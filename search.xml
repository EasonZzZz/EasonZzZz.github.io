<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>最短路径和最小生成树</title>
      <link href="/2019/11/26/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%92%8C%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2019/11/26/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%92%8C%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>学习数据结构的时候一直忘记了区分这两个，现在正是用博客记录一下。</p><h1 id="一-区别"><a class="markdownIt-Anchor" href="#一-区别"></a> 一、区别</h1><ul><li>最小生成树能保证整个拓扑图的 <strong>所有路径权值之和最小</strong> ，但是不能保证 <strong>任意两点间是最短路径</strong></li><li>最短路径是从 <strong>一点</strong> 出发，到达目的地的路径权值和最小</li></ul><h1 id="二-实现算法"><a class="markdownIt-Anchor" href="#二-实现算法"></a> 二、实现算法</h1><h2 id="最短路径"><a class="markdownIt-Anchor" href="#最短路径"></a> 最短路径</h2><h3 id="dijkstra算法"><a class="markdownIt-Anchor" href="#dijkstra算法"></a> Dijkstra算法</h3><ol><li>指定一个节点为初始点，将其看作一个 <strong>集合S</strong> ，剩余的点看作 <strong>另一个集合U</strong></li><li>根据初始点，求出到其他点的距离 <strong>d[i]</strong>（若相邻，则为边的权值；若不相邻，则为 ∞ ）</li><li>选择最小的<strong>d[i]</strong>，并将其<strong>加入集合S</strong>，在<strong>U中去除</strong>它，暂时用x标记</li><li>再根据x，<strong>更新</strong>跟x相邻点y的d[y]的值：<strong>d[y] = min{ d[y], d[x] + w[x][y] }</strong>，则个操作有可能把距离调小，也有可能没变化，因而称为<strong>松弛操作</strong></li><li>重复3，4两步操作，直至<strong>集合S包括所有的点</strong>，即<strong>集合U为空集</strong>时，求得初始点到其他所有点的最短路径</li></ol><ul><li>时间复杂度 <strong>O(e*logv)</strong></li></ul><h2 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树"></a> 最小生成树</h2><h3 id="prim算法"><a class="markdownIt-Anchor" href="#prim算法"></a> Prim算法</h3><ol><li>选择任意节点为起始点，加入<strong>点集合V</strong>，初始化<strong>边集合E为空</strong></li><li>选取<strong>集合V中的点</strong>到<strong>剩余节点</strong>的<strong>最小权值边</strong>，加入E，然后把该边连接的节点加入V</li><li>重复以上步骤，直至<strong>集合V包括所有的节点</strong></li><li>所求的 <strong>{V，E}</strong> 就是最小生成树</li></ol><ul><li>时间复杂度取决于图的存储方式<ul><li>邻接矩阵 <strong>O(v^2)</strong></li><li>邻接表 <strong>O(e*logv)</strong></li></ul></li></ul><h3 id="kruskal算法"><a class="markdownIt-Anchor" href="#kruskal算法"></a> Kruskal算法</h3><ol><li>新建图 <strong>{V,E}</strong>，<strong>V有原来图的所有顶点</strong>，而 <strong>E为空集</strong>，因而每个节点自成一个连通分量</li><li>在原图的边中选择权值最小的边<ol><li>若该边依附的顶点落在新建图中 <strong>不同的连通分量</strong>，则将此边加入E</li><li>否则舍去此边，寻找下一条权值最小的边</li></ol></li><li>以此类推，直至新建图 <strong>所有的节点在同一连通分量</strong></li></ol><ul><li>时间复杂度 <strong>O(eloge)</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串运算</title>
      <link href="/2019/11/10/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%90%E7%AE%97/"/>
      <url>/2019/11/10/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>实现字符串的加，乘法</p><a id="more"></a><p>一. 加法利用双指针，和人工的竖式运算相同<br>二. 乘法有两个版本：</p><ol><li>版本一为竖式运算普通版</li><li>版本二是优化版的竖式运算。<br>该算法是通过两数相乘时，乘数某位与被乘数某位相乘，与产生结果的位置的规律来完成。具体规律如下：<ul><li>乘数 num1 位数为 M，被乘数 num2 位数为 N， num1 x num2 结果 ans 最大总位数为 M+N，最小位数为 M+N-1</li><li>num[i] x num[j] 的结果 temp (为两位数，“0x&quot;或者&quot;xy”),其第一位位于 ans[i+j]，第二位位于 ans[i+j+1]</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span></span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">int</span> i = num1.length()-<span class="number">1</span>, j = num2.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = n1 + n2 + carry;</span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">        sb.append(temp % <span class="number">10</span>);</span><br><span class="line">        i--;j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry==<span class="number">1</span>) sb.append(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>))   <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    String ans = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num2.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = num2.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num2.length()-i-<span class="number">1</span>;j++)<span class="comment">//补零</span></span><br><span class="line">            sb.append(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = num1.length() - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--)&#123;<span class="comment">//计算 n2*num1</span></span><br><span class="line">            <span class="keyword">int</span> n1 = num1.charAt(k) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = n1 * n2 + carry;</span><br><span class="line">            sb.append(temp%<span class="number">10</span>);</span><br><span class="line">            carry = temp/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>) sb.append(carry);</span><br><span class="line">        ans = addStrings(ans, sb.reverse().toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">multiplyPlus</span><span class="params">(String num1, String num2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>))   <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[num1.length() + num2.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = num2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(n1 == <span class="number">0</span> || n2 ==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = n1 * n2 + ans[i+j+<span class="number">1</span>];</span><br><span class="line">            ans[i+j+<span class="number">1</span>] = temp % <span class="number">10</span>;</span><br><span class="line">            ans[i+j] += temp / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">        <span class="comment">//两个数相乘，位数是n+m(全9)或者n+m-1(只有一个1)，因此只有i=0的时候，才有可能抛弃一位0</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ans[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        result.append(ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长的回文子串</title>
      <link href="/2019/11/09/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E6%9C%80%E9%95%BF%E7%9A%84%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2019/11/09/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E6%9C%80%E9%95%BF%E7%9A%84%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串 s，找到 s 中最长的回文子串。</p><a id="more"></a><h1 id="暴力法"><a class="markdownIt-Anchor" href="#暴力法"></a> 暴力法</h1><p>找出所有的子串，判断它是不是回文串</p><ul><li>时间复杂度O(n^3)</li></ul><h1 id="暴力法优化动态规划"><a class="markdownIt-Anchor" href="#暴力法优化动态规划"></a> 暴力法优化(动态规划)</h1><p>首先定义一个二维数组 <em>P(i,j)</em>,<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191110165844.png" class="lazyload"><br>接下来<br>P(i,j) = (P(i+1,j-1) &amp;&amp; S[i]==S[j])<br>因此，我们不需要去判断S[i,j]是不是回文串，而是通过P(i+1,j-1)和S[i]==S[j]判断，这样时间复杂度减少了O(n)，利用动态规划，空间换时间</p><p>求 长度为 1 和长度为 2 的 P(i,j) 时不能用上边的公式，因为我们代入公式后会遇到 P[i][j] 中 i &gt; j 的情况，比如求 P[1][2] 的话，我们需要知道 P[1+1][2-1]=P[2][1]P[1+1][2−1]=P[2][1] ，而 P[2][1]P[2][1] 代表着 S[2,1] 是不是回文串，显然是不对的，所以我们需要单独判断。</p><p>所以我们先初始化长度是 1 的回文串的 P[i,j]，这样利用上边提出的公式 P(i,j)=(P(i+1,j−1)&amp;&amp;S[i]==S[j])，然后两边向外各扩充一个字符，长度为 3 的，为 5 的，所有奇数长度的就都求出来了。<br>同理，先初始化长度为2的回文串，然后所有偶数长度也能求出</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] P = <span class="keyword">new</span> <span class="keyword">boolean</span>[length][length];</span><br><span class="line">    String ans = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> ansLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= length; len++)&#123;<span class="comment">//遍历所有长度的子串，1~length</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; length; start++)&#123;</span><br><span class="line">            <span class="keyword">int</span> end = start + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(end &gt;= length)<span class="comment">//越界</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            P[start][end] = (len==<span class="number">1</span> || len == <span class="number">2</span> || P[start+<span class="number">1</span>][end-<span class="number">1</span>]) &amp;&amp; s.charAt(start) == s.charAt(end);</span><br><span class="line">            <span class="keyword">if</span>(len&gt;ansLen &amp;&amp; P[start][end])&#123;</span><br><span class="line">                ansLen = len;</span><br><span class="line">                ans = s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="中心扩散法"><a class="markdownIt-Anchor" href="#中心扩散法"></a> 中心扩散法</h1><p>事实上，只需使用恒定的空间，我们就可以在O(n^2)的时间内解决这个问题。</p><p>我们观察到回文中心的两侧互为镜像。因此，回文可以从它的中心展开，并且只有 2n−1 个这样的中心。</p><p>你可能会问，为什么会是 2n−1 个，而不是 n 个中心？原因在于所含字母数为偶数的回文的中心可以处于两字母之间的间隙（例如 “abba” 的中心在两个 ‘b’ 之间）。</p><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);<span class="comment">//字符</span></span><br><span class="line">        <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);<span class="comment">//间隙</span></span><br><span class="line">        <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">            start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            end = i + len / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//left == right，则以字符为中心，传出一个奇数</span></span><br><span class="line">    <span class="comment">//反之，以i，j的间隙为中心，传出一个偶数</span></span><br><span class="line">    <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">    <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">        L--;</span><br><span class="line">        R++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里要小心，跳出 while 循环时，已经不满足 s.charAt(L) == s.charAt(R)</span></span><br><span class="line">    <span class="comment">// 因此L，R与实际匹配的位置多了一次自增自减，因此要 R-L-1,不然原本应该为 R-L+1</span></span><br><span class="line">    <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="manacher马拉车-算法"><a class="markdownIt-Anchor" href="#manacher马拉车-算法"></a> Manacher(马拉车) 算法</h1><p>TBD</p>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode LCP</title>
      <link href="/2019/11/06/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/LeeCode-LCP/"/>
      <url>/2019/11/06/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/LeeCode-LCP/</url>
      
        <content type="html"><![CDATA[<p>LeetCode LCP</p><a id="more"></a><h1 id="lcp1"><a class="markdownIt-Anchor" href="#lcp1"></a> LCP1</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>小A和小B在玩猜数字。小B每次从 1, 2, 3 中随机选择一个，小A每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回小A猜对了几次？</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">game</span><span class="params">(<span class="keyword">int</span>[] guess, <span class="keyword">int</span>[] answer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*int count = 0;</span></span><br><span class="line"><span class="comment">    for(int i = 0 ; i &lt; 3; i++)</span></span><br><span class="line"><span class="comment">        if(guess[i] == answer[i]) count++;</span></span><br><span class="line"><span class="comment">    return count;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用循环时间复杂度较高</span></span><br><span class="line">    <span class="keyword">return</span> (guess[<span class="number">0</span>]==answer[<span class="number">0</span>]?<span class="number">1</span>:<span class="number">0</span>)+(guess[<span class="number">1</span>]==answer[<span class="number">1</span>]?<span class="number">1</span>:<span class="number">0</span>)+(guess[<span class="number">2</span>]==answer[<span class="number">2</span>]?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lcp2"><a class="markdownIt-Anchor" href="#lcp2"></a> LCP2</h1><h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2><p>有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191106210354.png" class="lazyload"><br>输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。返回一个长度为2的数组[n, m]，使得连分数的值等于n / m，且n, m最大公约数为1。</p><h2 id="不需要约分"><a class="markdownIt-Anchor" href="#不需要约分"></a> 不需要约分</h2><p>假设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mfrac><mi>n</mi><mi>d</mi></mfrac></mrow><annotation encoding="application/x-tex">a+\frac{n}{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>中的 <strong>n和d已经约分</strong>，<br>通分后：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>a</mi><mo>∗</mo><mi>d</mi><mo>+</mo><mi>n</mi></mrow><mi>d</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{a*d+n}{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight">d</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>如果需要约分，那么 a<em>d+n 和 d 能写成 x</em>c，y*c，c是公约数，且不为1</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∗</mo><mi>c</mi><mo>=</mo><mi>a</mi><mo>∗</mo><mi>d</mi><mo>+</mo><mi>n</mi><mo>=</mo><mi>a</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>y</mi><mo>∗</mo><mi>c</mi><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">x*c = a*d+n = a*(y*c)+n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span></p><p>那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>a</mi><mo>∗</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">n = (x - a*y)*c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> ，又 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>=</mo><mi>y</mi><mo>∗</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">d = y*c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> ，所以 <strong>n与d有非1的公约数</strong>，与假设矛盾，因此：<strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>a</mi><mo>∗</mo><mi>d</mi><mo>+</mo><mi>n</mi></mrow><mi>d</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{a*d+n}{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight">d</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>不需要约分</strong></p><h2 id="规律"><a class="markdownIt-Anchor" href="#规律"></a> 规律</h2><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191106212849.png" class="lazyload"></p><h2 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] fraction(<span class="keyword">int</span>[] cont) &#123;</span><br><span class="line">    <span class="keyword">int</span> up = <span class="number">1</span>, down = cont[cont.length-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cont.length-<span class="number">2</span>; i &gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">        up += down*cont[i];</span><br><span class="line">        temp = up; up = down; down = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;down,up&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lcp3"><a class="markdownIt-Anchor" href="#lcp3"></a> LCP3</h1><h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191107205446.png" class="lazyload"></p><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><ol><li>判断终点是否在路径内，如果没有，就直接 <em>return false</em>，如果没有接着判断</li><li>先删除在目标后面障碍，因为在目标后面无需再遍历，然后遍历障碍数组，判断是否有障碍在路径内，如果有则 <em>return false</em></li><li>以上全不 <em>false</em> 的话，就可返回 <em>true</em></li></ol><ul><li>写一个判断方法 <em>reach</em> 更加方便，但是Java不能方法内写方法，所以传入较多的参数</li><li><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191107205355.png" class="lazyload"></li></ul><p>啦啦啦<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191107205519.png" class="lazyload"></p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">robot</span><span class="params">(String command, <span class="keyword">int</span>[][] obstacles, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] cmd = command.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, u = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//String转化为char[]数组容易遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : cmd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'U'</span>) u++;</span><br><span class="line">        <span class="keyword">else</span> r++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!reach(r, u, x, y, cmd)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逻辑上删除在目标后面的障碍</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obstacles.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (obstacles[i][<span class="number">0</span>] &lt;= x &amp;&amp; obstacles[i][<span class="number">1</span>] &lt;= y) &#123;</span><br><span class="line">            obstacles[index][<span class="number">0</span>] = obstacles[i][<span class="number">0</span>];</span><br><span class="line">            obstacles[index][<span class="number">1</span>] = obstacles[i][<span class="number">1</span>];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断目标前面的障碍是否在路径上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (reach(r, u, obstacles[i][<span class="number">0</span>], obstacles[i][<span class="number">1</span>], cmd)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">reach</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> u, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span>[] cmd)</span></span>&#123;</span><br><span class="line">    <span class="comment">//求出最小的循环次数</span></span><br><span class="line">    <span class="keyword">int</span> i = Math.min(x/r,y/u);</span><br><span class="line">    <span class="keyword">int</span> nx = i*r, ny = i*u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : cmd)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nx == x &amp;&amp; ny == y)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'U'</span>) ny+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>         nx+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lcp4"><a class="markdownIt-Anchor" href="#lcp4"></a> LCP4</h1><h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191110165924.png" class="lazyload"></p><h2 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h2><p>这是求 <strong>二分图的最大匹配</strong> ，用到的是匈牙利算法，CSDN上有个<a href="https://blog.csdn.net/Dark_Scope/article/details/8880547" target="_blank" rel="noopener">趣写算法系列之–匈牙利算法</a>，讲的很形象</p><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[][] board;<span class="comment">//棋盘，false代表坏点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] dir = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;<span class="comment">//上下左右四个顶点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] link;<span class="comment">//link[v2] = v1,表示目前v1，v2相连</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] visit;<span class="comment">//查找顶点是否被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">domino</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span>[][] broken)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (broken.length == <span class="number">0</span> )&#123;<span class="comment">//棋盘无坏点，直接返回 棋盘个数/2</span></span><br><span class="line">        <span class="keyword">return</span> n * m &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    board = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">boolean</span>[] i : board)&#123;<span class="comment">//棋盘全部初始化为true</span></span><br><span class="line">        Arrays.fill(i,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] i : broken)&#123;<span class="comment">//坏点设为false</span></span><br><span class="line">        board[i[<span class="number">0</span>]][i[<span class="number">1</span>]] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hungary();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span></span>&#123;<span class="comment">//匈牙利算法，返回最大匹配数</span></span><br><span class="line">    <span class="keyword">int</span> maxOfMatch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = board.length, m = board[<span class="number">0</span>].length;</span><br><span class="line">    visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[n*m];<span class="comment">//用一维数组存储二维数组</span></span><br><span class="line">    link = <span class="keyword">new</span> <span class="keyword">int</span>[n*m];</span><br><span class="line">    Arrays.fill(link, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; r++) &#123;<span class="comment">//遍历v1中的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = ((r&amp;<span class="number">1</span>) == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>); c &lt; m; c+=<span class="number">2</span>)&#123;<span class="comment">//让遍历的点不相邻</span></span><br><span class="line">            <span class="keyword">if</span> (board[r][c])&#123;</span><br><span class="line">                Arrays.fill(visit,<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (find(r,c))&#123;</span><br><span class="line">                    maxOfMatch++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxOfMatch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.length, m = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] d : dir)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = row + d[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> c = col + d[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= n || c &gt;= m)&#123;<span class="comment">//越界</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v2 = r * m + c;</span><br><span class="line">        <span class="keyword">if</span> (board [r] [c] &amp;&amp; !visit[v2])&#123;</span><br><span class="line">            visit[v2] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (link[v2] == -<span class="number">1</span> || find(link[v2]/m, link[v2]%m))&#123;<span class="comment">//因为link是用一维数组存储二维数组</span></span><br><span class="line">                link[v2] = row * m + col;                       <span class="comment">//因此row = link[v2]/m, col = lin[v2]%m，由左式可知</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数排序和桶排序</title>
      <link href="/2019/11/05/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%92%8C%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/11/05/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%92%8C%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>比快排更快的算法，在理想情况下，甚至可以做到线性时间的复杂度</p><a id="more"></a><p>以前学过的排序都是基于 <strong>元素之间的比较</strong> 来进行排序的，但是有一些特殊的排序并不基于元素比较，<br>如：计数排序，桶排序，基数排序，</p><ul><li>以计数排序来说，这种算法是利用数组下标来确定元素的位置</li><li>基数排序是将多位数分成个位数进行计数排序</li><li>桶排序是每一个桶代表一个区间范围</li></ul><h1 id="计数排序"><a class="markdownIt-Anchor" href="#计数排序"></a> 计数排序</h1><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><ol><li>创建一个统计数组，数组长度为 <strong>数列的最大值 - 数列的最小值 + 1</strong>，</li><li>同时数列的最小值作为一个偏移量，用于计算整数在统计数组的下标</li><li>遍历无序数列，将元素填入统计数组 <strong>元素值 - 偏移量</strong> 的位置</li><li>对统计数组进行变形，每一个元素都加上前面所有元素之和。<blockquote><p>为什么相加呢？是让统计数组储存的元素值，等于相应整数的最终排序位置的序号。<br>例如：下标为9的元素值为5，那么代表原始数列的整数9，最终排序在第5位</p></blockquote></li><li>倒序遍历数组，从统计数组找到正确的位置，输出到结果数组<blockquote><p>为什么倒序？为了不改变原有顺序，使之稳定</p></blockquote></li></ol><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">     <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">int</span> min = array[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">         <span class="keyword">if</span> (array[i] &gt; max) max = array[i];</span><br><span class="line">         <span class="keyword">if</span> (array[i] &lt; min) min = array[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> d = max -min;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//填写统计数组</span></span><br><span class="line">     <span class="keyword">int</span>[] countArray = <span class="keyword">new</span> <span class="keyword">int</span> [d+<span class="number">1</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">         countArray[array[i] - min]++;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//统计数组变形</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; countArray.length; i++)</span><br><span class="line">         countArray[i] += countArray[i-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">     <span class="comment">//倒序遍历原始数组</span></span><br><span class="line">     <span class="keyword">int</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span>  i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">         sortedArray[countArray[array [i] - min] - <span class="number">1</span>] = array[i];</span><br><span class="line">         countArray[array [i] - min]--;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> sortedArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h2><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><ul><li>时间复杂度仅为O(n+m)</li><li>空间复杂度为O(m)</li></ul><h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3><ol><li>当数列最大和最小值差距过大时，空间浪费，时间复杂度增加</li><li>必须为整数</li></ol><h1 id="桶排序"><a class="markdownIt-Anchor" href="#桶排序"></a> 桶排序</h1><p>桶排序同样是一种线性时间的排序算法。类似于计数排序所创建的统计数组，桶排序需要创建若干个桶来协助排序。</p><ul><li>每一个桶(bucket)代表一个区间范围，里面可以承载一个或多个元素</li></ul><h2 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h2><ol><li>创建若干个桶，并确定每一个桶的区间范围<blockquote><p>创建几个桶，确定区间范围，有很多种不同的方式。我们这里创建的桶数量等于原始数列的元素数量，<em>除了最后一个桶只包含数列最大值外，前面各个桶的区间按照比例来确定</em></p></blockquote></li><li>遍历原始数列，把元素对号入座放入各个桶中</li><li>对每个桶内部的元素分别进行排序</li><li>遍历所有的桶，输出所有元素</li></ol><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] bucketSort(<span class="keyword">double</span>[] array)&#123;</span><br><span class="line">     <span class="keyword">double</span> max = array[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">double</span> min = array[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">         <span class="keyword">if</span> (array[i] &gt; max) max = array[i];</span><br><span class="line">         <span class="keyword">if</span> (array[i] &lt; min) min = array[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">double</span> d = max - min;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> bucketNum = <span class="number">9</span>;</span><br><span class="line">     ArrayList&lt;LinkedList &lt;Double&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;LinkedList &lt;Double&gt;&gt;(bucketNum);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++)</span><br><span class="line">         bucketList.add(<span class="keyword">new</span> LinkedList&lt;Double&gt; ());</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">         <span class="keyword">int</span> num = (<span class="keyword">int</span>)((array[i] - min)*(bucketNum-<span class="number">1</span>)/d);</span><br><span class="line">         bucketList.get(num).add(array[i]);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketList.size(); i++)</span><br><span class="line">         <span class="comment">//JDK底层采用了归并排序或归并的优化版本</span></span><br><span class="line">         Collections.sort(bucketList.get(i));</span><br><span class="line"></span><br><span class="line">     <span class="keyword">double</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">double</span>[array.length];</span><br><span class="line">     <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//增强版的for只能遍历，不能修改值</span></span><br><span class="line">     <span class="keyword">for</span>(LinkedList&lt;Double&gt; list : bucketList) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">double</span> element : list) &#123;</span><br><span class="line">             sortedArray[index++] = element;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> sortedArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优缺点-2"><a class="markdownIt-Anchor" href="#优缺点-2"></a> 优缺点</h2><h3 id="优点-2"><a class="markdownIt-Anchor" href="#优点-2"></a> 优点</h3><ul><li>时间复杂度仅为O(n)</li><li>空间复杂度为O(m)</li></ul><h3 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h3><p>不稳定，第一个桶有n-1个元素，最后一个桶只有一个，此时时间复杂度退化为O(nlogn)，而且白白的创建了许多空桶</p>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2019/11/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/11/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>堆排序是利用二叉堆的特性完成的排序。</p><a id="more"></a><h1 id="二叉堆的特性"><a class="markdownIt-Anchor" href="#二叉堆的特性"></a> 二叉堆的特性</h1><ol><li>最大堆的堆顶是整个堆中最大的元素</li><li>最小堆的堆顶是整个堆中最小的元素</li></ol><ul><li>以最大堆为例，如果删除一个最大堆的堆顶(并不是完全删除，而是跟末尾节点交换位置，然后退出堆)，经过自我调整，第二大的元素就会成为堆顶元素，往复 n-1次即可完成排序</li></ul><h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1><ol><li>把无序数组构建成二叉堆。需要从小到大排序，则构成最大堆；反之，构成最小堆。</li><li>循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶</li></ol><h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下沉调整堆</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parentIndex, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">int</span> childIndex = <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(childIndex &lt; length)&#123;</span><br><span class="line">    <span class="comment">//如果有右孩子，且右孩子的值大于左孩子，则定位到右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(childIndex+<span class="number">1</span> &lt; length &amp;&amp; array[childIndex+<span class="number">1</span>] &gt; array[childIndex])</span><br><span class="line">            childIndex++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果父节点小于任何一个孩子的值，则直接跳出</span></span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= array[childIndex])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">        array[parentIndex] = array[childIndex];</span><br><span class="line">        parentIndex = childIndex;</span><br><span class="line">        childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array[parentIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序(升序)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.将无序数组建成最大堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = array.length/<span class="number">2</span>; i &gt;=<span class="number">0</span>; i--)</span><br><span class="line">        downAdjust(array,i,array.length-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = array.length-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于第一次的调整建成了最大堆，所以堆顶的左右孩子只比最大的元素小，</span></span><br><span class="line">        <span class="comment">//因而只需将堆顶的元素下沉即可重新得到最大堆，参照堆的删除节点操作</span></span><br><span class="line">        downAdjust(array, <span class="number">0</span> ,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h1><p>下沉调整的空间复杂度为O(logn)，需要调整n次，因此时间复杂度为O(nlogn)</p><ul><li>构建堆的时间复杂度为O(n)，而不是(nlogn)</li><li>堆的插入和删除的时间复杂度都是O(logn)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2019/11/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/11/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。</p><a id="more"></a><h1 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h1><p>动态规划与分治法类似，其基本思想也是 <strong>将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</strong>。<br>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。<br>如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，即 <strong>重复利用子问题的答案</strong> 这样就可以避免大量的重复计算，节省时间，这就是动态规划的优势。</p><h1 id="设计步骤"><a class="markdownIt-Anchor" href="#设计步骤"></a> 设计步骤</h1><h2 id="基本步骤"><a class="markdownIt-Anchor" href="#基本步骤"></a> 基本步骤</h2><ol><li><p>划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p></li><li><p>确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足 <em>无后效性</em> 。</p></li><li><p>确定决策并写出 <em><strong>状态转移方程</strong></em>：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p></li><li><p>寻找边界条件：给出的状态转移方程是一个 <em>递推式</em>，需要一个递推的 <em>终止条件或边界条件</em> 。</p></li></ol><h2 id="简化"><a class="markdownIt-Anchor" href="#简化"></a> 简化</h2><p>一般，只要 <strong>解决问题的阶段、状态</strong> 和 <strong>状态转移决策</strong> 确定了，就可以写出 <strong>状态转移方程（包括边界条件）</strong>。实际应用中可以按以下几个简化的步骤进行设计：</p><ol><li>分析最优解的性质，并刻画其结构特征。</li><li>递归的定义最优解。</li><li>以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</li><li>根据计算最优值时得到的信息，构造问题的最优解。</li></ol><h1 id="适用条件"><a class="markdownIt-Anchor" href="#适用条件"></a> 适用条件</h1><ol><li><p><strong>最优化原理</strong>（最优子结构性质）：最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。</p></li><li><p><strong>无后效性</strong>：将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。</p></li><li><p><strong>子问题的重叠性</strong>：动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于 <strong>解决冗余</strong> ，这是动态规划算法的根本目的。动态规划实质上是一种以 <strong>空间换时间</strong> 的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。</p></li></ol><h1 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h1><p>动态规划一般可分为 <strong>线性动规</strong>，<strong>区域动规</strong>，<strong>树形动规</strong>，<strong>背包动规</strong>四类。<br>举例：</p><ul><li>线性动规：拦截导弹，合唱队形，挖地雷，建学校，剑客决斗等；</li><li>区域动规：石子合并， 加分二叉树，统计单词个数，炮兵布阵等；</li><li>树形动规：贪吃的九头龙，二分查找树，聚会的欢乐，数字三角形等；</li><li>背包问题：01背包问题，完全背包问题，分组背包问题，二维背包，装箱问题，挤牛奶（同济ACM第1132题）等；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位为1的个数</title>
      <link href="/2019/11/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E4%BD%8D%E4%B8%BA1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2019/11/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E4%BD%8D%E4%B8%BA1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><a id="more"></a><h1 id="循环和位移动"><a class="markdownIt-Anchor" href="#循环和位移动"></a> 循环和位移动</h1><p>这个方法比较直接。我们遍历数字的 32 位。如果最后一位是 1 ，将计数器加一，然后数字右移。<br>任何数字和 <strong>掩码1</strong> 进行按位与运算，可以让我们获得最后一位数字，检查下一位时，掩码左移或者参数右移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">            bits++;</span><br><span class="line">        &#125;</span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="位移动的小技巧"><a class="markdownIt-Anchor" href="#位移动的小技巧"></a> 位移动的小技巧</h1><p>我们可以把前面的算法进行优化。我们不再检查数字的每一个位，而是不断把数字最后一个 1 反转，并把答案加一。当数字变成 0 的时候，我们就知道它没有 1 的位了，此时返回答案。<br>这里关键的想法是对于任意数字n，将 <em>n</em> 和 <em>n-1</em> 做与运算，会把最后一个 1 的位变成 0 。为什么？考虑 n 和 n−1 的二进制表示。<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191101174947.png" class="lazyload"><br>在二进制表示中，数字 n 中最低位的 1 总是对应 n−1 中的 0 。因此，将 n 和 n−1 与运算总是能把 n 中最低位的 1 变成 0 ，并保持其他位不变。</p><ul><li>之前学到，可以利用这个判断一个数是不是2的整次幂，如果是2的整次幂，则 <strong>最低位为1</strong> 的就是 <strong>最高位</strong> ，因此 <strong>n&amp;n-1</strong>就会得到0</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 数 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fizz Buzz</title>
      <link href="/2019/11/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/Fizz%20Buzz/"/>
      <url>/2019/11/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/Fizz%20Buzz/</url>
      
        <content type="html"><![CDATA[<p>写一个程序，输出从 1 到 n 数字的字符串表示。</p><ol><li>如果 n 是3的倍数，输出“Fizz”；</li><li>如果 n 是5的倍数，输出“Buzz”；</li><li>如果 n 同时是3和5的倍数，输出 “FizzBuzz”。</li></ol><a id="more"></a><h1 id="暴力法"><a class="markdownIt-Anchor" href="#暴力法"></a> 暴力法</h1><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><ol><li>初始化一个空的答案列表。</li><li>遍历 1 … N1…N。</li><li>对于每个数，判断它能不能同时被 3 和 5 整除，如果可以就把 FizzBuzz 加入答案列表。</li><li>如果不行，判断它能不能被 3 整除，如果可以，把 Fizz 加入答案列表。</li><li>如果还是不行，判断它能不能被 5 整除，如果可以，把 Buzz 加入答案列表。</li><li>如果以上都不行，把这个数加入答案列表。</li></ol><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= n; num++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> divisibleBy3 = (num % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">boolean</span> divisibleBy5 = (num % <span class="number">5</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (divisibleBy3 &amp;&amp; divisibleBy5)</span><br><span class="line">        ans.add(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (divisibleBy3)</span><br><span class="line">        ans.add(<span class="string">"Fizz"</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (divisibleBy5)</span><br><span class="line">        ans.add(<span class="string">"Buzz"</span>);</span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">        ans.add(num + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="字符串连接"><a class="markdownIt-Anchor" href="#字符串连接"></a> 字符串连接</h1><p>这个方法不会降低渐进复杂度，但是当 FizzBuzz 的规则变得更复杂的时候，这将会是个更优雅的解法。比方说，玩个 FizzBuzzJazz 的游戏。</p><h2 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h2><p>我们放弃使用之前的联合判断，取而代之依次判断是否能被给定的数整数。这道题中，就是依次判断能不能被 3 整除，能不能被 5 整除。如果能被 3 整除，就把对应的 Fizz 连接到答案字符串，如果能被 5 整除，就把 Buzz 连接到答案字符串。</p><h2 id="实现-2"><a class="markdownIt-Anchor" href="#实现-2"></a> 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= n; num++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> divisibleBy3 = (num % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">boolean</span> divisibleBy5 = (num % <span class="number">5</span> == <span class="number">0</span>);</span><br><span class="line">        String s = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(divisibleBy3) s += <span class="string">"Fizz"</span>;</span><br><span class="line">        <span class="keyword">if</span>(divisibleBy5) s += <span class="string">"Buzz"</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">""</span>) s += num;</span><br><span class="line"></span><br><span class="line">        ans.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="散列表"><a class="markdownIt-Anchor" href="#散列表"></a> 散列表</h1><p>这个方法是对方法二的优化。当数字和答案的映射是定好的，那么方法二用起来也还可以。但是如果你遇到一个变态的面试官，他跟你说他需要更自由的映射关系呢？<br>每个映射一个判断显然是不可行的，这样写出来的代码一定是丑陋不堪且难以维护的。<br>如果老板有这样一个需求，明天你把映射关系换掉或者删除一个映射关系吧。对于这种要求，我们只能一个个去修改判断条件的代码。</p><h2 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h2><p>但我们实际上有个更优雅的做法，那就是把映射关系放在 <em>散列表</em> 里面。</p><ol><li>把所有的映射关系放在散列表 fizzBuzzHash 中，这个散列表形如 { 3: ‘Fizz’, 5: ‘Buzz’ }。</li><li>遍历 1 … N。</li><li>对于每个数字，遍历 fizzBuzzHash 中的键，检查是否能被它整除。</li><li>如果这个数能被键整除，就把当前键映射的值加到到答案字符串后面去。对于散列表的每个键值对，都这样操作。</li><li>最后将答案字符串加入答案列表。</li></ol><ul><li>通过这样的方式你可以对散列表 <em>添加/删除</em> 映射关系，同时还不需要修改太多代码。</li></ul><h2 id="实现-3"><a class="markdownIt-Anchor" href="#实现-3"></a> 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ans list</span></span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hash map to store all fizzbuzz mappings.</span></span><br><span class="line">    HashMap&lt;Integer, String&gt; fizzBizzDict =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;Integer, String&gt;() &#123;</span><br><span class="line">          &#123;</span><br><span class="line">            put(<span class="number">3</span>, <span class="string">"Fizz"</span>);</span><br><span class="line">            put(<span class="number">5</span>, <span class="string">"Buzz"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= n; num++) &#123;</span><br><span class="line"></span><br><span class="line">      String numAnsStr = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Integer key : fizzBizzDict.keySet()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the num is divisible by key,</span></span><br><span class="line">        <span class="comment">// then add the corresponding string mapping to current numAnsStr</span></span><br><span class="line">        <span class="keyword">if</span> (num % key == <span class="number">0</span>) &#123;</span><br><span class="line">          numAnsStr += fizzBizzDict.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (numAnsStr.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="comment">// Not divisible by 3 or 5, add the number</span></span><br><span class="line">        numAnsStr += Integer.toString(num);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Append the current answer str to the ans list</span></span><br><span class="line">      ans.add(numAnsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2019/10/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/10/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>生活中的排序无处不在，因此在算法中也无处不在，排序看似简单，但是有着各种各样的算法和思想。</p><a id="more"></a><h1 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h1><h2 id="根据时间复杂度的不同主流的排序算法可以分为3大类"><a class="markdownIt-Anchor" href="#根据时间复杂度的不同主流的排序算法可以分为3大类"></a> 根据时间复杂度的不同，主流的排序算法可以分为3大类。</h2><ol><li>时间复杂度为 <em>O(n^2)</em></li></ol><ul><li>冒泡算法</li><li>选择排序</li><li>插入排序</li><li>希尔排序(希尔排序比较特殊，它的性能略优于O(n^2)，但又比不上O(nlogn))</li></ul><ol start="2"><li>时间复杂度为 <em>O(nlogn)</em></li></ol><ul><li>快速排序</li><li>归并排序</li><li>堆排序</li></ul><ol start="3"><li>时间复杂度为线性</li></ol><ul><li>计数排序</li><li>桶排序</li><li>基数排序</li></ul><h2 id="此外排序算法还划分为-稳定排序-和-不稳定排序"><a class="markdownIt-Anchor" href="#此外排序算法还划分为-稳定排序-和-不稳定排序"></a> 此外，排序算法还划分为 <strong>稳定排序</strong> 和 <strong>不稳定排序</strong></h2><p>如何划分稳定和不稳定：如果值相同的元素在排序后仍然保持排序前的顺序，排序算法就是稳定的</p><h1 id="总表"><a class="markdownIt-Anchor" href="#总表"></a> 总表</h1><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191103155227.png" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2019/10/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/10/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>同冒泡排序，快速排序也是交换排序</p><a id="more"></a><h1 id="思想"><a class="markdownIt-Anchor" href="#思想"></a> 思想</h1><p>每一轮挑选一个基准元素，并让其他比它大的元素移动到数列的一边，比它小的移动到另一边，从而把数列拆成两个部分，一个部分的数全部比基准元素打，另一个部分全部比它小。</p><ul><li>这种思想叫做 <strong>分治法</strong></li><li>原数列在每一轮都被拆成两部分，两部分中的每一部分又被拆成两部分，一直递归下去，直至不可再分，因此要遍历 <strong>logn</strong> 轮，而且每一轮的交换和比较要遍历数组，因此时间复杂度为 <strong>O(nlogn)</strong></li></ul><h1 id="基准元素的选择"><a class="markdownIt-Anchor" href="#基准元素的选择"></a> 基准元素的选择</h1><p>最简单的方式是选第一个元素，但是在数列基本有序，或者逆序的情况下，数列没有理想的被分为均匀的两半，<em>每一轮只确定基准元素的位置</em>，时间复杂度退化为O(n^2)</p><ul><li>解决方法：<strong>随机选择一个元素作为基准元素</strong>，并让基准元素和数列首位元素交换位置</li></ul><h1 id="元素的交换"><a class="markdownIt-Anchor" href="#元素的交换"></a> 元素的交换</h1><p>选定了基准元素以后，我们要做的就是把其他元素中小于基准元素都交换到基准元素的一边，大于它的交换到另一边。</p><h2 id="实现方法"><a class="markdownIt-Anchor" href="#实现方法"></a> 实现方法</h2><h3 id="双边循环法"><a class="markdownIt-Anchor" href="#双边循环法"></a> 双边循环法</h3><p>也就是数据结构中学的方法，为双指针法。</p><ul><li>首先选定基准元素pivot，并设置两个指针left，right，分别指向数组的最左边和最右边</li><li>进行循环，从right指针开始，让指针所指向的元素和基准元素做比较。<ol><li>如果大于或等于pivot，则right指针右移</li><li>如果小于pivot，则right指针停止移动，right和left指向的值互换，切换到left指针</li><li>让left指针指向的元素和基准元素作比较，如果小于等于pivot，则左移，反之停止移动，right和left指向的值互换，切换到right指针</li></ol></li><li>一直循环下去，直到 <strong>right == left</strong></li><li>最后把pivot的与两指针汇合处的元素与pivot互换，即完成第一次分治</li></ul><h4 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归结束条件，startIndex大于等于endIndex时</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex &gt;= endIndex) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span><br><span class="line">    <span class="comment">//根据基准元素，分成两部分进行递归快速排序</span></span><br><span class="line">    quickSort(arr, startIndex, pivotIndex-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex, endIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">//取第一个位置的元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> left = startIndex;</span><br><span class="line">    <span class="keyword">int</span> right = endIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left != right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt; pivot)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &lt;= pivot)</span><br><span class="line">            left++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换left和right指针所指向的元素</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = arr[left];</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            arr[right] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pivot和指针重合点交换</span></span><br><span class="line">    arr[startIndex] = arr[left];</span><br><span class="line">    arr[left] = pivot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单边循环法"><a class="markdownIt-Anchor" href="#单边循环法"></a> 单边循环法</h3><p>双边循环从数组的两边交替遍历元素，虽然更加直观，但是代码量较多。单边循环法只从数组的一边对元素进行遍历和交换。</p><ul><li>选定基准元素pivot，设置一个mark指针指向数列起始位置，这个mark指针代表 <strong>小于基准元素的区域边界</strong></li><li>接下来，从基准元素的下一个位置开始遍历数组<ol><li>如果遍历到的元素大于基准元素，就继续往后遍历</li><li>如果小于基准元素，需要做两件事：<br>第一，把mark指针右移一位，因为小于pivot的区域边界增加了1；<br>第二，让最新遍历到的元素和mark指针所在位置的元素互换，因为最新遍历的元素归属与小于pivot的区域</li></ol></li><li>按照这个思路，继续遍历，直至末位，最后把pivot元素交换到mark指针所在的位置，第一次分治结束</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归结束条件，startIndex大于等于endIndex时</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex &gt;= endIndex) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partitionV2(arr, startIndex, endIndex);</span><br><span class="line">    <span class="comment">//根据基准元素，分成两部分进行递归快速排序</span></span><br><span class="line">    quickSort(arr, startIndex, pivotIndex-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex+<span class="number">1</span>, endIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partitionV2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> mark = startIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex+<span class="number">1</span>; i &lt;= endIndex; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; pivot)&#123;</span><br><span class="line">            mark++;</span><br><span class="line">            <span class="keyword">int</span> p = arr[mark];</span><br><span class="line">            arr[mark] = arr[i];</span><br><span class="line">            arr[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[startIndex] = arr[mark];</span><br><span class="line">    arr[mark] = pivot;</span><br><span class="line">    <span class="keyword">return</span> mark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡算法</title>
      <link href="/2019/10/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/10/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>冒泡排序(bubble sort)是很经典的 <strong>交换排序</strong> 算法，为什么叫做冒泡，就是因为这个算法的每一个元素都像小气泡一样，根据自身大小，往数组的一侧移动。</p><a id="more"></a><h1 id="思想"><a class="markdownIt-Anchor" href="#思想"></a> 思想</h1><p>把相邻的元素两两比较，当一个元素大于右侧元素时，两个元素交换，如果没有，位置不变</p><ul><li>每一遍历完一轮，总有一个最大的元素移到最右侧</li><li>冒泡算法是一个稳定的算法</li><li>每一轮都要遍历所有没排序的元素，总共遍历 <em>n-1</em> 轮，因此时间复杂度为O(n^2)</li></ul><h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//有序标志，每一轮初值为true</span></span><br><span class="line">        <span class="comment">//如果是执行一轮过后还是true，就是没有进行交换，则数组以有序，循环结束</span></span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                isSorted = <span class="keyword">false</span>;<span class="comment">//发生了交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isSorted) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双向冒泡鸡尾酒排序"><a class="markdownIt-Anchor" href="#双向冒泡鸡尾酒排序"></a> 双向冒泡：鸡尾酒排序</h1><p>冒泡排序的每一个元素都是向右移动的，是单向的，鸡尾酒排序是 <strong>双向 的</strong>，奇数找最大的，偶数找最小的，但是代码量增加了一倍，在大部分元素有序的情况下，鸡尾酒排序更有优势</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doubleBubbleSort</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length/<span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//奇数轮</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; array.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                isSorted = <span class="keyword">false</span>;<span class="comment">//发生了交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSorted) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//偶数轮，重新标记</span></span><br><span class="line">        isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = array.length-i-<span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &lt;&gt; array[j-<span class="number">1</span>])&#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j-<span class="number">1</span>];</span><br><span class="line">                array[j-<span class="number">1</span>] = tmp;</span><br><span class="line">                isSorted = <span class="keyword">false</span>;<span class="comment">//发生了交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSorted) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断一个数是不是2的整次幂</title>
      <link href="/2019/10/29/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%98%AF%E4%B8%8D%E6%98%AF2%E7%9A%84%E6%95%B4%E6%AC%A1%E5%B9%82/"/>
      <url>/2019/10/29/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%98%AF%E4%B8%8D%E6%98%AF2%E7%9A%84%E6%95%B4%E6%AC%A1%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<ul><li>如果一个整数是2的整次幂，那么当它转化为二进制时，只有最高位时1，其他都是0</li><li>把这个整数减1后，二进制数全变成了1，原本最高位变为0</li><li>因此，只需要 <em>原数值</em> 和 <em>它减1的结果</em> 进行按位与运算，也就是 <strong>n&amp;(n-1)</strong> 是否为0，就可以判断它是不是2的整次幂</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">boolean</span> <span class="title">isPowerOf2</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (num &amp; num-<span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小栈的实现</title>
      <link href="/2019/10/28/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%9C%80%E5%B0%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/10/28/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%9C%80%E5%B0%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>实现一个栈，该栈带有出栈（pop），进栈（push），取最小元素（getMin）3个方法，保证时间复杂度为O(1).</p><a id="more"></a><p>如果只声明一个变量储存最小值是不够的，因为如果最小值出栈的话，怎么更新？<br>因而，我们需要储存栈中 <strong>曾经的最小值</strong>，作为“备胎”</p><h1 id="解法步骤"><a class="markdownIt-Anchor" href="#解法步骤"></a> 解法步骤</h1><ol><li>设原有栈为A，此时创建个额外的“备胎”栈B，用于辅助栈A。</li><li>当第一个元素进入栈A时，让新元素也进入栈B。因为这个唯一的元素时栈A目前最小值。</li><li>之后，每当新元素入栈A时，比较 <em>新元素</em> 和 <em>栈A目前最小值</em> 的大小，如果小于 <em>栈A目前的最小值</em>，则让新元素也入栈B，此时 <em>栈B的栈顶元素</em> 是 <em>栈A当前最小值</em>。</li><li>每当有栈A的元素出栈，如果 <em>出栈元素</em> 和 <em>栈B栈顶元素</em> 相同时，栈B栈顶元素也出栈，则接下去栈B栈顶元素变为栈A目前最小值，“备胎转正”。</li><li>当调用getMin()时，返回 <em>栈B的栈顶元素</em> ，这就是栈A目前最小值。</li></ol><ul><li>时间复杂度均是O(1)，最坏情况的空间复杂度为O(n)</li></ul><h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; mainStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> element)</span></span>&#123;</span><br><span class="line">    mainStack.push(element);</span><br><span class="line">    <span class="keyword">if</span>(mainStack.empty() || element &lt;= mainStack.peek())</span><br><span class="line">        mainStack.push(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mainStack.peek().equals(minStack.peek()))</span><br><span class="line">        minStack.pop();</span><br><span class="line">    <span class="keyword">return</span> mainStack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mainStack.empty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"stack is empty"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> minStack.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大公约数</title>
      <link href="/2019/10/28/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
      <url>/2019/10/28/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>求一个数的最大公约数，getGreatestCommonDivisor简称gcd</p><a id="more"></a><h1 id="辗转相除法"><a class="markdownIt-Anchor" href="#辗转相除法"></a> 辗转相除法</h1><p>又名 <em>欧几里得算法</em></p><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><p>两个正整数a，b（a&gt;b），它们的最大公约数等于 <em>a/b的余数</em> 和 <em>b</em> 之间的最大公约数</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> big = a&gt;b? a:b;</span><br><span class="line">    <span class="keyword">int</span> small = a&lt;b? a:b;</span><br><span class="line">    <span class="keyword">if</span>(big%small == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> gcd(big%small, small);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2><p>两个整数较大时，模运算性能较差</p><h1 id="更相减损术"><a class="markdownIt-Anchor" href="#更相减损术"></a> 更相减损术</h1><h2 id="原理-2"><a class="markdownIt-Anchor" href="#原理-2"></a> 原理</h2><p>两个正整数a，b（a&gt;b），它们的最大公约数等于 <em>a-b的差值</em> 和 <em>较小数b</em>的最大公约数</p><h2 id="实现-2"><a class="markdownIt-Anchor" href="#实现-2"></a> 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> big = a&gt;b? a:b;</span><br><span class="line">    <span class="keyword">int</span> small = a&lt;b? a:b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gcd(big-small, small);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h2><p>不稳定，当两个数悬殊巨大时，要计算多次，例如：100001和1</p><h1 id="移位运算法"><a class="markdownIt-Anchor" href="#移位运算法"></a> 移位运算法</h1><p>这个算法结合了 <em>辗转相除法</em> 和 *更相减损术 的优势，在更相减损术的基础上使用移位运算，整个算法只用到 <em>移位运算</em> 和 <em>减法</em></p><ul><li>这个算法在两个数比较小时看不出优势，但是当数比较大的时候，计算速度明显提高</li></ul><h2 id="原理-3"><a class="markdownIt-Anchor" href="#原理-3"></a> 原理</h2><p>两个正整数a，b（a&gt;b）</p><ol><li>gcd(a,a)=a，也就是一个数和其自身的公约数仍是其自身。</li><li>gcd(ka,kb)=k gcd(a,b)，也就是最大公约数运算和倍乘运算可以交换。特殊地，当k=2时，说明两个偶数的最大公约数必然能被2整除。</li><li>当k与b互为质数，gcd(ka,b)=gcd(a,b)，也就是约掉两个数中只有其中一个含有的因子不影响最大公约数。特殊地，当k=2时，说明计算一个偶数和一个奇数的最大公约数时，可以先将偶数除以2。</li></ol><h2 id="实现-3"><a class="markdownIt-Anchor" href="#实现-3"></a> 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcdPlus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//采用与1进行与的位运算判断奇偶数，速度更快</span></span><br><span class="line">    <span class="keyword">if</span>((a&amp;<span class="number">1</span>)==<span class="number">0</span> &amp;&amp; (b&amp;<span class="number">1</span>) ==<span class="number">0</span>)<span class="comment">//a，b均为偶数</span></span><br><span class="line">        <span class="keyword">return</span> gcdPlus(a&gt;&gt;<span class="number">1</span>, b&gt;&gt;<span class="number">1</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((a&amp;<span class="number">1</span>)==<span class="number">0</span> &amp;&amp; (b&amp;<span class="number">1</span>) !=<span class="number">0</span>)<span class="comment">//a为偶数，b为奇数</span></span><br><span class="line">        <span class="keyword">return</span> gcdPlus(a&gt;&gt;<span class="number">1</span>, b);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((a&amp;<span class="number">1</span>)==<span class="number">0</span> &amp;&amp; (b&amp;<span class="number">1</span>) !=<span class="number">0</span>)<span class="comment">//a为奇数，b为偶数</span></span><br><span class="line">        <span class="keyword">return</span> gcdPlus(a, b&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> big = a&gt;b? a:b;</span><br><span class="line">        <span class="keyword">int</span> small = a&lt;b? a:b;</span><br><span class="line">        <span class="keyword">return</span> gcdPlus(big-small, small);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h1><ol><li>暴力法：O(min(a, b))</li><li>辗转相除法：近似为O(log(max(a, b)))，但是模运算性能较差</li><li>更相减损术：算法不稳定，最坏为O(max(a, b))</li><li>移位运算法：不但避免模运算，而且稳定，复杂度为O(log(max(a, b)))</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断链表有环</title>
      <link href="/2019/10/27/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF/"/>
      <url>/2019/10/27/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p>有一个单向链表，如何判断链表是否为有环链表？</p><a id="more"></a><h1 id="hashset法"><a class="markdownIt-Anchor" href="#hashset法"></a> HashSet法</h1><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><ul><li>创建一个以节点ID为Key的HashSet集合</li><li>遍历链表并加入HashSet，判断是否重复，重复则有环</li></ul><h2 id="复杂度"><a class="markdownIt-Anchor" href="#复杂度"></a> 复杂度</h2><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul><h1 id="双指针追及法"><a class="markdownIt-Anchor" href="#双指针追及法"></a> 双指针追及法</h1><h2 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h2><ul><li>声明两个指针p1，p2，都指向头节点</li><li>p1为慢指针，速度一个节点，p2为快指针，速度两个节点，速度差一个节点</li><li>让两个指针开始跑，两个指针跑完一次，判断两个指针指向的节点是否相同，相同则有环，不同则继续下一次循环<br>这个思路类似于数学上的 <em>追及问题</em>，如果跑道是环形的，快指针会追上慢指针</li></ul><h2 id="复杂度-2"><a class="markdownIt-Anchor" href="#复杂度-2"></a> 复杂度</h2><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul><h2 id="源码"><a class="markdownIt-Anchor" href="#源码"></a> 源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCycle</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    Node p1 = head, p2 = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p2 != <span class="keyword">null</span> &amp;&amp; p2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ringMeetNode可以在这里获得</span></span><br><span class="line">        <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class Node&#123;</span></span><br><span class="line"><span class="comment">    int data;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node(int data)&#123;</span></span><br><span class="line"><span class="comment">        this.data = data;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="问题扩展"><a class="markdownIt-Anchor" href="#问题扩展"></a> 问题扩展</h1><h2 id="1如何求出环的长度"><a class="markdownIt-Anchor" href="#1如何求出环的长度"></a> 1.如何求出环的长度</h2><p>当两个指针首次相遇，让两个指针接着前进，并统计前进的循环次数，直到两个指针再次相遇。此时统计前进的循环次数就是环长。</p><h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3><p>p1与p2速度差为一个节点，当快指针再次追上慢指针时，快指针多走了慢指针一圈，因此：<br><strong>环长 = 快指针走的步数 - 慢指针走的步数 = 速度差 * 前进次数 = 前进次数</strong></p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRingLength</span><span class="params">(Node ringMeetNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ringLength = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ringMeetNode可以在isCycle()中获得</span></span><br><span class="line">    Node p1 = ringMeetNode, p2 = ringMeetNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next.next;</span><br><span class="line">        ringLength++;</span><br><span class="line">        <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ringLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2如何求入环节点"><a class="markdownIt-Anchor" href="#2如何求入环节点"></a> 2.如何求入环节点</h2><h3 id="原理-2"><a class="markdownIt-Anchor" href="#原理-2"></a> 原理</h3><p>假设从链表头节点到入环的距离时D，从入环点到首次相遇点的距离时S1，从首次相遇点回到入环点的距离时S2</p><ol><li>两次指针首次相遇时，各自所走的距离：</li></ol><ul><li>p1：D + S1</li><li>p2：D + S1 + S2 + S1 = D + 2S1 + S2</li></ul><ol start="2"><li>由于p2的速度是p1的两倍，因此：2(D + S1) = D + 2S1 + S2</li><li>得到 <strong>D = S2</strong>，即：从头节点到入环点的距离 = 从首次相遇点回到入环点的距离</li><li>这样一来，只要把其中一个指针放回头节点，另一个指针保持在远处，然后两个指针的 <strong>速度都是一个节点</strong>，那么：它们 <strong>相遇节点就是入环节点</strong></li></ol><h3 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">getRingStart</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="comment">//ringMeetNode可以在isCycle()中获得</span></span><br><span class="line">    Node p1 = head, p2 = ringMeetNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快乐数</title>
      <link href="/2019/10/27/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
      <url>/2019/10/27/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>编写一个算法来判断一个数是不是“快乐数”。</p><a id="more"></a><p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p><ul><li>例如:19</li></ul><blockquote><p>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 0^2 = 1</p></blockquote><h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1><p>使用“快慢指针”思想找出循环：“快指针”每次走两步，“慢指针”每次走一步，当二者相等时，即为一个循环周期。此时，判断是不是因为1引起的循环，是的话就是快乐数，否则不是快乐数。</p><ul><li>注意：此题不建议用集合记录每次的计算结果来判断是否进入循环，因为这个集合可能大到无法存储；另外，也不建议使用递归，同理，如果递归层次较深，会直接导致调用栈崩溃。不要因为这个题目给出的整数是int型而投机取巧。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = n, p2 = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        p1 = bitSquareSum(p1);</span><br><span class="line">        p2 = bitSquareSum(bitSquareSum(p2));</span><br><span class="line">    &#125;<span class="keyword">while</span>(p1 != p2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果循环点是1，则它是快乐数</span></span><br><span class="line">    <span class="comment">//也有可能循环点不是1</span></span><br><span class="line">    <span class="keyword">return</span> p1 == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bitSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span> ,bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">        bit = n%<span class="number">10</span>;</span><br><span class="line">        sum += bit*bit;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模式匹配</title>
      <link href="/2019/10/27/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/10/27/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p><a id="more"></a><p>这个是个模式匹配问题，我刚开始没有意识到到，用暴力法匹配所有的子串，解决了问题，虽然在短字符串的匹配中速度比kmp快，但是长字符串的效率很低。<br>看了解答后，才意识到这是我数据结构中学到的 <strong>KMP算法</strong>。</p><h1 id="核心next数组"><a class="markdownIt-Anchor" href="#核心next数组"></a> 核心NEXT数组</h1><p>next数组是求 <strong>前缀，后缀最长的公共子串长度</strong></p><ul><li>求next函数值的问题可以看成另一个模式匹配问题：<strong>整个模式串既是子串又是模式串</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] get_next(String needle)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[needle.length()];</span><br><span class="line">    <span class="comment">//i是后缀，j是前缀，前缀固定，后缀是相对的</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; needle.length()-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || needle.charAt(i) == needle.charAt(j))&#123;</span><br><span class="line">            i++; j++;</span><br><span class="line">            <span class="comment">//next数组优化，当字符失配时，回到相同字符无意义，应继续递归</span></span><br><span class="line">            <span class="keyword">if</span>(needle.charAt(i) != needle.charAt(j)) next[i] = j;</span><br><span class="line">            <span class="keyword">else</span> next[i] = next[j];</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            j = next[j];<span class="comment">//j回溯</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br></pre></td></tr></table></figure><h1 id="strstr的实现"><a class="markdownIt-Anchor" href="#strstr的实现"></a> strStr的实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] next = get_next(needle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; haystack.length() &amp;&amp; j &lt; needle.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || haystack.charAt(i) == needle.charAt(j)) &#123;i++; j++;&#125;</span><br><span class="line">        <span class="keyword">else</span> j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == needle.length()) <span class="keyword">return</span> i-j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
            <tag> KMP算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除指定元素</title>
      <link href="/2019/10/26/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E7%A7%BB%E9%99%A4%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0/"/>
      <url>/2019/10/26/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E7%A7%BB%E9%99%A4%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><a id="more"></a><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br>这个采用 <strong>双指针</strong> ，与之前的 <strong>删除排序数组中的重复项</strong> 极为相似</p><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != val) &#123;</span><br><span class="line">            nums[ans] = nums[i];</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针优化版"><a class="markdownIt-Anchor" href="#双指针优化版"></a> 双指针优化版</h1><p>现在考虑数组包含很少的要删除的元素的情况。例如，num=[1，2，3，5，4]，Val=4num=[1，2，3，5，4]，Val=4。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 num=[4，1，2，3，5]，Val=4，似乎没有必要将 [1，2，3，5] 这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。<br>所以当我们遇到 <strong>nums[ans] == val</strong> 的时候，我们可以将 <strong>当前元素与最后一个元素进行交换，并释放最后一个元素</strong>（ans–）。这实际上使数组的大小减少了 1。</p><ul><li>请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素，因为并没有i++。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">            nums[i] = nums[ans-<span class="number">1</span>];</span><br><span class="line">            ans--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并有序链表</title>
      <link href="/2019/10/25/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/10/25/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><a id="more"></a><p>题设类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="迭代法"><a class="markdownIt-Anchor" href="#迭代法"></a> 迭代法</h1><p>这个在数据结构中学过，虽然那时候学的是 <strong>C语言</strong>，但是思想相同。<br>由于没有头节点，我们可以假设个头节点，更容易的返回合并后的链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置头节点</span></span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode p = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            p.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将两个链表中剩下的一个链表直接接在末尾</span></span><br><span class="line">    p.next = (l1 == <span class="keyword">null</span>)?l2:l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O(n+m)</li><li>空间复杂度 O(1)</li></ul><h1 id="递归法"><a class="markdownIt-Anchor" href="#递归法"></a> 递归法</h1><p>我们可以递归的定义在两个链表的 merge 操作：<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191025171030.png" class="lazyload"><br>也就是说，头部比较小的一个与剩下元素的 merge 操作结果连接起来，就可以得到最终的链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归先考虑边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)  <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O(n+m)</li><li>空间复杂度 O(n+m)，由于需要n+m个栈帧</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习之旅————多线程</title>
      <link href="/2019/10/23/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/10/23/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>多线程（Thread）是软件开发中的重要内容，实际上，多线程最直观的说法是让应用程序看起来好像同时能做好几件事情</p><a id="more"></a><p>线程是独立的线程。它代表独立的执行空间。在Java中，要建立新的线程就得创建 <strong>Thread</strong>，CPU会在执行空间非常快速地来回切换。因为CPU速度很快，所以你会感觉CPU同时在做好几件事</p><ul><li>要记得，Java也只是个在底层操作系统上执行的进程。一旦轮到Java执行的时候，JVM实际执行的是执行空间最上面的字节码！在某个时间片内，目前执行程序代码会被切换到不同空间上的不同方法。</li><li>线程要记录的一项事情是目前线程执行空间做到哪里：保护现场</li></ul><h1 id="实现多线程的两种方法"><a class="markdownIt-Anchor" href="#实现多线程的两种方法"></a> 实现多线程的两种方法</h1><h2 id="继承-thread-类开发多线程"><a class="markdownIt-Anchor" href="#继承-thread-类开发多线程"></a> 继承 <strong>Thread</strong> 类开发多线程</h2><ol><li>编写一个类，继承 <strong>java.lang.Thread</strong> 类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>在这个类重写 <strong>java.lang.Thread</strong> 类中的函数：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>实例化线程对象，调用其 <strong>start()</strong> 函数启动该线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><h2 id="实现-runnable-接口开发多线程"><a class="markdownIt-Anchor" href="#实现-runnable-接口开发多线程"></a> 实现 <strong>Runnable</strong> 接口开发多线程</h2><ol><li>编写一个类，实现 <strong>java.lang.Runnable</strong> 接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>在这个类中重写 <strong>java.lang.Runnable</strong> 接口中的函数：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>实例化 <strong>java.lang.Thread</strong> 对象，实例化上面编写的 <strong>Runnable</strong> 实现类，将后者传入 <strong>Thread</strong> 对象的构造函数，调用 <strong>Thread</strong> 对象的 <strong>start()</strong> 函数来启动线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Runnable threadJob = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(threadJob);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><h1 id="两种方法比较"><a class="markdownIt-Anchor" href="#两种方法比较"></a> 两种方法比较</h1><ol><li>第一种每个对象都是一个线程，而第二种每个对象不是一个线程，必须将其传入Thread对象才能运行</li><li>第一种每个线程都有自己的成员变量，而第二种共享成员变量</li><li>Java不支持多重继承，只能继承一个类，但是可以实现多个接口，第一种方法虽然较简单，但是扩展性没有第二种强</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除排序数组中的重复项</title>
      <link href="/2019/10/22/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2019/10/22/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度，不需要考虑超出新长度后面的元素。</p><a id="more"></a><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><ul><li>如果题目没要求O(1)，可以直接用LinkedHashSet解决。</li><li>即使不能有空间要求，这道题也比较简单。这是我第一次速度超过100%，哈哈哈哈哈<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191022112916.png" class="lazyload"></li></ul><h1 id="双指针法"><a class="markdownIt-Anchor" href="#双指针法"></a> 双指针法</h1><p>由于我的答案和LeetCode思路一样，所以我叫他双指针法。</p><ul><li>首先判断数组是不是空或者是不是长度为1，是的话直接返回数组长度</li><li>声明两个变量即 <strong>双指针</strong> ，一个快指针i，一个慢指针ans</li><li>快指针声明在for循环里，每次循环都 i++</li><li>慢指针声明在循环外，当 nums[i] != nums[i+1]时(即不重复时)，令nums[ans] = nums[i]，ans++</li><li>最后返回ans<br></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == nums.length-<span class="number">1</span> || nums[i] != nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            nums[ans] = nums[i];</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后贴上leetcode解法"><a class="markdownIt-Anchor" href="#最后贴上leetcode解法"></a> 最后贴上LeetCode解法</h1><p>思路基本一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>罗马数转整数</title>
      <link href="/2019/10/21/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E7%BD%97%E9%A9%AC%E6%95%B0%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
      <url>/2019/10/21/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E7%BD%97%E9%A9%AC%E6%95%B0%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>罗马数字包含以下七种字符: I(1), V(5), X(10), L(50), C(100), D(500), M(1000)，将一串罗马数转成整数。</p><a id="more"></a><p>通常情况下，罗马数字中小的数字在大的数字的右边。<br>但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。<br>一共有六个特例：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。</li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br></li></ul><h1 id="穷举法"><a class="markdownIt-Anchor" href="#穷举法"></a> 穷举法</h1><ul><li>首先将所有的组合添加到哈希表中，一共有13种</li><li>然后遍历字符串，由于组合只有两类，一类是1个字符，另一类是2个字符，其中，2个字符优先级较高</li><li>返回ans</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">"I"</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">"IV"</span>, <span class="number">4</span>);</span><br><span class="line">    map.put(<span class="string">"V"</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">"IX"</span>, <span class="number">9</span>);</span><br><span class="line">    map.put(<span class="string">"X"</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="string">"XL"</span>, <span class="number">40</span>);</span><br><span class="line">    map.put(<span class="string">"L"</span>, <span class="number">50</span>);</span><br><span class="line">    map.put(<span class="string">"XC"</span>, <span class="number">90</span>);</span><br><span class="line">    map.put(<span class="string">"C"</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">"CD"</span>, <span class="number">400</span>);</span><br><span class="line">    map.put(<span class="string">"D"</span>, <span class="number">500</span>);</span><br><span class="line">    map.put(<span class="string">"CM"</span>, <span class="number">900</span>);</span><br><span class="line">    map.put(<span class="string">"M"</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length();)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &lt; s.length() &amp;&amp; map.containsKey(s.substring(i, i+<span class="number">2</span>)))&#123;</span><br><span class="line">            ans += map.get(s.substring(i,i+<span class="number">2</span>));</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans += map.get(s.substring(i,i+<span class="number">1</span>));</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="更优解法"><a class="markdownIt-Anchor" href="#更优解法"></a> 更优解法</h1><p>因为通常情况下，罗马数字中小的数字在大的数字的右边，所以我们可以和下一个字符比大小，如果比它小，那么就是六种特例中的一种</p><ul><li>定义一个获取罗马字符对应数字的静态方法，使用switch来获取字符对应数字</li><li>遍历字符串，比较当前字符和下一字符的数字大小，大于则加，小于则减</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态方法获得罗马数对应的数字大小</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal character"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = getValue(s.charAt(i));</span><br><span class="line">        <span class="comment">//i为最后一个时，直接加</span></span><br><span class="line">        <span class="keyword">if</span>(i == n-<span class="number">1</span> || t &gt;= getValue(s.charAt(i+<span class="number">1</span>)))&#123;</span><br><span class="line">            ans += t;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans -= t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂等法</title>
      <link href="/2019/10/20/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AD%89%E6%B3%95/"/>
      <url>/2019/10/20/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AD%89%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>实现 <strong>pow(x,n)</strong> ，即求x的n次幂。使用暴力法超时，因而使用快速幂等法。</p><a id="more"></a><h1 id="快速幂等法"><a class="markdownIt-Anchor" href="#快速幂等法"></a> 快速幂等法</h1><p>要求一个数的n次幂，可以先求他的n/2次幂，一直分下去，简化问题，减少运算次数。<br>假设 A = x^(n/2)<br>如果 n%2 == 0，则 x^n = A * A;<br>如果 n%2 != 0，则 x^n = A * A * x;</p><ul><li>可以采用循环法或者是递归法解决问题，时间复杂度均为 <strong>O(logN)</strong></li></ul><h1 id="循环法"><a class="markdownIt-Anchor" href="#循环法"></a> 循环法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//n是32位有符号整数，其数值范围是[−2^31, 2^31 − 1]。</span></span><br><span class="line">        <span class="comment">//如果直接将其 -n 转化为正数，有可能导致溢出</span></span><br><span class="line">        <span class="comment">//所以采用long类型储存n</span></span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            N = -N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> current_product = x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = N; i &gt; <span class="number">0</span>; i /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = ans * current_product;</span><br><span class="line">            &#125;</span><br><span class="line">            current_product = current_product * current_product;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="递归法"><a class="markdownIt-Anchor" href="#递归法"></a> 递归法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> N = n;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        N = -N;</span><br><span class="line">        x = <span class="number">1</span>/x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> myFastPow(x, N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myFastPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">double</span> half = myFastPow(x, n/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> ==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> half*half;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> half*half*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="位运算法"><a class="markdownIt-Anchor" href="#位运算法"></a> 位运算法</h1><p>此外还有一种位运算的方法，只说思路：把指数部分转换成2进制，然后展开成2的幂次的和。借用网上的图展示关系<br>以 x 的 10 次方举例。10 的 2 进制是 1010，然后用 2 进制转 10 进制的方法把它展成 2 的幂次的和。<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191020143802.png" class="lazyload"><br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191020143835.png" class="lazyload"></p><ul><li>时间复杂度为 <strong>O(N)</strong></li><li>以上算法空间复杂度均是 <strong>O(1)</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="/2019/10/19/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2019/10/19/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>滑动窗口是数组/字符串问题中常用的抽象概念。</p><a id="more"></a><h1 id="无重复字符的最长子串-给定一个字符串请你找出其中-不含有重复字符-的-最长子串-的长度"><a class="markdownIt-Anchor" href="#无重复字符的最长子串-给定一个字符串请你找出其中-不含有重复字符-的-最长子串-的长度"></a> <strong>无重复字符的最长子串</strong> :给定一个字符串，请你找出其中 <strong>不含有重复字符</strong> 的 <strong>最长子串</strong> 的长度</h1><h2 id="暴力法"><a class="markdownIt-Anchor" href="#暴力法"></a> 暴力法</h2><p>如果使用暴力法，检查所有的子字符串，则时间复杂度为O(n^3)，耗费时间过多。暴力法会反复检查一个字符串是否含有重复的字符，浪费时间。</p><h2 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h2><p>窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j）（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。<br>-例:[i, j）向右滑动1个元素，则它将变为[i+1, j+1)<br>回到我们的问题，我们使用 HashSet 将字符存储在当前窗口 [i, j)（最初 j = i）中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。</p><h2 id="优化版的滑动窗口"><a class="markdownIt-Anchor" href="#优化版的滑动窗口"></a> 优化版的滑动窗口</h2><p>上述的方法最多需要执行 2n 个步骤。事实上，它可以被进一步优化为仅需要 n 个步骤。我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。</p><ul><li>也就是说，如果 j 对应的字符与[i, j-1]重复，则不再让 i++，而是直接跳过[i, j],令 i=j+1;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, n = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符对应的索引为下一次不重复的位置，即下一位置</span></span><br><span class="line">        <span class="comment">//例：j这个地方与前面重复了，则下一次不重复的位置为j+1</span></span><br><span class="line">        <span class="comment">//声明HashMap，形成字符到索引的映射</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="comment">//如果map中有s[j],则更新i</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(j)))&#123;</span><br><span class="line">                i = Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新ans</span></span><br><span class="line">            ans = Math.max(ans, j-i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将s[j]和它到索引的映射(下一个不重复的位置）加入map</span></span><br><span class="line">            <span class="comment">//若是已经重复，则是更新索引，更新为下一次不重复的位置</span></span><br><span class="line">            map.put(s.charAt(j), j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK-13配置环境</title>
      <link href="/2019/10/12/Java%E5%AD%A6%E4%B9%A0/JDK-13%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/10/12/Java%E5%AD%A6%E4%B9%A0/JDK-13%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>目前最新JDK-13的配置环境方法，虽然我也不懂为什么这样弄，但是能用就行。</p><a id="more"></a><h1 id="下载并安装jdk-13"><a class="markdownIt-Anchor" href="#下载并安装jdk-13"></a> 下载并安装JDK-13</h1><p>当然实在 <a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">官网</a> 下载了</p><h1 id="生成jre文件夹"><a class="markdownIt-Anchor" href="#生成jre文件夹"></a> 生成jre文件夹</h1><p>打开cmd，cd到D:\Java\jdk-13(你的安装文件夹) 然后输入并运行命令：bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre</p><h1 id="配置jdk-13环境"><a class="markdownIt-Anchor" href="#配置jdk-13环境"></a> 配置JDK-13环境</h1><h2 id="系统变量添加"><a class="markdownIt-Anchor" href="#系统变量添加"></a> 系统变量添加</h2><ul><li>Java_Home  D:\Java\jdk-13</li><li>ClassPath  .;%Java_Home%\bin;%Java_Home%\lib\dt.jar;%Java_Home%\lib\tools.jar(注意.号)</li></ul><h2 id="系统变量path里追加"><a class="markdownIt-Anchor" href="#系统变量path里追加"></a> 系统变量Path里追加</h2><ul><li>;%Java_Home%\bin;%Java_Home%\jre\bin</li></ul><h1 id="最后检查是否成功"><a class="markdownIt-Anchor" href="#最后检查是否成功"></a> 最后检查是否成功</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">javac</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><p>能看到很多东西应该就是成功了，哈哈哈哈哈</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习之旅————单例模式</title>
      <link href="/2019/10/12/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/10/12/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>郭克华老师在上课讲到的一种设计模式—单例模式。<br>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建 <strong>单一对象</strong> 的最佳方式。</p><a id="more"></a><h1 id="那么问题来了为什么创建单一对象呢"><a class="markdownIt-Anchor" href="#那么问题来了为什么创建单一对象呢"></a> 那么问题来了，为什么创建单一对象呢?</h1><p>有一些实例只需要创建一次就够了，例如：一个班级只有一个班主任，Windows系统只有一个Task Manager(任务管理器)</p><h1 id="单例模式有什么优缺点呢"><a class="markdownIt-Anchor" href="#单例模式有什么优缺点呢"></a> 单例模式有什么优缺点呢？</h1><h2 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h2><ul><li>1.在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。<br></li><li>2.避免对资源的多重占用（比如写文件操作）。</li><li></li></ul><h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2><ul><li>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。<br></li></ul><hr><h1 id="如何实现单例模式"><a class="markdownIt-Anchor" href="#如何实现单例模式"></a> 如何实现单例模式</h1><p>我们将创建一个 SingleObject 类。SingleObject 类有它的 <strong>私有构造函数</strong> 和本身的一个 <strong>静态实例</strong>。<br>SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190925152915.png" class="lazyload"></p><h2 id="step-1"><a class="markdownIt-Anchor" href="#step-1"></a> Step 1</h2><p>创建一个SingleObject类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建SingleObject的一个私有静态对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance = <span class="keyword">new</span> SingObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给外面一个接口，返回唯一可用对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="step-2"><a class="markdownIt-Anchor" href="#step-2"></a> Step 2</h2><p>在外界声明个SingleObject的引用，获取该唯一对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SingleObject instance = SingleObject.getInstance();</span><br></pre></td></tr></table></figure><hr><h1 id="这里的实现方式只是一个大致的抽象方法更详细的如下"><a class="markdownIt-Anchor" href="#这里的实现方式只是一个大致的抽象方法更详细的如下"></a> 这里的实现方式只是一个大致的抽象方法，更详细的如下</h1><ul><li>懒汉式—线程不安全：最基础的实现方式，线程上下文单例，不需要共享给所有线程，也不需要加synchronize之类的锁，以提高性能</li><li>懒汉式—线程安全：加上synchronize之类保证线程安全的基础上的懒汉模式，相对性能很低，大部分时间并不需要同步</li><li>饿汉方式。指全局的单例实例在类装载时构建。</li><li>双检锁式。在懒汉式基础上利用synchronize关键字和volatile关键字确保第一次创建时没有线程间竞争而产生多个实例，仅第一次创建时同步，性能相对较高</li><li>登记式。作为创建类的全局属性存在，创建类被装载时创建</li><li>枚举。java中枚举类本身也是一种单例模式</li></ul><hr><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>单例模式是设计模式中最简单的形式之一。这一模式的目的是使得类的一个对象成为系统中的唯一实例。它有很多种实现方式，但是文中只给出了大致的思路，以后再学习更进一步的实现方式。</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo + Github 图床</title>
      <link href="/2019/10/12/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/PicGo+Github%E5%AE%9E%E7%8E%B0%E5%BA%8A%E5%9B%BE/"/>
      <url>/2019/10/12/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/PicGo+Github%E5%AE%9E%E7%8E%B0%E5%BA%8A%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>昨天用了七牛云实现了床图，但是突然发现免费的只有30天的时间，到了时间就会换域名。之前的图床就失效了，于是转而薅Github的羊毛。</p><a id="more"></a><h1 id="picgo"><a class="markdownIt-Anchor" href="#picgo"></a> PicGo</h1><p>这是一款图片上传的工具，支持众多图床<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190909113126.png" class="lazyload"></p><h1 id="创建github图床"><a class="markdownIt-Anchor" href="#创建github图床"></a> 创建Github图床</h1><p>Github国内访问较慢，但是免费的，真香</p><h2 id="1注册github"><a class="markdownIt-Anchor" href="#1注册github"></a> 1.注册Github</h2><p>这个就不说呢</p><h2 id="2创建一个新公共仓库"><a class="markdownIt-Anchor" href="#2创建一个新公共仓库"></a> 2.创建一个新公共仓库</h2><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190909113644.png" class="lazyload"></p><h2 id="3生成一个token用于操作github仓库"><a class="markdownIt-Anchor" href="#3生成一个token用于操作github仓库"></a> 3.生成一个token用于操作Github仓库</h2><p>在个人 <strong>Settings</strong> / <strong>Developer settings</strong> / <strong>Personal access tokens</strong> 内 <strong>Generate new token</strong><br>只需勾选 <strong>repo</strong><br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190909114127.png" class="lazyload"></p><ul><li>创建成功后，会生成一串token，这串token只显示一次！<br></li></ul><h1 id="配置picgo"><a class="markdownIt-Anchor" href="#配置picgo"></a> 配置PicGo</h1><h2 id="1下载运行picgo"><a class="markdownIt-Anchor" href="#1下载运行picgo"></a> 1.下载运行PicGo</h2><p>在这个链接下下载<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">PicGo</a><br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190909114643.png" class="lazyload"></p><ul><li>mac 系统选择 .dmg 下载，windwos 选择 .exe系统</li></ul><h2 id="2配置图床"><a class="markdownIt-Anchor" href="#2配置图床"></a> 2.配置图床</h2><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190909114721.png" class="lazyload"></p><ul><li>设定仓库名的时候，是按照“账户名/仓库名的格式填写”</li><li>分支名统一填写“master”</li><li>存储的路径可以按照我这样子写，就会在仓库下创建一个“img”文件夹，当然也可以不填</li></ul><h2 id="3快捷键修改"><a class="markdownIt-Anchor" href="#3快捷键修改"></a> 3.快捷键修改</h2><p>根据个人习惯，我这里是这样配置的<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190909115028.png" class="lazyload"></p><h1 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h1><p>将上面的步骤都设置好之后，就可以让自己的Markdown文档更生动形象呢，每次截图之后，都可以按一下 <strong>ctrl+shift+c</strong>，这样就会将剪切板上面的截图转化为在线网络图片链接，十分快捷。<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/biubiubiu.gif" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm(cnpm)安装/卸载模块</title>
      <link href="/2019/10/12/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/cnpm%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/10/12/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/cnpm%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>因为发现七牛云不行，所以卸载了有关的插件。</p><a id="more"></a><h1 id="安装模块"><a class="markdownIt-Anchor" href="#安装模块"></a> 安装模块</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install xxx      #利用 npm 安装xxx模块到当前命令行所在目录</span><br><span class="line">npm install -g xxx   #利用npm安装全局模块xxx</span><br></pre></td></tr></table></figure><h1 id="本地安装时将模块写入-packagejson"><a class="markdownIt-Anchor" href="#本地安装时将模块写入-packagejson"></a> 本地安装时将模块写入 <strong>package.json</strong></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install xxx             #安装但不写入package.json</span><br><span class="line">npm install xxx –save       #安装并写入package.json的”dependencies”中</span><br><span class="line">npm install xxx –save -dev  #安装并写入package.json的”devDependencies”中</span><br></pre></td></tr></table></figure><h1 id="删除模块"><a class="markdownIt-Anchor" href="#删除模块"></a> 删除模块</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall xxx      #删除xxx模块</span><br><span class="line">npm uninstall -g xxx   #删除全局模块xxx</span><br></pre></td></tr></table></figure><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/biubiubiu.gif" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+gayhub搭建个人博客</title>
      <link href="/2019/10/12/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/hexo+gayhub/"/>
      <url>/2019/10/12/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/hexo+gayhub/</url>
      
        <content type="html"><![CDATA[<p>经过<strong>学姐</strong>的安利，我用<strong>hexo+gayhub</strong>搭建起了第一个个人博客</p><a id="more"></a><h1 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h1><hr><ol><li>你要有个gayhub账号，虽然在国内访问较慢，但是免费，真香</li><li>安装node.js，npm(也可以装cnpm，为npm的淘宝镜像，国内访问速度快）</li><li>安装git</li><li>有台Windows电脑，还有个女朋友</li></ol><hr><h1 id="创建github博客"><a class="markdownIt-Anchor" href="#创建github博客"></a> 创建github博客</h1><h2 id="1-新建仓库"><a class="markdownIt-Anchor" href="#1-新建仓库"></a> 1. 新建仓库</h2><p>在github上新建个仓库，命名规则必须为：<strong><a href="http://xn--6qqv7i14ofosyrb.github.io" target="_blank" rel="noopener">你的用户名.github.io</a></strong>(我也不知道为什么要这样子哈)，如果没钱的话这个就是你以后的博客地址了。</p><h2 id="2绑定域名"><a class="markdownIt-Anchor" href="#2绑定域名"></a> 2.绑定域名</h2><p>由于我没有钱，所以绑定域名就不说了，你可以买个域名，然后把域名的地址跳转到<strong><a href="http://xn--6qqv7i14ofosyrb.github.io" target="_blank" rel="noopener">你的用户名.github.io</a></strong>就行了。</p><h2 id="3配置ssh"><a class="markdownIt-Anchor" href="#3配置ssh"></a> 3.配置SSH</h2><p>这个有什么用呢？给你的博客加个密，防止其他人提交代码。<br>打开cmd输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/. ssh #检查本机已存在的ssh密钥</span><br></pre></td></tr></table></figure><p>如果提示：No such file or directory 说明你是第一次使用git。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><p>连续三次回车就行了<br>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到 <strong>.ssh\id_rsa.pub</strong> 文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：<br>将刚复制的内容粘贴到key那里，title随便填，保存.</p><h3 id="测试是否成功"><a class="markdownIt-Anchor" href="#测试是否成功"></a> 测试是否成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com # 注意邮箱地址不用改</span><br></pre></td></tr></table></figure><p>然后yes就行了。<br>此外你还配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;****&quot;// 你的github用户名，非昵称</span><br><span class="line">$ git config --global user.email  &quot;xxx@qq.com&quot;// 填写你的github注册邮箱</span><br></pre></td></tr></table></figure><p>这个具体是什么呢？我也不知道呀</p><h1 id="安装hexo"><a class="markdownIt-Anchor" href="#安装hexo"></a> 安装hexo</h1><h2 id="首先我们安装个cnpm"><a class="markdownIt-Anchor" href="#首先我们安装个cnpm"></a> 首先我们安装个cnpm</h2><p>前面也说过了，加快下载速度。<br>我们要用npm下载cnpm，然后以后都用cnpm代替npm (npm:???!!!)<br>在你的blog文件夹，在空白处点击鼠标右键，选择 <strong>Git Bash Here</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install cnpm -g --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><ul><li>开始安装hexo</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm intall -g hexo-cli </span><br><span class="line">#这里原本是 npm intall -g hexo-cli ，但是下载速度较慢所以切换成cnpm，以后都如此</span><br></pre></td></tr></table></figure><p>验证是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>如果你看不到error，那应该就是成功了，哈</p><ul><li>重要的一步来了，初始化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>如果最后一行出现 <strong>Start blogging with Hexo!</strong><br>恭喜你，可以开始编写博客了</p><h2 id="先测试一下"><a class="markdownIt-Anchor" href="#先测试一下"></a> 先测试一下</h2><p>我们经常用的指令是以下几个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean #用来清理缓存文件</span><br><span class="line">hexo g     #hexo generate的缩写，生成文件</span><br><span class="line">hexo s     #hexo serve的缩写，生成本地预览</span><br><span class="line">hexo d     #hexo deploy的缩写，部署到服务器</span><br></pre></td></tr></table></figure><p>还有一个组合指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并部署</span><br></pre></td></tr></table></figure><ul><li>测试本地运行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>打开浏览器，进入 <strong>localhost:4000</strong>，你会看到hexo自带的一个主题还有 <strong>Hello World</strong></p><h1 id="更换主题"><a class="markdownIt-Anchor" href="#更换主题"></a> 更换主题</h1><p>我最喜欢的就是美化了</p><ul><li>由于网上比较推荐的是 <strong>yilia</strong>，所以我下载了它。<br>首先下载这个主题，在你的文件夹你 <strong>Git Bash Here</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><p>下载的主题都在 <strong>themes</strong> 文件夹<br>修改源文件夹下的 <strong>_config.yml</strong> 中的 <strong>theme: landscape</strong> 改为<strong>theme: yilia</strong> ，然后重新执行 <strong>hexo g</strong> 来重新生成。<br><strong>hexo s</strong> 后进入 <strong>localhost:4000</strong> 就能预览你的主题了。<br>如果出现一些莫名其妙的问题，可以先执行 <strong>hexo clean</strong> 来清理一下内容，然后再来重新生成和发布。</p><ul><li>你可以在 <strong>themes</strong>文件夹下的 <strong>_config.yml</strong> 修改有关主题的内容，这里不多加详述了。</li></ul><h1 id="部署到github"><a class="markdownIt-Anchor" href="#部署到github"></a> 部署到Github</h1><p>如果你一切都配置好了，发布上传很容易，一句 <strong>hexo d</strong> 就搞定，当然关键还是你要把所有东西配置好。</p><ul><li>首先，<strong>ssh key</strong>肯定要配置好。</li><li>其次，配置 <strong>_config.yml</strong> 中有关 <strong>deploy</strong>的部分：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: github</span><br><span class="line">  repository: https://github.com/******.github.io.git #你的仓库地址</span><br><span class="line">  branch: master</span><br><span class="line">#注意空格</span><br></pre></td></tr></table></figure><ul><li>此外还装一个插件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ul><li>最后的最后<br><strong>hexo d</strong>就能把你的博客部署到GitHub上了。<br>以后你可以打开 <strong><a href="http://xn--6qqv7i14ofosyrb.github.io" target="_blank" rel="noopener">你的用户名.github.io</a></strong>，进入你的博客。<br>#可以写博客了</li><li>由于我基本不会命令行，所以我没用命令行。<br>你可以直接新建一个 <strong>.md</strong>的文件，然后用 <strong>Markdown</strong>的编辑器打开就可以开始写你的博客了（我用的编辑器是 <strong>VSCode</strong> + <strong>Markdown Preview Enhanced插件</strong>），这里的 <strong>.md</strong>的文件使用 <strong>Markdown</strong>语法写的，十分简单 ，几分钟速成。<br>写好后，把文件放在你的文件夹下的 <strong>source/_posts</strong>就行了。<br>然后用组合命令行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>就能直接生成本地文件并且部署到服务器上。</p><h1 id="最终效果"><a class="markdownIt-Anchor" href="#最终效果"></a> 最终效果</h1><p>也就是本博客 <strong><a href="http://EasonZzZz.github.io" target="_blank" rel="noopener">EasonZzZz.github.io</a></strong><br><img alt data-src="http://pxij6pdrn.bkt.clouddn.com/static/images/biubiubiu.gif" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
