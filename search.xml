<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>离散数学</title>
      <link href="/2020/01/05/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
      <url>/2020/01/05/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="数理逻辑"><a class="markdownIt-Anchor" href="#数理逻辑"></a> 数理逻辑</h1><ul><li>判断是否是命题</li><li>命题符号化</li><li>对偶式</li><li>求主析取范式</li><li>量词：辖域，消去，前束范式</li><li>US,UG,ES,EG</li><li>推理大题：先用ES，再用US</li></ul><h1 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h1><ul><li><strong>幂集合：所有子集组成的集合</strong></li><li><strong>笛卡尔乘积</strong></li></ul><h1 id="二元关系"><a class="markdownIt-Anchor" href="#二元关系"></a> 二元关系</h1><ul><li>恒等关系</li><li>二元关系的个数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup></msup></mrow><annotation encoding="application/x-tex">2^{n^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9869199999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li>关系的特性：自反，反自反，对称，反对称，传递<ul><li>自反关系个数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n^2 - n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9869199999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></li><li>对称又反对称个数：只有对角线上可能为1，因此2^n</li></ul></li><li><strong>关系的合成只保持自反性</strong></li><li>闭包运算：r，s，t</li><li><strong>偏序性质：自反，反对称，传递</strong><ul><li><em>Hass图，极大极小，最大最小</em></li></ul></li><li><strong>等价关系：自反，对称，传递</strong><ul><li>等价类：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><msub><mo stretchy="false">]</mo><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">[x]_{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，x为表示元素</li><li><strong>商集：等价类作为元素的集合</strong></li></ul></li></ul><h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1><ul><li>特殊函数类<ul><li><strong>单射</strong>：当x，y不等时，f(x)，f(y)也不等；f(x)=f(y)则x=y</li><li><strong>满射</strong>：对所有y，都有一个x，使得f(x)=y</li><li><strong>双射</strong>：单射又满射，分开证明即可</li></ul></li><li>恒等函数：f(x) = x</li><li>x上的<strong>双射函数</strong>称为置换/排列</li></ul><h1 id="无限集合"><a class="markdownIt-Anchor" href="#无限集合"></a> 无限集合</h1><h1 id="代数"><a class="markdownIt-Anchor" href="#代数"></a> 代数</h1><ul><li>代数：非空，运算，封闭</li><li><strong>同态：f(x*y)=f(x)·f(y)</strong><ul><li>单同态，满同态，同构</li></ul></li><li>半群：代数，结合律</li><li>独异点：代数，结合律，幺元</li><li>群：代数，结合律，幺元，逆元<ul><li>有逆元，满足消去律</li><li><strong>幺元是唯一等幂元，没有零元</strong></li></ul></li><li>生成元：所有元素可以写成自己的幂，不唯一</li><li><strong>元素的阶：a^n = e，则n为a的阶，阶至多为|G|</strong><ul><li>任一元素与它的<strong>逆元同阶</strong></li></ul></li><li><strong>子群三个判定定理</strong><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a*b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>∈S且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>∈S</li><li>有限群，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a*b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>属于S</li><li><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder accentunder="true"><mrow><mi>a</mi><mo>∗</mo><msup><mi>b</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>∈</mo><mi>S</mi></mrow><mo stretchy="true">‾</mo></munder></mrow><annotation encoding="application/x-tex">\underline{a*b^{-1}∈S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.053208em;vertical-align:-0.2391000000000001em;"></span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999998em;"><span style="top:-2.8009em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2391000000000001em;"><span></span></span></span></span></span></span></span></span>，划重点</strong></li></ul></li><li><strong>拉格朗日定理</strong><ul><li>陪集中的元素构成一个<strong>等价关系</strong></li><li>陪集是G的一个<strong>划分(等价关系类)</strong></li><li><strong>[G的阶] = [子群H的不同陪集数] x [H的阶]</strong></li></ul></li><li><em><strong>任何质数群只有平凡子群：&lt;e,*&gt;和&lt;G,*&gt;，且质数群一定为循环群</strong></em></li><li>正规子群：左右陪集存在相等<ul><li>Abel和平凡子群都是正规子群</li></ul></li><li>环：&lt;R,+,*&gt;：+为Abel；*为半群；*对+可分配</li><li>域：整环(无0因子，*可交换)，且&lt;F-{0},*&gt;是群</li></ul><h1 id="格"><a class="markdownIt-Anchor" href="#格"></a> 格</h1><ul><li>保交(最大下届)，保联(最小上界)</li><li>分配格：满足分配律<ul><li>与两个五元素格(钻石格，五角格)不同构</li></ul></li><li>补元素：a*b=0且a+b=1，则a，b互为补元</li><li>有补格：每一元素有补(不唯一)</li><li>有补分配格：有补且分配，补元素唯一</li></ul><h1 id="图"><a class="markdownIt-Anchor" href="#图"></a> 图</h1><ul><li>握手定理</li><li><strong>欧拉路径充要条件：起点，终点同奇偶，其他全偶</strong></li><li><strong>欧拉回路充要条件：所有点为偶</strong></li><li>点：支配<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>γ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\gamma_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，独立<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>α</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\alpha_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，覆盖<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>β</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\beta_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>边：匹配(独立)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>α</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\alpha_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，覆盖<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>β</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\beta_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><ul><li>覆盖+独立=n</li></ul></li><li>可达性矩阵</li><li><strong>二部图充要条件：所有回路长度都是偶数</strong></li><li>t条件(完全匹配)</li><li><strong>欧拉定理 → m≤3n-6(连通平面图充要条件)</strong></li><li>Huffman树</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成概论</title>
      <link href="/2020/01/02/%E8%AE%A1%E7%BB%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%AE%BA/"/>
      <url>/2020/01/02/%E8%AE%A1%E7%BB%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统概论"><a class="markdownIt-Anchor" href="#计算机系统概论"></a> 计算机系统概论</h1><ul><li>机器字长<ul><li>CPU一次能处理数据的位数</li><li>与CPU中的<strong>寄存器位数</strong>有关</li></ul></li><li>存储容量：存放二进制信息的总位数<ul><li>主存容量：存储单元个数 X 存储字长</li></ul></li></ul><h1 id="冯诺依曼机的特点"><a class="markdownIt-Anchor" href="#冯诺依曼机的特点"></a> 冯·诺依曼机的特点</h1><ul><li>计算机由运算器、存储器、控制器、输入设备和输出设备五大部件组成</li><li>指令和数据以同等的地位存于存储器，并可按地址寻址</li><li>指令和数据均用二进制表示</li><li>指令由操作码和地址码组成</li><li>指令在存储器内按顺序存放</li><li>机器以运算器为中心</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象</title>
      <link href="/2019/12/27/Java%E5%AD%A6%E4%B9%A0/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/12/27/Java%E5%AD%A6%E4%B9%A0/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><ul><li>面向对象的三大特征：<ul><li><strong>封装(Encapsulation)</strong></li><li><strong>继承(Inheritance)</strong></li><li><strong>多态(Polymorphism)</strong></li></ul></li><li>面向对象(Object Oriented)是一个编程思想：将事件看成事件(过程)的集合还是物体(对象)的集合</li><li>类是对象的抽象</li><li>对象是类的实例</li><li>对象拥有两类内容：<ul><li>成员变量：属性(Property, Member Variable, Field)</li><li>成员函数(方法)：功能(Member Function, Method)</li></ul></li><li>对象的引用性质：<strong>Java中的对象名只是一个引用(指针)，或者是一个遥控器，并不代表其实际占据内存，只有通过&quot;.&quot;号才能访问到其真实内存中的数据</strong></li></ul><h1 id="成员变量和成员函数"><a class="markdownIt-Anchor" href="#成员变量和成员函数"></a> 成员变量和成员函数</h1><h2 id="成员函数"><a class="markdownIt-Anchor" href="#成员函数"></a> 成员函数</h2><ul><li>目的：复用代码</li></ul><h3 id="参数传递方式"><a class="markdownIt-Anchor" href="#参数传递方式"></a> 参数传递方式：</h3><ol><li><strong>简单数据类型</strong>采用<strong>值传递</strong><ul><li>primitive类型</li></ul></li><li><strong>引用数据类型</strong>采用<strong>引用传递</strong><ul><li>对象的引用，数组</li></ul></li></ol><h3 id="函数重载overload"><a class="markdownIt-Anchor" href="#函数重载overload"></a> 函数重载(Overload)</h3><ul><li>允许多个函数名字相同，但是要满足要求<ol><li>参数个数不同</li><li>个数相同，类型不同</li><li>个数相同，类型相同，但是不同类型的参数出现的顺序不同</li></ol><ul><li><em>函数的返回值不能作为重载的条件</em></li><li>函数重载也叫静态多态(Static Polymorphism)</li></ul></li></ul><h3 id="构造函数constructor"><a class="markdownIt-Anchor" href="#构造函数constructor"></a> 构造函数(Constructor)</h3><ul><li>构造函数也是一种函数，为了强制对象初始化，但必须满足：<ol><li>函数名与类相同</li><li>不含返回类型(并不是void)</li></ol></li><li>特点：<ol><li>对象实例化时自动调用一次</li><li>可以被重载</li><li>如果一个类没有定义任何构造函数，系统自动为其分配一个空的，不带参数的默认构造函数，如果定义了构造函数，默认构造函数自动失效(不会自动创建)</li></ol></li></ul><h3 id="析构函数destructor"><a class="markdownIt-Anchor" href="#析构函数destructor"></a> 析构函数(Destructor)</h3><ul><li>对象结束其生命周期时或者该对象没有被引用，系统会执行析构函数</li><li>在java中，对象的内存在哪个时刻回收，取决于垃圾回收器何时运行</li></ul><h1 id="静态变量和静态函数"><a class="markdownIt-Anchor" href="#静态变量和静态函数"></a> 静态变量和静态函数</h1><h2 id="静态变量"><a class="markdownIt-Anchor" href="#静态变量"></a> 静态变量</h2><ul><li>默认情况下，各个成员都有自己独有的成员变量，占据不同内存。</li><li>而<strong>静态变量是该类所有对象公用的变量</strong></li><li>访问方式：“对象名.变量名”，“<strong>类名.变量名</strong>”(推荐)</li></ul><h2 id="静态函数"><a class="markdownIt-Anchor" href="#静态函数"></a> 静态函数</h2><ul><li><strong>静态函数只能访问静态变量，不能访问类中的普通成员变量。</strong></li><li>建议用“<strong>类名.函数名</strong>”访问。</li><li>作用：一般情况下可以用来执行一些不隶属于任何一个特定对象的公共的工作。</li></ul><h1 id="封装encapsulation"><a class="markdownIt-Anchor" href="#封装encapsulation"></a> 封装(Encapsulation)</h1><ul><li>隐藏对象的属性和实现细节，仅对外公开接口</li></ul><h2 id="最大层面的封装包"><a class="markdownIt-Anchor" href="#最大层面的封装包"></a> 最大层面的封装：包</h2><ul><li>用包来管理类</li></ul><ol><li>如何把类放入包中<br>在文件头声明类所在的包：<strong>package 包名</strong>;<ul><li>Java中，包名一般名词，首字母小写；</li><li>如果包中还含有包，用.号隔开</li></ul></li><li>如何使用包中的类<ol><li>同一个包中的类直接使用</li><li>不同包中的类不能直接使用，需以下操作：<ul><li>import 另一个包中的类<ul><li>import 类路径;</li><li>import 包路径.*; 表示导入包中所有类（不含子包中的类）</li></ul></li><li>被使用的类是一个public类<ul><li><strong>public类对包外可见，非public类只能在包内可见</strong>；public-类的类名必须与所在文件名相同</li><li>一个文件中，最多只能有一个public类</li></ul></li></ul></li></ol></li></ol><h2 id="细节层面的封装访问区分符"><a class="markdownIt-Anchor" href="#细节层面的封装访问区分符"></a> 细节层面的封装：访问区分符</h2><ul><li><p>有些成员不适合其他类直接调用，这不安全。用访问区分符来管理成员的访问权限</p></li><li><p>在成员定义前面加上访问区分符：public，protected，default，private</p></li><li><p>访问权限如下：</p><table><thead><tr><th>访问权限</th><th>本类</th><th>同包类</th><th>外包子类</th><th>外包类</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table></li><li><p>以上访问区分符适合成员变量和函数</p></li><li><p>default是一种包访问，外包不能访问</p></li><li><p>一般情况下，成员变量定义为私有(private),成员函数定义为公有(public)，<strong>如果涉及到继承，可以将成员定义为保护型</strong></p></li><li><p>如果需要读取成员变量或者修改成员变量怎么做：</p><ul><li>setXXX函数和getXXX函数</li><li>也叫做setter和getter函数</li></ul></li></ul><h1 id="继承inheritance"><a class="markdownIt-Anchor" href="#继承inheritance"></a> 继承(Inheritance)</h1><h2 id="概念-2"><a class="markdownIt-Anchor" href="#概念-2"></a> 概念</h2><ol><li>原因：通过继承，降低代码量，提高可维护性；定义共同协议</li><li>实现方式：extends关键字</li><li>性质：<ul><li>不允许多重继承，一个类只能extends一次</li><li>所有的成员都可以被继承，但是要考虑访问区分符：<ul><li><strong>父类的private成员不能被继承</strong></li><li><strong>父类的default成员，不能被包外子类继承</strong></li><li>成员变量可以被继承，作为子类的成员变量直接使用（属性）</li><li>成员函数可以被继承，作为子类的成员函数直接使用（功能）</li></ul></li></ul></li><li>本质：实例化子类对象时，系统会首先实例化父类对象<ul><li>如果父类没有默认构造函数，子类必须用<strong>super()显式调用</strong>(必须写在<strong>第一行</strong>)</li><li>调用本类的其他构造函数this()也必须写在第一行，且不能与super()同时使用，因为this()中也会调用super()，使父类对象构造的两次</li></ul></li></ol><h2 id="成员的覆盖override"><a class="markdownIt-Anchor" href="#成员的覆盖override"></a> 成员的覆盖(Override)</h2><ul><li><p>子类中重定义父类的成员，方法(参数一致，返回类型兼容)</p></li><li><p>覆盖是表现多态特性的具体做法</p></li><li><p>子类对象调用成员时，自动调用子类成员，父类成员不被调用。一定要调用父类成员，可以用super关键字。</p></li><li><p><strong>super</strong>和<strong>this</strong>是相对的两个关键词，一个指代父类；一个指代自己</p><table><thead><tr><th>使用</th><th>执行</th></tr></thead><tbody><tr><td>super.</td><td>调用父类的成员</td></tr><tr><td>super(参数列表)</td><td>调用父类构造函数</td></tr><tr><td>this.</td><td>调用本类中成员</td></tr><tr><td>this(参数列表)</td><td>调用本类中另一个构造函数</td></tr></tbody></table></li><li><p><strong>覆盖不允许缩小访问权限</strong></p></li><li><p>Java中有一个类：Object类，是所有成员的父类</p><ul><li>常见方法：equals(Object obj)，toString()</li></ul></li></ul><h1 id="多态polymorphism"><a class="markdownIt-Anchor" href="#多态polymorphism"></a> 多态(Polymorphism)</h1><h2 id="概念-3"><a class="markdownIt-Anchor" href="#概念-3"></a> 概念</h2><ul><li>多种形态：某个东西，在不同情况下呈现出不同形态</li><li>动态多态的理论基础是：父类引用可以指向子类对象。</li><li><strong>当父类引用调用被覆盖的成员时，调用的是子类成员</strong>，从子类向上找</li><li>作用：<ol><li>函数形参为父类类型，实参为子类对象</li><li>函数返回类型是父类类型，函数中实际返回子类对象</li></ol></li></ul><h2 id="父类和子类的类型转换"><a class="markdownIt-Anchor" href="#父类和子类的类型转换"></a> 父类和子类的类型转换</h2><ol><li>子类转化为父类<ul><li>可以直接赋值</li></ul></li><li>父类转化为父类<ul><li>严格来说，无法转换</li><li>特殊情况：该父类原本是子类的对象，使用强制类型转换</li></ul></li></ol><ul><li>“对象名 <strong>instanceof</strong> 类名” 可以判断对象类型</li></ul><h2 id="抽象abstract"><a class="markdownIt-Anchor" href="#抽象abstract"></a> 抽象(abstract)</h2><ul><li>抽象函数：将函数体去掉，定义为抽象函数<ul><li>特点：必须在子类中被重写，否则报错，除非子类也是抽象类</li></ul></li><li><strong>含有抽象函数的类叫抽象类，必须用abstract修饰</strong></li><li>特点：<ol><li>抽象类必须用abstract修饰，抽象类不能被实例化，只能被继承</li><li>抽象类中含有抽象函数（包括继承的，也可以不含有），也可以含有普通函数（便于子类调用）</li><li>抽象函数必须在子类中被重写(<strong>注意权限不能缩小</strong>)，否则报错，除非子类也是抽象类</li></ol></li><li>抽象类中不一定都是抽象函数，但是含抽象函数的类一定是抽象类</li><li>抽象类不能被实例化，但是它有构造函数(因为子类中会使用super()调用父类构造函数)</li></ul><h2 id="接口interface"><a class="markdownIt-Anchor" href="#接口interface"></a> 接口(interface)</h2><ul><li>特点：<ol><li>全部是<strong>public抽象函数</strong>，默认public，abstract(可省略)<ul><li>因此实现接口的类中<strong>重写方法必须是public</strong>，因为权限不能缩小</li></ul></li><li>接口中定义的“变量”只能是<strong>静态public常量</strong>，系统默认使用public，static，final修饰，可以省略</li><li>一个类继承抽象类–&gt;实现（<strong>implements</strong>）接口</li><li><strong>一个类继承一个父类同时实现多个接口</strong></li></ol></li></ul><h2 id="抽象类和接口的区别"><a class="markdownIt-Anchor" href="#抽象类和接口的区别"></a> 抽象类和接口的区别</h2><table><thead><tr><th>参数</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>方法</td><td>可以有正常方法</td><td>只有抽象方法</td></tr><tr><td>实现</td><td>extends</td><td>implements</td></tr><tr><td>构造</td><td>可以有</td><td>不能有</td></tr><tr><td>正常类</td><td>只有不能实例化</td><td>完全不同类型</td></tr><tr><td>修饰符</td><td>public、protected和default</td><td>默认修饰符是public，不能使用其他</td></tr><tr><td>main</td><td>可以有main且可以运行</td><td>不能有</td></tr></tbody></table><ul><li><strong>接口可以extends接口，但不能implements接口，不能extends类</strong></li><li><strong>抽象类可以implements接口，也可以extends实体类(<em>这个类必须有明确的构造函数</em>)，因为抽象类也可以有实体函数</strong></li></ul><h2 id="final关键字"><a class="markdownIt-Anchor" href="#final关键字"></a> final关键字</h2><ol><li>修饰类：不能被继承</li><li>修饰函数：不能被重写</li><li>修饰成员变量：不能被改变(哪怕是同一个值)，用来定义常量</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用API</title>
      <link href="/2019/12/27/Java%E5%AD%A6%E4%B9%A0/Java%E5%B8%B8%E7%94%A8API/"/>
      <url>/2019/12/27/Java%E5%AD%A6%E4%B9%A0/Java%E5%B8%B8%E7%94%A8API/</url>
      
        <content type="html"><![CDATA[<p>API：Application Programming Interface，Java内置的一些类及其功能</p><h1 id="javalang"><a class="markdownIt-Anchor" href="#javalang"></a> java.lang</h1><ul><li>Java语言核心包，包含了Java编程最基本的支持类</li><li>java.lang默认被任何程序import，使用里面的类，不需要导入。其他包必须导入才能使用</li><li>包括：Object，Math，String，StringBuffer，StringBuilder，基本数据类型包装类，System</li></ul><h2 id="math"><a class="markdownIt-Anchor" href="#math"></a> Math</h2><ul><li>负责数值运算</li><li>一般采用<strong><a href="http://Math.Xxx" target="_blank" rel="noopener">Math.Xxx</a></strong>调用</li><li>例：在一个100个元素的1维数组（默认值为0）中，随机将50个值赋为1<ul><li>思路：先用一个ArrayList保存1－100的元素值。每次从中随机取出一个值，并将其赋给数组的一个元素。然后从ArrayList中删除这个值</li></ul></li></ul><h2 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h2><ul><li>负责字符串处理</li><li>不可变，采用池机制，任何一个新字符串都会被新建空间存放，因此循环中用String会大大影响程序性能</li><li>调用replace这种函数时，原字符串不变，会返回一个新的字符串</li></ul><h2 id="stringbuffer和stringbuilder"><a class="markdownIt-Anchor" href="#stringbuffer和stringbuilder"></a> StringBuffer和StringBuilder</h2><ul><li>两者都是可变的字符串</li><li>StringBuffer：可变，效率低，线程安全</li><li>StringBuilder：可变，效率高，线程不安全<ul><li>如果要操作少量的数据用String</li><li>多线程操作字符串缓冲区下操作大量数据StringBuffer</li><li>单线程操作字符串缓冲区下操作大量数据StringBuilder。</li></ul></li></ul><h2 id="基本数据类型包装类"><a class="markdownIt-Anchor" href="#基本数据类型包装类"></a> 基本数据类型包装类</h2><h3 id="包装类"><a class="markdownIt-Anchor" href="#包装类"></a> 包装类</h3><ul><li>Java是面向对象的语言，但是基本类型，如int，short，float，double等并没有遵循面向对象；Java中为它们各自设计一个包装类</li><li>boolean——Boolean，byte——Byte，short——Short，char——Character，<strong>int——Integer</strong>，long——Long，float——Float，double——Double</li><li>作用<ol><li>将各种数据用对象包装，便于管理</li><li>便于和字符串之间相互转换<ul><li>String.valueOf(各种类型)</li><li>Xxx.parseXxx(字符串)</li></ul></li></ol></li></ul><h2 id="system"><a class="markdownIt-Anchor" href="#system"></a> System</h2><ol><li>显示时间：System.currentTimeMillis()<ul><li>看程序运行多长时间</li></ul></li><li>终止程序：System.exit(int status)</li><li>强制垃圾收集：System.gc()</li></ol><h1 id="javautil"><a class="markdownIt-Anchor" href="#javautil"></a> java.util</h1><h2 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h2><h3 id="collection"><a class="markdownIt-Anchor" href="#collection"></a> Collection</h3><ol><li><strong>List接口：有顺序,下标访问，可重复，一维变长</strong><ol><li>ArrayList：底层数组存储，线程不安全</li><li>LinkedList：底层链表存储，线程不安全</li><li>Vector：底层数组存储，线程安全</li></ol><ul><li>功能基本相同：增删改查</li></ul></li><li><strong>Set接口：无下标，不可重复(唯一)，一维变长</strong><ol><li>HashSet：普通的set，保存元素，乱序</li><li>LinkedHashSet：顺序按照元素添加顺序</li><li>TreeSet：自动排序(自然/比较器排序)</li></ol></li></ol><h3 id="collections类"><a class="markdownIt-Anchor" href="#collections类"></a> Collections类</h3><ul><li>Collection<strong>s</strong>是类，不是接口</li><li>为集合提供处理功能的工具类</li><li>sort，frequency，disjoint，max/min，replaceAll……</li></ul><h3 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h3><ul><li><strong>&lt;Key,Value&gt;，key不可重复，每个key对应一个value(类似于映射)</strong></li></ul><ol><li>HashMap：普通map，乱序</li><li>LinkedHashMap：按添加顺序排序</li><li>TreeMap：按Key排序，(自然/比较器排序)</li><li>Hashtable(线程同步)，Properties：具有更多功能</li></ol><h3 id="遍历方法"><a class="markdownIt-Anchor" href="#遍历方法"></a> 遍历方法</h3><ol><li>List：下标访问，可以用普通for或高级for遍历</li><li>Set：无下标<ol><li>利用迭代器进行，迭代遍历</li><li>高级for</li><li>foreach</li></ol></li><li>Map：无下标<ol><li>在for循环中使用entries实现Map的遍历</li><li>在for循环中遍历key或者values，一般适用于只需要map中的key或者value时使用，在性能上比使用entrySet较好</li><li>通过Iterator遍历</li><li>通过键找值遍历，这种方式的效率比较低，因为本身从键取值是耗时的操作</li></ol></li></ol><h2 id="日期操作"><a class="markdownIt-Anchor" href="#日期操作"></a> 日期操作</h2><ol><li>Date</li><li>Calendar</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常处理</title>
      <link href="/2019/12/27/Java%E5%AD%A6%E4%B9%A0/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2019/12/27/Java%E5%AD%A6%E4%B9%A0/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="认识异常"><a class="markdownIt-Anchor" href="#认识异常"></a> 认识异常</h1><ul><li>java.lang.Exception</li><li>程序出现异常，有什么危害？<ol><li>异常退出，错误提示</li><li>程序在出现异常之后，后面的代码将不会执行</li></ol></li></ul><h1 id="解决异常"><a class="markdownIt-Anchor" href="#解决异常"></a> 解决异常</h1><ol><li>预见所有异常可能，进行约束。很难做到</li><li>一网打尽  try-catch-finally<ul><li>用try块来管理可能出现异常的代码</li><li>用catch块处理某种异常</li><li>用finally块包起来不管异常与否都要运行的代码，保证程序安全性</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 不管异常与否都要运行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>try至少接一个catch或finally，而且两个之间不能有代码</li><li>catch能有多个(从小到大排序)，但finally至多一个</li><li>只有try-finally必须throws异常</li><li>try中异常后的代码不执行</li><li>finally最大的特点是：即使在try中跳出了代码块，甚至return跳出了函数，finally内的代码仍然能运行</li></ul><h1 id="抛出异常"><a class="markdownIt-Anchor" href="#抛出异常"></a> 抛出异常</h1><ul><li><strong>throw：在函数中抛出一个异常对象</strong></li><li><strong>throws：标注该函数可能会抛出某种异常</strong></li><li>一般情况下，标注了throws的函数，调用时一定要用try-catch处理异常或者再次抛出(直至到JVM，它也不会处理，出现异常的话只好死给你看)</li><li>RuntimeException在编译时不会报错，但是在运行时会出错，相当于main函数抛出异常</li><li>自定义异常：extends Exception即可</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO操作</title>
      <link href="/2019/12/27/Java%E5%AD%A6%E4%B9%A0/Java%20IO%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/12/27/Java%E5%AD%A6%E4%B9%A0/Java%20IO%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="io操作"><a class="markdownIt-Anchor" href="#io操作"></a> IO操作</h1><ul><li><strong>IO：输入输出，站在内存角度</strong></li><li>输入输出，最典型的是文件输入输出<ul><li>文件输入：将已有文件的内容输入内存-&gt;文件读</li><li>文件输出：将内存数据输出到文件-&gt;文件写</li></ul></li><li>IO操作支持的API一般保存在<strong><a href="http://java.io" target="_blank" rel="noopener">java.io</a></strong>包</li></ul><h1 id="file类"><a class="markdownIt-Anchor" href="#file类"></a> File类</h1><ol><li>最常见的构造函数：<ul><li>public File(String pathname)</li></ul></li></ol><ul><li>Windows系统分隔符&quot;\&quot;，但是要用&quot;\\“表示，因为”\&quot;转义字符</li><li>Unix系统分隔符是&quot;/&quot;，但是Windows系统也能使用，所以一般用&quot;/&quot;</li></ul><ol start="2"><li>常用方法：<ul><li>getAbsolutePath()，exists()，isDirectory()，isFile()，length()，delete()……</li><li>没有复制文件(读取，再新建)，移动文件(读取，删除，再新建)的功能</li><li>文件的length用字节表示，删除为永久删除</li></ul></li></ol><h1 id="读写文件"><a class="markdownIt-Anchor" href="#读写文件"></a> 读写文件</h1><ul><li>流(Stream)：就是指像水流一样长长的一串连续的东西。在很多时候，流(Stream)是字节流(Byte Steram)的简称，也就是长长的一串字节。</li></ul><h2 id="读文件"><a class="markdownIt-Anchor" href="#读文件"></a> 读文件</h2><ol><li><strong>InputStream</strong><ol><li><strong>FileInputStream</strong>：字节流，支持类型多，但是对双字节字符支持不佳(不能识别中文)</li><li><strong>BufferedInputStream</strong>(常用)：带缓冲，速度较快，但只能使用read或readLine</li></ol></li><li><strong>Reader</strong><ol><li><strong>FileReader</strong>：字符流，一般支持字符，对双字节字符支持较好(可以识别中文)</li><li><strong>BufferedReader</strong>(常用)：带缓冲，速度较快</li></ol></li></ol><ul><li>readLine：按行读，在网络编程中应用较多，会阻塞</li><li>flush：将缓冲区中的数据立马存入硬盘</li></ul><h2 id="写文件"><a class="markdownIt-Anchor" href="#写文件"></a> 写文件</h2><ol><li><strong>OutputStream</strong><ol><li><strong>FileOutputStream</strong>：字节流，对中文支持尚可</li><li><strong>BufferedOutputStream</strong>：带缓冲，速度较快</li></ol></li><li><strong>Writer</strong><ol><li><strong>FileWriter</strong>：字符流</li><li><strong>BufferedWriter</strong>(常用)：带缓冲，速度较快</li></ol></li><li><strong>PrintStream</strong></li></ol><h2 id="randomaccessfile"><a class="markdownIt-Anchor" href="#randomaccessfile"></a> RandomAccessFile</h2><ul><li>随机访问，在文件随机位置定义一个起始点，从起始点读写，有着各种类型的读写</li><li>在于可以随意在文件中间定义起始点：seek(long pos) 函数</li><li>public RandomAccessFile(String name，String mode) throws FileNotFountException</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ul><li>一般使用BufferedReader，PrintStream</li><li>流使用完后要关闭，关闭最外层流，内层流自动关闭</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java界面和事件</title>
      <link href="/2019/12/27/Java%E5%AD%A6%E4%B9%A0/Java%E7%95%8C%E9%9D%A2%E5%92%8C%E4%BA%8B%E4%BB%B6/"/>
      <url>/2019/12/27/Java%E5%AD%A6%E4%B9%A0/Java%E7%95%8C%E9%9D%A2%E5%92%8C%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="gui"><a class="markdownIt-Anchor" href="#gui"></a> GUI</h1><p>GUI(Graphics User Interface)：图形用户界面</p><h2 id="swing"><a class="markdownIt-Anchor" href="#swing"></a> Swing</h2><ul><li>用于开发GUI程序，有三大要素：窗口(Window)，控件(Component)，渲染</li></ul><h3 id="窗口"><a class="markdownIt-Anchor" href="#窗口"></a> 窗口</h3><ol><li>javax.swing.JFrame:普通窗口</li><li>javax.swing.JWindow：无标题栏的窗口</li><li>javax.swing.JDialog：窗口间调用时的对话框</li></ol><h3 id="控件"><a class="markdownIt-Anchor" href="#控件"></a> 控件</h3><ul><li><p>常见以下控件：</p><ol><li>按钮(JButton)</li><li>标签(JLabel)</li><li>文本框(JTextField)</li><li>多行文本框(JTextArea)</li><li>密码框(JPasswordField)</li><li>单选按钮(JRadioButton)</li><li>下拉列表框(JComboBox)：addItem</li><li>复选框(JCheckBox)</li><li>菜单：JMenuBar，JMenu，JMenuItem</li></ol></li><li><p>为了更好的组织界面，通常：<strong>先将控件添加到面板(JPanel)上，再添加到窗口上</strong></p></li><li><p>JPanel上的控件，<strong>默认FlowLayout布局</strong>：系统确定的大小，从左到右，从上到下按照顺序布局，不可更改。</p></li><li><p>如果要自由地安排布局，一般将JPanel的布局方式设置为null，通过setSize设置控件大小，setLocation设置控件位置。</p></li></ul><h3 id="渲染"><a class="markdownIt-Anchor" href="#渲染"></a> 渲染</h3><ul><li>颜色(Color)，字体(Font)，图标(Icon)……</li><li>所有控件都可以设置背景颜色和前景颜色(字的颜色)：<ul><li>setBackground(Color c)</li><li>setForeground(Color c)</li><li>颜色用java.awt.Color来表示</li></ul></li><li>所有含文字的控件都可以设置字体；<ul><li>setFont(Font f)</li><li>字体用java.awt.Font来表示</li></ul></li></ul><h3 id="layout"><a class="markdownIt-Anchor" href="#layout"></a> Layout</h3><ol><li>FlowLayout：流式布局，JPanel默认布局<ul><li>从左到右，从上到下</li></ul></li><li>GridLayout：网格布局<ul><li>将界面划分成相等大小的块</li></ul></li><li>BorderLayout：边界布局<ul><li>分成东南西北中，每个方向最多放一个组件</li></ul></li><li>null：空布局</li></ol><h1 id="事件处理"><a class="markdownIt-Anchor" href="#事件处理"></a> 事件处理</h1><h2 id="方式"><a class="markdownIt-Anchor" href="#方式"></a> 方式</h2><ul><li>事件(Event)是指用户为了交互而产生的键盘和鼠标动作<ul><li>上面定义不严谨，程序出现异常，也可以被认为是一个事件</li><li>事件是一个对象</li></ul></li><li>事件的处理者(Listener)必须有监听的能力</li><li>通常三步走：<strong>长耳朵，绑定，监听</strong><ol><li>编写一个类，implements相应的Listener，实现事件的响应（长耳朵）</li><li>将需要监听的控件和这个类的对象绑定（告诉它你要监听事件）</li><li>控件开始监听，一旦有该种事件发生，会实现事件的相应</li></ol></li></ul><h2 id="常见event-listener"><a class="markdownIt-Anchor" href="#常见event-listener"></a> 常见Event-Listener</h2><ul><li>Event和Listener都在java.awt.event包</li></ul><ol><li><em><strong>ActionListener-ActionEvent</strong></em>：鼠标点击控件，文本框中回车</li><li><strong>KeyListener-KeyEvent</strong>：操作键盘发生的事件</li><li><strong>MouseListener-MouseEvent</strong>：通用的操作鼠标发生的事件；画图软件</li><li><em>MouseMotionListener-MouseEvent</em>：鼠标拖动或移动事件</li><li>FocusListener-FocusEvent：控件得到聚焦</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程开发</title>
      <link href="/2019/12/27/Java%E5%AD%A6%E4%B9%A0/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
      <url>/2019/12/27/Java%E5%AD%A6%E4%B9%A0/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="认识多线程"><a class="markdownIt-Anchor" href="#认识多线程"></a> 认识多线程</h1><ul><li>进程(process)：操作系统层面，计算机能够“同时”运行的各个应用程序；管理上，每个进程占用独自的内存资源分时间片</li><li>线程(Thread)：应用程序层面，程序能够“同时”运行的各个任务；管理上，各个线程共用进程的内存资源<ul><li>例：一个程序，可以下载文件，同时播放音乐。两个任务分别运行。</li></ul></li></ul><h1 id="开发线程"><a class="markdownIt-Anchor" href="#开发线程"></a> 开发线程</h1><ul><li>关键是<strong>将需要用线程管理的代码（不依赖主程序，可以同时运行的代码），放在线程中</strong>。</li></ul><h2 id="方法1继承-thread-类开发多线程"><a class="markdownIt-Anchor" href="#方法1继承-thread-类开发多线程"></a> 方法1：继承 <em><strong>Thread</strong></em> 类开发多线程</h2><ol><li><p>继承 <strong>java.lang.Thread</strong> 类开发多线程</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure></li><li><p>在这个类重写 <strong>Thread</strong> 类中的<strong>run函数</strong>：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>实例化线程对象，调用其 <strong>start()</strong> 函数启动该线程</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li></ol><h2 id="方法2实现-runnable-接口开发多线程"><a class="markdownIt-Anchor" href="#方法2实现-runnable-接口开发多线程"></a> 方法2：实现 <em><strong>Runnable</strong></em> 接口开发多线程</h2><ol><li><p>编写一个类，实现 <strong>java.lang.Runnable</strong> 接口</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure></li><li><p>在这个类中重写 <strong>java.lang.Runnable</strong> 接口中的函数：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>实例化 <strong>java.lang.Thread</strong> 对象，实例化上面编写的 <strong>Runnable</strong> 实现类，将后者传入 <strong>Thread</strong> 对象的构造函数，调用 <strong>Thread</strong> 对象的 <strong>start()</strong> 函数来启动线程</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Runnable threadJob = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(threadJob);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// new Thread(new MyRunnable()).start();</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="两种方法比较"><a class="markdownIt-Anchor" href="#两种方法比较"></a> 两种方法比较</h2><ol><li>第一种每个对象都是一个线程，而第二种每个对象不是一个线程，必须将其传入Thread对象才能运行</li><li>第一种每个线程都有自己的成员变量，而第二种共享成员变量</li><li>Java不支持多重继承，只能继承一个类，但是可以实现多个接口，第一种方法虽然较简单，但是扩展性没有第二种强</li></ol><h1 id="线程控制"><a class="markdownIt-Anchor" href="#线程控制"></a> 线程控制</h1><ul><li><strong>启动(start)、暂停(suspend)、继续(resume)、停止(stop)，销毁(destroy)</strong></li><li>Thread的suspend(暂停)，resume(继续)虽然可以使用，但是由于有死锁危险，被废弃。因为线程暂停时，并不释放线程所拥有的资源。<ul><li>解决方法：建议让<strong>线程暂停，等价于让线程结束运行</strong>。因为结束运行会释放资源；线程结束运行的标志：run函数运行完毕。线程继续相当于新开一个线程，在原来线程基础上运行。所以线程暂停时，要注意保护现场。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java网络编程</title>
      <link href="/2019/12/27/Java%E5%AD%A6%E4%B9%A0/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/12/27/Java%E5%AD%A6%E4%B9%A0/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="ip和port"><a class="markdownIt-Anchor" href="#ip和port"></a> IP和Port</h1><ol><li>如何定位到某台电脑？<ul><li><strong>IP地址</strong></li><li>IPV4：32位，分割成4个&quot;8位二进制数&quot;，2019.11.26耗尽</li><li>IPV6：128位</li></ul></li><li>确定IP后，如何确定特定的网络应用程序？<ul><li><strong>端口(Port)</strong></li><li>0~65535，其中0~1024被占用(HTTP:80)</li></ul></li></ol><ul><li>IP确定电脑地址，Port确定应用程序，实现计算机之间的相互通讯</li></ul><h1 id="tcp和udp"><a class="markdownIt-Anchor" href="#tcp和udp"></a> TCP和UDP</h1><ul><li>TCP(Transmission Control Protocol)<ul><li>基于连接，只有C/S两端连接上才能通信</li><li>打电话</li></ul></li><li>UDP(User Datagram Protocol)<ul><li>基于报文，只传送信息，并不保证信息传送一定成功，性能好</li><li>写信</li></ul></li></ul><h1 id="cs模式"><a class="markdownIt-Anchor" href="#cs模式"></a> C/S模式</h1><ul><li>Client/Server模式</li><li>客户端的通信通过服务器的转发</li><li>过程：<ol><li>服务器启动（确定端口）</li><li>客户端连到服务器（根据服务器IP和端口）</li><li>客户端发信息给服务器</li><li>服务器发信息给另一个客户端</li></ol></li></ul><h1 id="javanet包"><a class="markdownIt-Anchor" href="#javanet包"></a> java.net包</h1><ul><li>ServerSocket：开启服务器，指定端口，接受客户端连接。<ul><li>accept()：阻塞函数(死等函数)</li></ul></li><li>Socket：套接字。负责实际的通信连接，以及发送接收信息。<ul><li>getOutputStream，getIntputStream，老师推荐使用：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream())</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> IntputStreamReader(socket.getIntputStream()))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基本语法</title>
      <link href="/2019/12/27/Java%E5%AD%A6%E4%B9%A0/Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/12/27/Java%E5%AD%A6%E4%B9%A0/Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li>立即数系统默认为int/double<ul><li>如要赋值一个long，必须要在最后加上L符号表示这是个long类型</li></ul></li><li>数组初始化<blockquote><p>int[] a = new int[]{1,2,3};</p></blockquote></li><li>类型转换<ul><li>低精度可以直接赋给高精度<blockquote><p>byte &lt; short &lt; char &lt; int &lt; long &lt; float &lt; double<br>java中的char是十六位，双字节，因此比short大</p></blockquote></li><li>高精度不能直接赋值给低精度：需要强制类型转换</li><li>不同类型之间的运算结果为<strong>精度最高的类型</strong></li></ul></li><li>基本数据类型和字符串转换<ul><li>String.valueOf(各种基本类型)，返回String对象</li><li>XXX.parseXXX(字符串)，返回的是primitive类型，而不是对象</li></ul></li><li>文档注释：&quot;/**&quot; 开头，&quot;*/&quot;结束</li><li><strong>字符串相加(实为连接)：&quot;+&quot;是Java中唯一重载过的一个字符</strong></li><li>&amp;&amp; 和 || 都是短路运算符，即如果第一个可以判断出表达式的TF，就不再运算后面的内容</li><li>运算符的优先级：<ul><li>点号，括号，分号，逗号</li><li>算术运算符</li><li>移位运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>赋值运算符</li></ul></li><li>Java流程<ul><li>选择：if-else switch-case(会让你判断结果)</li><li>循环：for while do-while break continue</li><li>注意：判断中只能为boolean类型，不能为数值</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储器</title>
      <link href="/2019/12/26/%E8%AE%A1%E7%BB%84/%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2019/12/26/%E8%AE%A1%E7%BB%84/%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><h2 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h2><ol><li>按存储介质分类<ol><li>半导体存储器：TTL，MOS(易失)</li><li>磁表面存储器</li><li>磁芯存储器</li><li>光盘存储器</li></ol></li><li>按照存取方式<ol><li>RAM(Random Access Memory)</li><li>ROM(Read Only Memory)</li><li>串行访问存储器</li></ol></li><li>按在计算机中的作用分类<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191216180240.png" class="lazyload"></li></ol><h2 id="层次结构"><a class="markdownIt-Anchor" href="#层次结构"></a> 层次结构</h2><ol><li>存储器三个主要特性的关系<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191216181028.png" class="lazyload"></li><li>缓存-主存层次和主存-辅存层次<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191216181224.png" class="lazyload"></li></ol><h1 id="主存储器"><a class="markdownIt-Anchor" href="#主存储器"></a> 主存储器</h1><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191216181356.png" class="lazyload"></p><ul><li>编址单位：字节</li><li>技术指标：<ol><li>容量：主存<strong>存放二进制代码的总位数</strong></li><li>速度：<ul><li>存取时间：存储器的<strong>访问时间</strong></li><li>存取周期：连续两次独立的存储器操作所需的<strong>最小间隔时间</strong>，比存取时间长，差个复原时间</li></ul></li><li>带宽：<strong>位/秒(bit/s)</strong></li></ol></li></ul><h2 id="半导体存储芯片"><a class="markdownIt-Anchor" href="#半导体存储芯片"></a> 半导体存储芯片</h2><ul><li>容量：<strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi mathvariant="normal">地</mi><mi mathvariant="normal">址</mi><mi mathvariant="normal">线</mi></mrow></msup><mo>×</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">线</mi></mrow><annotation encoding="application/x-tex">2^{地址线} \times 数据线</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.363em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">地</span><span class="mord cjk_fallback mtight">址</span><span class="mord cjk_fallback mtight">线</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">线</span></span></span></span></strong></li><li>译码驱动方式:<ul><li>线选法</li><li>重合法</li></ul></li></ul><h2 id="ram"><a class="markdownIt-Anchor" href="#ram"></a> RAM</h2><ol><li>静态RAM(SRAM)</li><li>动态RAM(DRAM)<ul><li><strong>2ms(刷新周期)</strong> 内再生(刷新)，<strong>一行行进行</strong></li><li>刷新方式：<ol><li>集中刷新(有死区)</li><li>分散刷新(无死区)</li><li>异步刷新(两者结合)：刷新安排在指令译码阶段，不会出现死区</li></ol></li></ul></li></ol><h2 id="rom"><a class="markdownIt-Anchor" href="#rom"></a> ROM</h2><ol><li>掩膜ROM：不能修改</li><li>PROM(一次性编程)</li><li>EPROM(多次性编程)</li><li>EEPROM(电可擦除)</li><li>Flash Memory(闪速型存储器)</li></ol><h1 id="存储器与cpu的连接"><a class="markdownIt-Anchor" href="#存储器与cpu的连接"></a> 存储器与CPU的连接</h1><ol><li>存储器容量的扩展<ol><li>位扩展(增加存储字长)</li><li>字扩展(增加存储字的数量)</li><li>字、位扩展</li></ol></li><li>存储器与CPU的连接<ol><li>地址线的连接<ul><li>低位接存储芯片，高位作片选信号</li></ul></li><li>数据线的连接</li><li>读/写命令线的连接</li><li>片选线的连接</li><li>合理选择存储芯片</li><li>其他：时序，负载</li></ol></li></ol><ul><li>做题步骤：<ol><li>写出对应二进制地址码</li><li>确定芯片的数量及类型<ul><li>优先位扩展：字扩展要设计片选型号，而位扩展只需将数据线引出即可</li><li>RAM，ROM尽量选择外特性一致，简化连接，避免二级译码</li></ul></li><li>分配地址线</li><li>确定片选信号</li></ol></li></ul><h1 id="存储器的校验"><a class="markdownIt-Anchor" href="#存储器的校验"></a> 存储器的校验</h1><ol><li>编码的最小距离：任意两组合法代码之间的二进制位数的<strong>最少差异数</strong><ul><li>L - 1 = D + C</li><li>L：最小距离；D：检错位数；C：纠错位数</li><li><strong>汉明码是具有一位纠错能力的编码</strong></li></ul></li><li>汉明码的组成三要素<ol><li>添加k位校验位：<strong>2^k ≥ n+k+1</strong> [传输n位，分成k组]</li><li>检测位的位置：<strong>2^i</strong> (i=0,1,……) [这一位不与其他组共用]<ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub><mi mathvariant="normal">检</mi><mi mathvariant="normal">测</mi><mi mathvariant="normal">的</mi><msub><mi>g</mi><mn>1</mn></msub><mi mathvariant="normal">：</mi><mn>1</mn><mi mathvariant="normal">，</mi><mn>3</mn><mi mathvariant="normal">，</mi><mn>5</mn><mi mathvariant="normal">，</mi><mn>7</mn><mi mathvariant="normal">，</mi><mn>9</mn><mo>…</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">C_{1}检测的g_{1}：1，3，5，7，9……</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">检</span><span class="mord cjk_fallback">测</span><span class="mord cjk_fallback">的</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">：</span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord">3</span><span class="mord cjk_fallback">，</span><span class="mord">5</span><span class="mord cjk_fallback">，</span><span class="mord">7</span><span class="mord cjk_fallback">，</span><span class="mord">9</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub><mi mathvariant="normal">检</mi><mi mathvariant="normal">测</mi><mi mathvariant="normal">的</mi><msub><mi>g</mi><mn>2</mn></msub><mi mathvariant="normal">：</mi><mn>2</mn><mi mathvariant="normal">，</mi><mn>3</mn><mi mathvariant="normal">，</mi><mn>6</mn><mi mathvariant="normal">，</mi><mn>7</mn><mi mathvariant="normal">，</mi><mn>10</mn><mo>…</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">C_{2}检测的g_{2}：2，3，6，7，10……</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">检</span><span class="mord cjk_fallback">测</span><span class="mord cjk_fallback">的</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">：</span><span class="mord">2</span><span class="mord cjk_fallback">，</span><span class="mord">3</span><span class="mord cjk_fallback">，</span><span class="mord">6</span><span class="mord cjk_fallback">，</span><span class="mord">7</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>4</mn></msub><mi mathvariant="normal">检</mi><mi mathvariant="normal">测</mi><mi mathvariant="normal">的</mi><msub><mi>g</mi><mn>3</mn></msub><mi mathvariant="normal">：</mi><mn>4</mn><mi mathvariant="normal">，</mi><mn>5</mn><mi mathvariant="normal">，</mi><mn>6</mn><mi mathvariant="normal">，</mi><mn>7</mn><mi mathvariant="normal">，</mi><mn>12</mn><mo>…</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">C_{4}检测的g_{3}：4，5，6，7，12……</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">检</span><span class="mord cjk_fallback">测</span><span class="mord cjk_fallback">的</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">：</span><span class="mord">4</span><span class="mord cjk_fallback">，</span><span class="mord">5</span><span class="mord cjk_fallback">，</span><span class="mord">6</span><span class="mord cjk_fallback">，</span><span class="mord">7</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>8</mn></msub><mi mathvariant="normal">检</mi><mi mathvariant="normal">测</mi><mi mathvariant="normal">的</mi><msub><mi>g</mi><mn>4</mn></msub><mi mathvariant="normal">：</mi><mn>8</mn><mi mathvariant="normal">，</mi><mn>9</mn><mi mathvariant="normal">，</mi><mn>10</mn><mi mathvariant="normal">，</mi><mn>11</mn><mi mathvariant="normal">，</mi><mn>12</mn><mo>…</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">C_{8}检测的g_{4}：8，9，10，11，12……</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">检</span><span class="mord cjk_fallback">测</span><span class="mord cjk_fallback">的</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">：</span><span class="mord">8</span><span class="mord cjk_fallback">，</span><span class="mord">9</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></li></ul></li><li>检测位的取值：所在小组中承担的<strong>奇偶校验任务</strong>有关</li></ol></li><li>汉明码纠错过程<br>形成新的检测位P[i]，和该组中1个数有关(奇偶校验决定，一般为偶校验)</li></ol><h1 id="提高访问速度的措施"><a class="markdownIt-Anchor" href="#提高访问速度的措施"></a> 提高访问速度的措施</h1><ul><li>采用高速器件</li><li>采用层次结构 Cache-主存</li><li>调整主存结构<ol><li>单体多字：增加存储器的带宽</li><li>多体并行<ol><li>高位交叉：<strong>顺序编址</strong>，各个体<strong>并行工作</strong>(适合存储器扩展，但不适合增加带宽)</li><li>低位交叉：各个体<strong>轮流编制</strong>，<strong>在不改变存取周期的前提下，增加存储器的带宽</strong>(流水线方式)</li></ol></li><li>高性能存储芯片<ol><li>SDRAM(同步RAM)</li><li>RDRAM</li><li>带Cache的DRAM<ul><li>集成了一个Cache，有利于猝发式读取</li></ul></li></ol></li></ol></li></ul><h1 id="高速缓冲存储器"><a class="markdownIt-Anchor" href="#高速缓冲存储器"></a> 高速缓冲存储器</h1><h2 id="概述-2"><a class="markdownIt-Anchor" href="#概述-2"></a> 概述</h2><p>避免CPU&quot;空等&quot;，<strong>程序访问局部性原理</strong></p><h3 id="cache工作原理"><a class="markdownIt-Anchor" href="#cache工作原理"></a> Cache工作原理</h3><ol><li>主存和缓存的编址<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191217163036.png" class="lazyload"><ul><li>主存和缓存<strong>按块存储</strong>，<strong>块大小相等</strong>，B为块长</li></ul></li><li>命中和未命中<br>缓存有C块，主存有M块，M &gt;&gt; C<ul><li>命中：主存块调入缓存，建立了对应关系</li><li>用<strong>标记</strong>记录与某缓存块建立了对应关系的<strong>主存块号</strong></li></ul></li><li>Cache命中率：CPU欲访问的信息再Cache中的比率<ul><li>与Cache的<strong>容量</strong>和<strong>块长</strong>有关</li><li>块长取一个存取周期内从主存调出的信息长度</li></ul></li><li>Cache-主存系统的效率<ul><li>效率e与命中率有关<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191217164120.png" class="lazyload"><br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191217164226.png" class="lazyload"></li></ul></li></ol><h3 id="cache的结构"><a class="markdownIt-Anchor" href="#cache的结构"></a> Cache的结构</h3><ol><li>Cache存储体</li><li>地址映射变换机构</li><li>替换机构</li></ol><h3 id="cache的读写操作"><a class="markdownIt-Anchor" href="#cache的读写操作"></a> Cache的读写操作</h3><ol><li>读：<img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191217165151.png" class="lazyload"></li><li>写：<strong>Cache和主存的一致性</strong><ol><li>写直达法：既写入Cache又写入主存。<strong>写操作时间就是访问主存的时间</strong></li><li>写回法：只把数据写入Cache而不写入主存，但Cache数据被替换出去时才写回主存。<strong>写操作时间就是访问Cache的时间</strong></li></ol></li></ol><h3 id="cache的改进"><a class="markdownIt-Anchor" href="#cache的改进"></a> Cache的改进</h3><ol><li>增加Cache的级数</li><li>统一缓存和分立缓存</li></ol><h2 id="cache-主存的地址映射"><a class="markdownIt-Anchor" href="#cache-主存的地址映射"></a> Cache-主存的地址映射</h2><h3 id="直接映射"><a class="markdownIt-Anchor" href="#直接映射"></a> 直接映射</h3><ul><li><strong>每个缓存块 i ———— 若干个主存块</strong></li><li><strong>每个主存块 j ———— 一个缓存块</strong></li></ul><blockquote><p>把主存划分成若干个<strong>与Cache相等的区</strong>，然后每个区里的字块一一映射到Cache字块<br>主存地址 = 主存字块标记(区号)[t] + Cache字块地址[c] + 字块内地址[b]<br>t + c = m</p></blockquote><h3 id="全相联映射"><a class="markdownIt-Anchor" href="#全相联映射"></a> 全相联映射</h3><ul><li><strong>主存中的任一块</strong>可以映射到<strong>缓存中的任一块</strong></li></ul><blockquote><p>主存地址 = 主存字块标记(m=t+c) + 字块内地址(b)</p></blockquote><h3 id="组相联映射"><a class="markdownIt-Anchor" href="#组相联映射"></a> 组相联映射</h3><ul><li>直接映射和全相联映射的结合</li><li>Cache被分成<strong>Q组</strong>，每组<strong>R块</strong></li><li><strong>某一主存块j</strong> 按 <strong>modQ</strong> 映射到缓存的<strong>第i组</strong>中的<strong>任一块</strong></li></ul><blockquote><p>直接映射：给定的一个块只能放在一个组<br>全相联映射：给定的一个块可以放到这个组中任一块<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191217172401.png" class="lazyload"></p></blockquote><h2 id="替换算法"><a class="markdownIt-Anchor" href="#替换算法"></a> 替换算法</h2><ol><li>先进先出(FIFO)</li><li>近期最少使用(LRU)：较好的利用局部性原理</li></ol><h1 id="辅助存储器"><a class="markdownIt-Anchor" href="#辅助存储器"></a> 辅助存储器</h1><h2 id="概述-3"><a class="markdownIt-Anchor" href="#概述-3"></a> 概述</h2><ul><li>不与CPU直接交换信息</li><li>磁表面技术指标：<ol><li>记录密度：道密度Dt，位密度Db</li><li>存储容量：C = n X k X s<ul><li>C为存储总量，n为盘面数，k为磁道数，s为磁道的二进制代码数</li></ul></li><li>平均寻址时间：寻道时间+等待时间<ul><li>平均等待时间：盘片旋转一周所需的时间的一半(即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mrow><mi mathvariant="normal">转</mi><mi mathvariant="normal">速</mi><mo>×</mo><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{转速 \times2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">转</span><span class="mord cjk_fallback mtight">速</span><span class="mbin mtight">×</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>)</li></ul></li><li>数据传输率：Dr = Db X V</li><li>误码率</li></ol></li></ul><h2 id="磁记录原理和记录方式"><a class="markdownIt-Anchor" href="#磁记录原理和记录方式"></a> 磁记录原理和记录方式</h2><h3 id="磁记录原理"><a class="markdownIt-Anchor" href="#磁记录原理"></a> 磁记录原理</h3><ul><li>磁层表面被磁化的<strong>极性方式不同</strong>，以区别0和1</li></ul><h3 id="记录方式"><a class="markdownIt-Anchor" href="#记录方式"></a> 记录方式</h3><ol><li><strong>归零制(RZ)</strong>：RZ记录&quot;1&quot;时，通以正向脉冲；记录&quot;0&quot;时，通以反向脉冲</li><li><strong>不归零(NRZ)</strong>：NRZ记录时，始终有驱动电流，不是正向就是反向。变化才翻转(见变就翻)</li><li><strong>&quot;见1就翻&quot;的不归零制(NEZ1)</strong>：始终有电流，只有见&quot;1&quot;才翻转</li><li><strong>调相制(PM)</strong>：又称相位编码(PE)，记录方式：记录&quot;1&quot;时，写电流由负变正；记录&quot;0&quot;时，写电流由正变负。电流变化出现在中间时刻。连续记录相同信息时，在每两个相同信息的交界处，电流反向；如果相邻信息不同，则电流不变向。</li><li><strong>调频制(FM)</strong>：又称倍频制，以驱动电流变化的频率记录区别0，1。记录&quot;0&quot;时，电流不变；记录&quot;1&quot;时，电流中间时刻反向。交界处均反向一次。所以&quot;0&quot;变化一次，&quot;1&quot;变化两次</li><li><strong>改进型调频制(MFM)</strong>：基本相同FM，但是MFM只有当连续记录两个或两个以上的&quot;0&quot;时，才在每位的起始位改变一次电流，不在每个起始点改变电流。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算方法</title>
      <link href="/2019/12/24/%E8%AE%A1%E7%BB%84/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
      <url>/2019/12/24/%E8%AE%A1%E7%BB%84/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="无符号数和有符号数"><a class="markdownIt-Anchor" href="#无符号数和有符号数"></a> 无符号数和有符号数</h1><h2 id="无符号数"><a class="markdownIt-Anchor" href="#无符号数"></a> 无符号数</h2><ul><li>寄存器的位数：反映无符号数的范围</li><li>0 ~ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="有符号数"><a class="markdownIt-Anchor" href="#有符号数"></a> 有符号数</h2><h3 id="机器数和真值"><a class="markdownIt-Anchor" href="#机器数和真值"></a> 机器数和真值</h3><ul><li>符号&quot;数字化&quot;的数，称为机器数</li><li>带&quot;+&quot;,&quot;-&quot;符号的数，称为真值</li></ul><h3 id="原码表示法"><a class="markdownIt-Anchor" href="#原码表示法"></a> 原码表示法</h3><ul><li>符号位0表示正数，符号位1表示负数</li><li>数值位即真值的绝对值<ul><li>整数的符号与数值之间用**逗号&quot;,&quot;**隔开</li><li>小数的符号位与数值之间用**小数点&quot;.&quot;**隔开</li></ul></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>+</mo><mn>0</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">原</mi></msub><mo stretchy="false">(</mo><mn>0.0</mn><mo stretchy="false">)</mo><mi mathvariant="normal">≠</mi><mo stretchy="false">[</mo><mo>−</mo><mn>0</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">原</mi></msub><mo stretchy="false">(</mo><mn>1.0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[+0]_{原}(0.0) \neq [-0]_{原}(1.0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">+</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，原码的0有两种形式</li></ul><h3 id="补码表示法"><a class="markdownIt-Anchor" href="#补码表示法"></a> 补码表示法</h3><ul><li>补的概念：一个负数加上 “模” 即得该负数的补数</li><li>求补码：<ul><li>正数：不变</li><li>负数：<strong>原码(除符号位)求反 + 1</strong> (<strong>反码+1</strong>)</li></ul></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1.0000</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>=</mo><mn>1.0000</mn></mrow><annotation encoding="application/x-tex">[-1.0000]_{补} = 1.0000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，因为补码0只有一种，所以可以多表示一位数字</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>+</mo><mn>0</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo stretchy="false">(</mo><mn>0.0</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mo>−</mo><mn>0</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo stretchy="false">(</mo><mn>0.0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[+0]_{补}(0.0) = [-0]_{补}(0.0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">+</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，补码的0只有一种</li></ul><h3 id="反码表示法"><a class="markdownIt-Anchor" href="#反码表示法"></a> 反码表示法</h3><ul><li>补码和原码之间互相转换的中间过渡</li><li>求反码：<ul><li>正数：不变</li><li>负数：<strong>原码(除符号位)求反</strong></li></ul></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>+</mo><mn>0</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">反</mi></msub><mo stretchy="false">(</mo><mn>0.0</mn><mo stretchy="false">)</mo><mi mathvariant="normal">≠</mi><mo stretchy="false">[</mo><mo>−</mo><mn>0</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">反</mi></msub><mo stretchy="false">(</mo><mn>1.0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[+0]_{反}(0.0) \neq [-0]_{反}(1.0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">+</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">反</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">反</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，反码的0有两种形式</li></ul><h3 id="三种机器数小结"><a class="markdownIt-Anchor" href="#三种机器数小结"></a> 三种机器数小结</h3><ul><li><strong>最高位均为符号位</strong>。符号位和数值部分用逗号&quot;,“或小数点”.&quot;(<strong>书写时，实际不存在</strong>)</li><li>正值<strong>三码合一</strong>，即符号位&quot;0&quot;，数值部分为真值</li><li>负值三种方式均不同，但符号位均&quot;1&quot;<ul><li>补码是原码的&quot;求反加1&quot;</li><li>反码是原码的&quot;每位求反&quot;</li></ul></li><li>不论正负，<strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi>y</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub></mrow><annotation encoding="application/x-tex">[-y]_{补}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>y</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub></mrow><annotation encoding="application/x-tex">[y]_{补}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>连同符号位在内，每位求反，末位加1</strong></li></ul><h3 id="移码表示法"><a class="markdownIt-Anchor" href="#移码表示法"></a> 移码表示法</h3><ul><li>移码：在真值上加上一个常数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，与 <strong>补码仅差一个符号位</strong> ，将补码的符号位取反即得到移码</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>+</mo><mn>0</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">移</mi></msub><mo stretchy="false">(</mo><mn>1.0</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mo>−</mo><mn>0</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">移</mi></msub><mo stretchy="false">(</mo><mn>1.0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[+0]_{移}(1.0) = [-0]_{移}(1.0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">+</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">移</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">移</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，移码的0只有一种</li></ul><h1 id="定点表示和浮点表示"><a class="markdownIt-Anchor" href="#定点表示和浮点表示"></a> 定点表示和浮点表示</h1><h2 id="定点表示"><a class="markdownIt-Anchor" href="#定点表示"></a> 定点表示</h2><ul><li>小数点固定在某一位置的数为定点数</li><li>数值部分决定了定点机中数的表示范围</li></ul><h2 id="浮点表示"><a class="markdownIt-Anchor" href="#浮点表示"></a> 浮点表示</h2><ul><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mi>S</mi><mo>×</mo><msup><mi>r</mi><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">N = S \times r ^ j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span></p><ul><li><strong>S 尾数：小数，可正可负</strong></li><li><strong>j 阶码：整数，可正可负</strong></li><li><strong>r 基数：固定，与计算机有关，取2，4，8，16 ……</strong></li></ul></li><li><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191223202817.png" class="lazyload"></p></li><li><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191223205035.png" class="lazyload"></p><ul><li>上溢中断，下溢为机器0</li></ul></li><li><p>浮点数的规格化形式(原码)</p><ul><li>r = 2 ：尾数最高位为 1</li><li>r = 4 ：尾数最高2位不全为0</li><li>r = 8 ：尾数最高3位不全为0</li><li><strong>基数不同，浮点数的规格化形式不同</strong></li></ul></li><li><p>浮点数的规格化</p><ul><li>r = 2<ul><li>左规：尾数左移 1 位，阶码减 1</li><li>右规：尾数右移 1 位，阶码加 1</li></ul></li><li><strong>基数 r 越大，可表示的浮点数的范围越大</strong></li><li><strong>基数 r 越大，浮点数的精度降低</strong></li><li>规格化后范围变小</li></ul></li><li><p>机器零：</p><ul><li>当浮点数 <strong>尾数为 0</strong> 时，不论其阶码为何值按机器零处理</li><li>当浮点数 <strong>阶码等于或小于它所表示的最小数</strong> 时，不论尾数为何值，按机器零处理</li></ul></li><li><p>IEEE 754标准：尾数为规格化表示，非 “0” 的有效位最高位为 “1”（隐含）</p></li></ul><h1 id="定点运算"><a class="markdownIt-Anchor" href="#定点运算"></a> 定点运算</h1><h2 id="移位运算"><a class="markdownIt-Anchor" href="#移位运算"></a> 移位运算</h2><ol><li>移位的意义：和加减配合，实现乘除<ul><li>数值相对于小数点移动，而不是小数点移动</li></ul></li><li>算术移位规则<ul><li>正数：补0</li><li>负数：<ul><li>原码：补0</li><li>补码：左移补0，右移补1</li><li>反码：补1</li></ul></li></ul></li><li>算术移位和逻辑移位<ul><li>算术移位：无符号数</li><li>逻辑移位：有符号数</li></ul></li></ol><h2 id="加减法"><a class="markdownIt-Anchor" href="#加减法"></a> 加减法</h2><ol><li>加法：A+B<ul><li>整数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>A</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>+</mo><mo stretchy="false">[</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>=</mo><mo stretchy="false">[</mo><mi>A</mi><mo>+</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[A]_{补} + [B]_{补} = [A+B]_{补}(mod 2^{n+1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>小数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>A</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>+</mo><mo stretchy="false">[</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>=</mo><mo stretchy="false">[</mo><mi>A</mi><mo>+</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[A]_{补} + [B]_{补} = [A+B]_{补}(mod 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></li></ul></li><li>减法：A-B<ul><li>转化为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub></mrow><annotation encoding="application/x-tex">[-B]_{补}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，就变成了加法</li></ul></li></ol><ul><li><strong>连同符号位一起相加，符号位产生的进位自然丢掉</strong></li></ul><ol start="3"><li>溢出判断<ol><li>一位符号位判溢出<ul><li>两个数符号相同，结果变号即溢出</li></ul></li><li>两位符号位判溢出<ul><li>双符号位相同，未溢出；不同则溢出</li><li><strong>最高符号位代表其真正的符号</strong></li></ul></li></ol></li></ol><h2 id="乘法运算"><a class="markdownIt-Anchor" href="#乘法运算"></a> 乘法运算</h2><ol><li>分析笔算乘法<ul><li>符号位单独处理</li><li>乘数的某一个决定是否加被乘数</li><li>乘积位数扩大一倍</li></ul></li><li>笔算乘法改进<ul><li><strong>乘法</strong>运算可用<strong>加和移位</strong>实现</li><li>由乘数的末位决定被乘数是否与原部分积相加，然后：<strong>➡1位形成新的部分积</strong>，同时：<strong>乘数➡1位</strong>(末位移丢)，空出的高位存放部分积的地位</li><li><strong>被乘数只与部分积的高位相加</strong></li><li>3个寄存器，其中2个具有移位功能；1个全加器</li></ul></li></ol><h3 id="原码乘法"><a class="markdownIt-Anchor" href="#原码乘法"></a> 原码乘法</h3><h4 id="原码一位乘"><a class="markdownIt-Anchor" href="#原码一位乘"></a> 原码一位乘</h4><ul><li>乘积的符号位单独处理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>⊕</mo><msub><mi>y</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_{0} \oplus y_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>数值部分为<strong>绝对值</strong>相乘 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mo>∗</mo></msup><mo>×</mo><msup><mi>y</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">x^* \times y^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.772026em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8831359999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></li><li>用 <strong>逻辑移位</strong> 的次数 <strong>(乘数位数)</strong> 判断乘法是否结束</li></ul><h4 id="原码两位乘"><a class="markdownIt-Anchor" href="#原码两位乘"></a> 原码两位乘</h4><ul><li><p>原码乘：<strong>符号位</strong>和<strong>数值位</strong>部分<strong>分开运算</strong></p></li><li><p>两位乘：每次用 <strong>乘数的 2 位判断</strong> 原部分积，<strong>是否加</strong>和<strong>如何加</strong>被乘数</p><table><thead><tr><th>乘数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>y</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">y_{n-1}y_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th><th>新的部分积</th></tr></thead><tbody><tr><td>00</td><td>加&quot;0&quot;，➡2位</td></tr><tr><td>01</td><td>加1倍的被乘数，➡2位</td></tr><tr><td>10</td><td>加2倍的被乘数，➡2位</td></tr><tr><td>11</td><td>加3倍的被乘数，➡2位</td></tr></tbody></table><ul><li>如何加3倍的被乘数：先减一倍，再加四倍</li></ul></li><li><p><strong>绝对值的补码运算</strong>，采用补码右移：因为要用到减法，所以采用补码运算</p></li><li><p>用 <strong>算术移位</strong> 的次数判断乘法是否结束</p></li></ul><h4 id="比较"><a class="markdownIt-Anchor" href="#比较"></a> 比较</h4><table><thead><tr><th>异同处</th><th>原码一位乘</th><th>原码两位乘</th></tr></thead><tbody><tr><td>符号位</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>⊕</mo><msub><mi>y</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_{0} \oplus y_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>⊕</mo><msub><mi>y</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_{0} \oplus y_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td></tr><tr><td>操作数</td><td>绝对值</td><td><strong>绝对值的补码</strong></td></tr><tr><td>移位</td><td>逻辑右移</td><td>算术右移</td></tr><tr><td>移位次数</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>(n为偶数)</td></tr><tr><td>最多加法次数</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{n}{2}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>(n为偶数)</td></tr></tbody></table><ul><li>n为奇数：最高位补0，就变成了偶数个</li></ul><h3 id="补码乘法"><a class="markdownIt-Anchor" href="#补码乘法"></a> 补码乘法</h3><ol><li>补码一位乘</li><li>Booth算法(被乘数、乘数符号任意)</li></ol><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><ol><li>整数乘法与小数乘法完全相同</li><li>原码乘：符号位<strong>单独处理</strong></li><li>补码乘：符号位<strong>自然形成</strong></li><li>原码乘去掉符号位运算，即为无符号数乘法</li></ol><h1 id="浮点四则运算"><a class="markdownIt-Anchor" href="#浮点四则运算"></a> 浮点四则运算</h1><h2 id="浮点加减运算"><a class="markdownIt-Anchor" href="#浮点加减运算"></a> 浮点加减运算</h2><ol><li>对阶<ol><li>求阶差</li><li>对阶原则：<strong>小阶向大阶看齐</strong></li></ol></li><li>尾数求和</li><li>规格化<ol><li>定义：r = 2：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>≤</mo><mrow><mo fence="true">∣</mo><mi>S</mi><mo fence="true">∣</mo></mrow><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{1}{2} \leq \left| S \right| \leq1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li>判断：<ul><li>原码：<strong>不论正数、负数，第一数位为1</strong></li><li>补码：<strong>符号位和第 一数位不同</strong></li><li>特例：<ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>=</mo><mn>1.10..0</mn></mrow><annotation encoding="application/x-tex">[-\frac{1}{2}]_{补} = 1.10..0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">0</span></span></span></span> 不是规格化数</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>=</mo><mn>1.00..0</mn></mrow><annotation encoding="application/x-tex">[-1]_{补} = 1.00..0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">0</span></span></span></span> 是规格化数</li></ul></li></ul></li><li>左规：<strong>尾数左移一位，阶码减 1，直到数符和第一数位不同为止</strong></li><li>右规：<strong>尾数溢出时，即尾数为：01.xxx或10.xxx时，尾数右移一位，阶码加 1</strong></li></ol></li><li>舍入：在<strong>对阶</strong>和<strong>右规</strong>过程中，可能出现<strong>尾数末位丢失</strong>引起误差，需考虑舍入<ol><li>0舍1入法</li><li>恒置1法</li></ol></li></ol><h2 id="浮点乘除运算"><a class="markdownIt-Anchor" href="#浮点乘除运算"></a> 浮点乘除运算</h2><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>S</mi><mi>x</mi></msub><mo>×</mo><msup><mn>2</mn><msub><mi>j</mi><mi>x</mi></msub></msup></mrow><annotation encoding="application/x-tex">x = S_{x} \times 2^{j_{x}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05724em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>S</mi><mi>y</mi></msub><mo>×</mo><msup><mn>2</mn><msub><mi>j</mi><mi>y</mi></msub></msup></mrow><annotation encoding="application/x-tex">y = S_{y} \times 2^{j_{y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8246640000000001em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8246640000000001em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:-0.05724em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li></ul><ol><li>乘法：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>×</mo><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>S</mi><mi>x</mi></msub><mo>×</mo><msub><mi>S</mi><mi>y</mi></msub><mo stretchy="false">)</mo><mo>×</mo><msup><mn>2</mn><mrow><msub><mi>j</mi><mi>x</mi></msub><mo>+</mo><msub><mi>j</mi><mi>y</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">x \times y = (S_{x} \times S_{y}) \times 2^{j_{x}+j_{y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8246640000000001em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8246640000000001em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05724em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:-0.05724em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li>除法：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>x</mi><mi>y</mi></mfrac><mo>=</mo><mfrac><msub><mi>S</mi><mi>x</mi></msub><msub><mi>S</mi><mi>y</mi></msub></mfrac><mo>×</mo><msup><mn>2</mn><mrow><msub><mi>j</mi><mi>x</mi></msub><mo>−</mo><msub><mi>j</mi><mi>y</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">\frac{x}{y} = \frac{S_{x}}{S_{y}} \times 2^{j_{x}-j_{y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1764999999999999em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.4307509999999999em;vertical-align:-0.5423199999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8884309999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5423199999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8246640000000001em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8246640000000001em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05724em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:-0.05724em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li>步骤：<ol><li>阶码采用 <strong>补码定点加(乘法)减(除法)</strong> 运算</li><li>尾数乘除同定点运算</li><li>规格化</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO系统</title>
      <link href="/2019/12/23/%E8%AE%A1%E7%BB%84/IO%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/12/23/%E8%AE%A1%E7%BB%84/IO%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><h2 id="io设备与主机信息传送的控制方式"><a class="markdownIt-Anchor" href="#io设备与主机信息传送的控制方式"></a> I/O设备与主机信息传送的控制方式</h2><ol><li>程序查询</li><li>程序中断</li><li>DMA</li></ol><h1 id="io设备"><a class="markdownIt-Anchor" href="#io设备"></a> I/O设备</h1><ol><li>输入设备：键盘，鼠标，触摸屏……</li><li>输出设备：显示器，打印机……</li><li>其他：A/D，D/A……</li><li>多媒体：VR……</li></ol><h1 id="io接口"><a class="markdownIt-Anchor" href="#io接口"></a> I/O接口</h1><h2 id="概述-2"><a class="markdownIt-Anchor" href="#概述-2"></a> 概述</h2><ul><li>为什么要设置接口：<ol><li>实现设备的选择</li><li>实现数据缓冲达到速度匹配</li><li>实现数据串——并格式转换</li><li>实现电平转换</li><li>传送控制命令</li><li>反映设备的状态（“忙”、“就绪”、“中断请求”）</li></ol></li></ul><h2 id="功能和组成"><a class="markdownIt-Anchor" href="#功能和组成"></a> 功能和组成</h2><ul><li>总线连接方式的 I/O 接口电路<ol><li>设备选择线</li><li>数据线</li><li>命令线</li><li>状态线</li></ol></li></ul><table><thead><tr><th>功能</th><th>组成</th></tr></thead><tbody><tr><td>选址</td><td>设备选择电路</td></tr><tr><td>传送命令</td><td>命令寄存器、命令译码器</td></tr><tr><td>传送数据</td><td>数据缓冲寄存器(DBR)</td></tr><tr><td>反映设备状态</td><td>设备状态标记</td></tr></tbody></table><ul><li>状态标记：完成触发器D，工作触发器B，中断请求触发器INTR，屏蔽触发器MASK</li></ul><h2 id="接口类型"><a class="markdownIt-Anchor" href="#接口类型"></a> 接口类型</h2><ol><li>按数据 <strong>传送方式</strong> 分类</li><li>按功能 <strong>选择的灵活性</strong> 分类</li><li>按 <strong>通用性</strong> 分类</li><li>按数据传送的 <strong>控制方式</strong> 分类</li></ol><h1 id="程序查询方式"><a class="markdownIt-Anchor" href="#程序查询方式"></a> 程序查询方式</h1><h1 id="程序中断方式"><a class="markdownIt-Anchor" href="#程序中断方式"></a> 程序中断方式</h1><h1 id="dma方式"><a class="markdownIt-Anchor" href="#dma方式"></a> DMA方式</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总线</title>
      <link href="/2019/12/16/%E8%AE%A1%E7%BB%84/%E6%80%BB%E7%BA%BF/"/>
      <url>/2019/12/16/%E8%AE%A1%E7%BB%84/%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="系统总线"><a class="markdownIt-Anchor" href="#系统总线"></a> 系统总线</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><ul><li>总线是连接各个部件的信息传输线，是<strong>各个部件共享的传输介质</strong></li><li>总线(Bus)是指计算机组件间<strong>规范化的交换数据（data）的方式</strong>，即以一种通用的方式为各组件提供数据传送和控制逻辑。</li></ul><h2 id="总线分类"><a class="markdownIt-Anchor" href="#总线分类"></a> 总线分类</h2><ol><li>片内总线：<strong>芯片内部</strong>的总线</li><li>系统总线：<strong>计算机各部件之间</strong>的信息传输线<ol><li>数据总线：<strong>双向</strong>，与机器字长、存储字长有关</li><li>地址总线：<strong>单向</strong>，与存储地址、I/O地址有关</li><li>控制总线：<strong>有出 有入</strong></li></ol></li><li>通信总线：<strong>计算机系统之间</strong>或<strong>与其他系统</strong>之间的通信<ul><li>串行，并行</li></ul></li></ol><h2 id="总线特性及性能指标"><a class="markdownIt-Anchor" href="#总线特性及性能指标"></a> 总线特性及性能指标</h2><h3 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h3><p>机械，电气，功能，时间</p><h3 id="性能指标"><a class="markdownIt-Anchor" href="#性能指标"></a> 性能指标</h3><ol><li><strong>总线宽度：数据线的根数</strong></li><li><strong>标准传输率：即总线带宽，每秒传输最大字节数(MBps/Mbps)</strong></li><li><strong>时钟</strong>，复用，信号线数，总线控制方式，其他指标(负载能力)</li></ol><h2 id="总线结构"><a class="markdownIt-Anchor" href="#总线结构"></a> 总线结构</h2><h3 id="单总线"><a class="markdownIt-Anchor" href="#单总线"></a> 单总线</h3><p>只有一条系统总线</p><h3 id="多总线"><a class="markdownIt-Anchor" href="#多总线"></a> 多总线</h3><ol><li>双总线</li><li>三总线(两种结构)</li><li>四总线</li></ol><h2 id="总线控制"><a class="markdownIt-Anchor" href="#总线控制"></a> 总线控制</h2><ul><li>控制方式：<ol><li><strong>链式查询方式</strong></li><li><strong>计数器定时查询方式</strong></li><li><strong>独立请求方式</strong></li></ol></li><li>总线传输周期：<ul><li>申请分配阶段：<strong>主模块申请</strong>，总线仲裁决定</li><li>寻址阶段：主模块向从模块<strong>给出地址和命令</strong></li><li>传输阶段：主模块和从模块<strong>交换数据</strong></li><li>结束阶段：主模块<strong>撤销有关信息</strong></li></ul></li><li>总线通信四种方式<ul><li>同步通信：由<strong>统一时标</strong>控制数据传送</li><li>异步通信：采用<strong>应答方式</strong>(互锁)，没有公共时钟标准</li><li>半同步通信：<strong>同步，异步结合</strong></li><li>分离式通信：充分挖掘系统总线每个瞬间的潜力(效率最高，最复杂)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编伪操作</title>
      <link href="/2019/12/14/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E4%BC%AA%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/12/14/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E4%BC%AA%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="处理器选择伪操作"><a class="markdownIt-Anchor" href="#处理器选择伪操作"></a> 处理器选择伪操作</h1><p>这类伪操作一般放在程序的最前面，如不给出,则汇编程序默认值为  .8086</p><h1 id="段定义伪操作"><a class="markdownIt-Anchor" href="#段定义伪操作"></a> 段定义伪操作</h1><h2 id="完整的段定义伪操作"><a class="markdownIt-Anchor" href="#完整的段定义伪操作"></a> 完整的段定义伪操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">段名  SEGMENT  [定位类型]  [组合类型]  [使用类型]  [‘类别’]</span><br><span class="line">    ……</span><br><span class="line">    ……            ;语句序列</span><br><span class="line">段名  ENDS</span><br></pre></td></tr></table></figure><ol><li>段名是为该段起的名字，用来指出汇编程序为该段分配的存储区起始位置</li><li>定位类型：<strong>PARA(默认)</strong>，WORD，BYTE，PAGE。<ul><li>段地址起始地址的限制，PARA限制16的整数倍</li></ul></li><li>组合类型：<strong>PRIVATE(默认)</strong>，PUBLIC，COMMON，STACK，MEMORY(同PUBLIC)，AT 表达式</li><li>使用类型：USE16，USE32.<ul><li>使用xx位寻址方式</li></ul></li><li>类别：在引号中给出连接时组成的段组的类型名。在连接后形成的装入模块中，可使相同类别的段位置靠在一起。</li></ol><h2 id="假定伪指令assume"><a class="markdownIt-Anchor" href="#假定伪指令assume"></a> 假定伪指令ASSUME</h2><ul><li>格式：ASSUME  段寄存器：段名 [，段寄存器：段名]</li><li>功能：<strong>建立段寄存器与段之间的对应关系</strong>。该伪指令一般出现在代码段中。<ul><li>只是建立对应关系，但没有赋值，还<strong>需要自己初始化段寄存器的值</strong></li></ul></li><li>其中段寄存器名必须是CS,DS,ES和SS中的一个。段名必须是由SEGMENT定义的段中的段名。</li></ul><h2 id="段组定义伪操作"><a class="markdownIt-Anchor" href="#段组定义伪操作"></a> 段组定义伪操作</h2><ul><li>格式：段组名  GROUP  数据段名1[，数据段名2……]</li><li>功能：汇编程序把各数据段组成一个段组，以便程序在访问各数据段时使用一个数据段寄存器DS。</li></ul><h1 id="数据定义及存储器分配伪操作"><a class="markdownIt-Anchor" href="#数据定义及存储器分配伪操作"></a> 数据定义及存储器分配伪操作</h1><h2 id="格式"><a class="markdownIt-Anchor" href="#格式"></a> 格式</h2><p>[变量名]   助记符   操作数 [ , 操作数 , … ]  [ ; 注释]</p><ul><li>变量名必须是一个合法的标识符，可写可不写</li><li>助记符：<strong>DB（字节）、DW（字）、DD（双字）、DF（6字节）、DQ（四字）、DT（10字节）</strong></li><li>操作数是定义内存单元时的初值表达式，一个定义语句可以有多个初值表达式，各表达式之间必须用逗号 <strong>‘,’</strong> 分开；如果某个存储单元没有初值表达式，则必须用一个问号 <strong>‘?’</strong> 来表示；<ul><li>注：‘?’表示保留存储空间但不存入数据</li></ul></li><li>注释可以不写</li></ul><h2 id="重复说明符dup"><a class="markdownIt-Anchor" href="#重复说明符dup"></a> 重复说明符DUP</h2><ul><li>一般形式：<strong>repeat_conut DUP(表达式，表达式……)</strong><ul><li>repeat_conut是重复次数</li><li>(表达式，表达式……)是被重复的部分</li><li>表达式可以是<strong>存储单元的初值</strong>，也可以是<strong>另一个DUP式子(可以嵌套)</strong></li><li>多个表达式要用逗号 <strong>‘,’</strong> 分开</li></ul></li></ul><h2 id="强制属性操作符ptr"><a class="markdownIt-Anchor" href="#强制属性操作符ptr"></a> 强制属性操作符PTR</h2><ul><li>类似于C语言的强制类型转换，为临时属性</li><li>一般格式：<strong>数据类型　PTR　地址表达式</strong><ul><li>例如：MOV byte ptr[BX]，1H</li></ul></li></ul><h2 id="label伪操作"><a class="markdownIt-Anchor" href="#label伪操作"></a> LABEL伪操作</h2><ul><li>同一个变量可以具有不同的类型属性，除了可以用PTR来定义外，还可以用LABEL伪操作来定义</li><li>一般格式：<strong>符号名  LABEL　变量类型</strong></li><li>LABEL为当前地址的另一别称，不占内存空间</li></ul><h1 id="表达式赋值伪操作"><a class="markdownIt-Anchor" href="#表达式赋值伪操作"></a> 表达式赋值伪操作</h1><h2 id="等价语句"><a class="markdownIt-Anchor" href="#等价语句"></a> 等价语句</h2><p><strong>符号名　EQU　表达式</strong></p><ul><li>作用：左边的符号名代表右边的表达式</li><li>注意：等价语句不会给符号名分配空间，不能重名，也不能被重新定义</li></ul><h2 id="等号"><a class="markdownIt-Anchor" href="#等号"></a> 等号&quot;=&quot;</h2><p><strong>符号名＝数值表达式</strong></p><ul><li>汇编语言提供了 <strong>等号&quot;=&quot;</strong> 来定义符号常数的方法，即可用符号名代表一个常数。</li><li>数值表达式在汇编时<strong>应该可以计算出数值</strong>，它<strong>不能含有向前引用的符号名称</strong>。</li><li>用等号语句定义的符号<strong>可以被重复定义</strong>。</li></ul><h2 id="equ和的区别"><a class="markdownIt-Anchor" href="#equ和的区别"></a> EQU和&quot;=&quot;的区别</h2><ul><li>由EQU伪指令定义后的符号名是<strong>不能重复再定义的</strong></li><li>而“=”伪指令中定义的符号名<strong>可重复定义</strong></li></ul><h1 id="地址计数器与对准伪操作"><a class="markdownIt-Anchor" href="#地址计数器与对准伪操作"></a> 地址计数器与对准伪操作</h1><h2 id="地址计数器"><a class="markdownIt-Anchor" href="#地址计数器"></a> 地址计数器 $</h2><ul><li>作用：保存当前正在汇编的指令的地址</li><li>$ 用在伪操作的参数字段：表示地址计数器的当前值</li></ul><h2 id="org伪操作"><a class="markdownIt-Anchor" href="#org伪操作"></a> ORG伪操作</h2><ul><li>作用：告诉汇编程序，本伪指令下面的内存变量从该“数值表达式”所指定的地址开始分配。</li></ul><h1 id="基数控制伪操作"><a class="markdownIt-Anchor" href="#基数控制伪操作"></a> 基数控制伪操作</h1><p>RADIX  表达式 ; 规定无标记数的基数</p><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><h2 id="offset运算符"><a class="markdownIt-Anchor" href="#offset运算符"></a> OFFSET运算符</h2><ul><li>格式：OFFSET  变量或标号</li><li>功能：分离出其后变量或标号的<strong>偏移地址</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符重载</title>
      <link href="/2019/12/13/C++%E5%AD%A6%E4%B9%A0/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2019/12/13/C++%E5%AD%A6%E4%B9%A0/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p><strong>函数类型 operator 运算符名称(形参表)</strong><br>{ <strong>对运算符的重载处理</strong> }</p><ul><li>函数名是由 <strong>operator</strong> 和 <strong>运算符</strong> 组成的</li></ul><hr><ul><li>运算符重载的规则<ol><li>不允许用户自定义新的运算符</li><li>不允许重载的5个运算符：<table><thead><tr><th>符号</th><th>类型</th></tr></thead><tbody><tr><td>.</td><td>成员访问运算符</td></tr><tr><td>*</td><td>成员指针访问运算符</td></tr><tr><td>::</td><td>域运算符</td></tr><tr><td>sizeof</td><td>长度运算符</td></tr><tr><td>?:</td><td>条件运算符</td></tr></tbody></table></li><li>不能改变 <strong>操作数个数</strong></li><li>不能改变 <strong>优先级</strong> 和 <strong>结合性</strong></li><li>不能有默认参数</li><li>参数 <strong>至少有一个</strong> 是类对象（或者对象的引用）</li><li>= 和 &amp; 不必重载</li></ol></li></ul><hr><ul><li>运算符重载的两个方式：<ol><li>作为成员函数<ul><li>可以少写一个函数参数</li><li>一般为单目操作符</li><li><strong>=，[]，()，-&gt;只能作为成员函数重载</strong></li></ul></li><li>友元函数<ul><li>一般为 <strong>双目操作符</strong> 的重载（为了普适交换律），以及 流插入 <strong>“&lt;&lt;”</strong> 和 流提取 <strong>“&gt;&gt;”</strong> 的重载</li><li>双目运算符的参数列表必须有 <strong>两个参数</strong></li></ul></li><li>不能是普通函数</li></ol></li></ul><hr><ul><li>单目运算符：++，–的重载<ul><li>前增：Object operator ++ ();</li><li>后增：Object operator ++ ( <strong>int</strong> );</li><li>为了让编译器区别前置和后置，在后置的声明中加入一个 <strong>虚参数</strong> ，以示区别</li><li>而且后增返回的应该为变化前的对象，此时应该调用复制构造函数：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="comment">//进行++</span></span><br><span class="line"><span class="keyword">return</span> temp;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><ul><li>流插入 <strong>“&lt;&lt;”</strong> 和 流提取 <strong>“&gt;&gt;”</strong> 的重载<ul><li><p>必须作为 <strong>友元函数</strong> ！</p></li><li><p>传入两个参数：一个流参数，一个对象，均为 <strong>引用</strong></p><ul><li>如果要对 <strong>临时对象</strong> (如返回对象)，进行 “&lt;&lt;”，此时要用const修饰引用的对象(ostream &amp;os,<strong>const</strong> Object &amp;obj)，因为临时对象为 <strong>右值且默认const属性</strong>, C++ 规定右值不能绑定到非 const 限定的左值引用。</li></ul></li><li><p>返回的类型要为 <strong>流</strong>，以便于连续向输出/输出流 <strong>插入信息</strong></p></li><li><p>&quot;&lt;&lt;&quot;的重载格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream &amp;os,Object &amp;obj)&#123;</span><br><span class="line">   os&lt;&lt;obj.members;</span><br><span class="line">   <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>&quot;&gt;&gt;&quot;的重载格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream &amp;is,Object &amp;obj)&#123;</span><br><span class="line">is&gt;&gt;obj.members;</span><br><span class="line"><span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><ul><li>类型转换函数<blockquote><p>operator 类型名()<br>{实现转换的语句}<br>//operator double(); 将对象转换为double类型。至于怎么转换，自己定义</p></blockquote><ul><li><strong>不能指定类型，没有参数</strong></li><li>必须为成员函数，因为转换的主体是本类的对象</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8086寻址方式</title>
      <link href="/2019/12/13/%E6%B1%87%E7%BC%96/8086%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/12/13/%E6%B1%87%E7%BC%96/8086%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="有效地址ea"><a class="markdownIt-Anchor" href="#有效地址ea"></a> 有效地址EA</h1><ul><li>8086中把<strong>操作数的偏移地址</strong>称为有效地址(EA)<br><strong>EA = 基址 + (变址*比例因子) + 位移量</strong></li></ul><table><thead><tr><th>四种成分</th><th>16位寻址</th><th>32位寻址</th></tr></thead><tbody><tr><td>位移量</td><td>0、8、16位</td><td>0、8、16、32位</td></tr><tr><td>基址寄存器</td><td>BX，BP</td><td>任何32位通用寄存器(包括ESP)</td></tr><tr><td>变址寄存器</td><td>SI，Di</td><td>除ESP以外的32位通用寄存器</td></tr><tr><td>比例因子</td><td>无</td><td>1、2、4、8</td></tr></tbody></table><ul><li>比例因子为固定值，其他三个成分都可正可负，以保证指针移动的灵活性</li><li>比例因子：386及后续机型新增的寻址方式中的一个术语，其值可以为1、2、4、8。</li></ul><h1 id="与数据有关的寻址方式"><a class="markdownIt-Anchor" href="#与数据有关的寻址方式"></a> 与数据有关的寻址方式</h1><ul><li>以MOV指令为例<ul><li>立即寻址：MOV  AX,3069H</li><li><strong>寄存器寻址：MOV  AL,BH</strong></li><li><strong>直接寻址：MOV  AX,[2000H]</strong></li><li>寄存器间接寻址：MOV AX,[BX]</li><li><strong>寄存器相对寻址：MOV AX,COUNT[SI]</strong></li><li>基址变址寻址：MOV AX,[BP][DI]</li><li>相对基址变址寻址：MOV AX,MASK[BX][SI]</li></ul></li></ul><h2 id="立即数寻址"><a class="markdownIt-Anchor" href="#立即数寻址"></a> 立即数寻址</h2><p>如：MOV AX, 3069H</p><ul><li><strong>操作数作为指令的一部分</strong>直接写在指令中，这种操作数成为立即数，这种寻址方式也成为立即数寻址方式</li><li>特点：操作数存放在存储器中，<strong>指令的下一单元即为立即操作数n</strong>。</li></ul><h2 id="寄存器寻址"><a class="markdownIt-Anchor" href="#寄存器寻址"></a> 寄存器寻址</h2><p>如：MOV AL, BH</p><ul><li><strong>指令中要用到的操作数已经存储在某寄存器中，或把目标操作数存入某寄存器</strong>。把指令中指出所使用寄存器（即寄存器的助记符）的寻址方式成为寄存器寻址</li><li>特点：操作数直接存放在寄存器中，<strong>速度较快</strong></li></ul><h2 id="直接寻址"><a class="markdownIt-Anchor" href="#直接寻址"></a> 直接寻址</h2><p>如：MOV AX, [2000H]</p><ul><li><strong>EA = 操作数</strong></li><li>指令所要的操作数存放在内存中，指令中<strong>直接给出该操作数的有效地址</strong></li><li>特点：操作数的有效地址只包含位移量一种成分</li><li>直接寻址的地址要写在”[]”内</li></ul><h2 id="寄存器间接寻址"><a class="markdownIt-Anchor" href="#寄存器间接寻址"></a> 寄存器间接寻址</h2><p>如：MOV AX, [BX]</p><ul><li><strong>EA = BX</strong></li><li>操作数在存储器中，<strong>操作数的有效地址使用SI、DI、BX和BP等四个寄存器之一来指定</strong></li><li>特点：有效地址在寄存器中，操作数在存储器中</li></ul><h2 id="寄存器相对寻址"><a class="markdownIt-Anchor" href="#寄存器相对寻址"></a> 寄存器相对寻址</h2><p>如：MOV AX，COUNT[SI] (也可表示为 MOV AX, [COUNT+SI])</p><ul><li><strong>EA = COUNT + SI</strong></li><li>操作数在存储器中，其有效地址是<strong>一个基址寄存器(BX、BP)或变址寄存器(SI、DI)的内容和指令中的8位/16位偏移量之和</strong></li><li>特点：有效地址由两种成分组成</li></ul><h2 id="基址变址-寻址"><a class="markdownIt-Anchor" href="#基址变址-寻址"></a> 基址变址 寻址</h2><p>如：MOV AX,[BP][SI](或MOV AX,[BP+SI])</p><ul><li><strong>EA = BP+SI</strong></li><li>操作数存储在存储器中，其地址是一个基址寄存器（BX、BP）和一个变址寄存器（SI、DI）的内容之和</li><li>处理数组和表格，首地址放在基址寄存器(BX,BP)，而用变址寄存器(SI,DI)来访问数组的各个元素</li></ul><h2 id="相对基址变址寻址"><a class="markdownIt-Anchor" href="#相对基址变址寻址"></a> 相对基址变址寻址</h2><p>如：MOV AX,MASK[BX][SI]</p><ul><li><strong>EA = MASK+BX+SI</strong></li><li>操作数存放于存储器中，其有效地址是由一个基址寄存器（BX、BP）、一个变址寄存器（SI、DI）和指令中的8位/16位偏移量之和</li><li>通常用于二维数组的寻址</li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编指令</title>
      <link href="/2019/12/13/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"/>
      <url>/2019/12/13/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="标志寄存器flasgs"><a class="markdownIt-Anchor" href="#标志寄存器flasgs"></a> 标志寄存器FLASGS</h1><ol><li>ZF(Zero Flag)</li></ol><ul><li>零标志位，执行完相关指令后，其结果是否为0</li><li>为0则ZF=1；不为0则ZF=0</li></ul><ol start="2"><li>CF(Carry Flag)</li></ol><ul><li>进位标志位，当运行结果的最高有效位有进位（加法）或借位（减法）时，进位标志置1，即CF=1;否则CF=0</li></ul><ol start="3"><li>SF(Sign Flag)</li></ol><ul><li>运行结果最高位为1，则SF=1，否则SF=0</li></ul><ol start="4"><li>PF(Parity Flag)</li></ol><ul><li>当运行结果最低字节的“1”的个数为零或者偶数时，PF=1，否则，PF=0</li></ul><ol start="5"><li>OF(Overflow Flag)</li></ol><ul><li>若算术运算的结果有溢出则OF=1，否则OF=0</li></ul><h1 id="数据传送指令"><a class="markdownIt-Anchor" href="#数据传送指令"></a> 数据传送指令</h1><h2 id="mov"><a class="markdownIt-Anchor" href="#mov"></a> MOV</h2><p>中文名：传送指令<br>允许以下操作：</p><ol><li>MOV 寄存器，寄存器/内存单元/段寄存器/立即数</li><li>MOV 内存单元，寄存器/段寄存器/立即数</li><li>MOV 段寄存器，寄存器/内存单元</li></ol><p>不允许以下操作：<br>4. 两个操作数类型不一样</p><ul><li>例如源操作数是字节，而目的操作数是字</li></ul><ol start="5"><li>两个操作数不能都是内存单元的数<ul><li>主存之间的直接传送不允许</li></ul></li><li>段寄存器的操作限制：<ol><li><strong>不允许直接传立即数给段寄存器</strong><blockquote><p>不能直接用变量名，因为变量其实也是个立即数</p></blockquote></li><li>不要直接改变CS值</li><li>不允许段寄存器之间的直接数据传送</li></ol></li></ol><h2 id="push"><a class="markdownIt-Anchor" href="#push"></a> PUSH</h2><p>进栈操作，以一个字为例，系统自动完成两步操作：</p><ol><li>SP ⬅ SP-2 //堆栈指针减2</li><li>(SP+1,SP) ⬅ SRC //将数据压入堆栈</li></ol><h2 id="pop"><a class="markdownIt-Anchor" href="#pop"></a> POP</h2><p>出栈操作，弹出一个字为例，系统自动完成两步操作：</p><ol><li>操作数 ⬅ SP</li><li>SP ⬅ SP+2<br>功能：将栈顶内容弹至某一寄存器，段寄存器(CS除外)或存储器</li></ol><h2 id="xchg"><a class="markdownIt-Anchor" href="#xchg"></a> XCHG</h2><p>XCHG OPR1, OPR2<br>功能：交换指令，OPR1，OPR2互换</p><h2 id="lea"><a class="markdownIt-Anchor" href="#lea"></a> LEA</h2><p>LEA Reg，Mem<br>功能：将一个内存变量的有效地址送给指定的寄存器</p><h2 id="类型转换指令"><a class="markdownIt-Anchor" href="#类型转换指令"></a> 类型转换指令</h2><h3 id="cbw-al-ax"><a class="markdownIt-Anchor" href="#cbw-al-ax"></a> CBW AL → AX</h3><ul><li>执行的操作：<ul><li>若(AL)的最高有效位为0则 AH = 00H</li><li>若(AL)的最高有效位为1则 AH = 0FFH</li></ul></li></ul><h3 id="cwd-ax-dxax"><a class="markdownIt-Anchor" href="#cwd-ax-dxax"></a> CWD AX → (DX,AX)</h3><ul><li>执行操作：<ul><li>若（AX）的最高有效位为0，则（DX)= 0000H</li><li>若（AX）的最高有效位为1，则（DX)= 0FFFFH</li></ul></li></ul><h1 id="算术指令"><a class="markdownIt-Anchor" href="#算术指令"></a> 算术指令</h1><h2 id="加法"><a class="markdownIt-Anchor" href="#加法"></a> 加法</h2><ul><li>重要的条件标志位：ZF，CF，SF，OF<ul><li>ZF，SF设置较为简单</li><li>CF：最高有效位是否有进位</li><li>OF：两个操作数符号(最高有效位)相同，结果与之相反则OF=1；否则OF=0</li></ul></li><li>INC对符号位无影响</li></ul><h3 id="add"><a class="markdownIt-Anchor" href="#add"></a> ADD</h3><p>功能：DST ⬅ DST+SRC</p><h3 id="adc"><a class="markdownIt-Anchor" href="#adc"></a> ADC</h3><p>功能：带进位的加法，DST ⬅ DST+SRC+CF</p><h3 id="inc"><a class="markdownIt-Anchor" href="#inc"></a> INC</h3><p>功能：OPR ⬅ OPR+1</p><h2 id="减法"><a class="markdownIt-Anchor" href="#减法"></a> 减法</h2><ul><li>CF：减数 &gt; 被减数，此时有借位，则CF=1；否则CF=0</li><li>OF：两个数符号(最高有效位)相反，而结果符号与减数相同，则OF=1；否则OF=0</li><li>DEC对符号位无影响</li></ul><h3 id="sub"><a class="markdownIt-Anchor" href="#sub"></a> SUB</h3><p>功能：功能：DST ⬅ DST-SRC</p><h3 id="dec"><a class="markdownIt-Anchor" href="#dec"></a> DEC</h3><p>功能：OPR ⬅ OPR-1</p><ul><li>对CF标志位无影响</li></ul><h3 id="neg"><a class="markdownIt-Anchor" href="#neg"></a> NEG</h3><p>功能：求补，每位求反(包括符号位)后加1</p><ul><li>OPR ⬅ 0 - OPR</li><li>因此，除了OPR=0，其他情况CF=1</li></ul><h3 id="cmp"><a class="markdownIt-Anchor" href="#cmp"></a> CMP</h3><p>功能：得到(OPR1-OPR2)的结果，改变标志位ZF或CF</p><h2 id="乘法"><a class="markdownIt-Anchor" href="#乘法"></a> 乘法</h2><ul><li>无符号乘法：MUL  SRC</li><li>有符号乘法：IMUL SRC</li><li>功能：<ul><li>若是字节数据相乘，<strong>AL和SRC相乘的结果放在AX</strong><ul><li>AX⬅AL*SRC</li></ul></li><li>若是字数据相乘，(AX)和SRC相乘得到的双字数据，<strong>高字放入DX，低字放入AX</strong><ul><li>DX,AX⬅AX*SRC</li></ul></li></ul></li><li><strong>乘法中OF，CF使用来判断相乘的结果是什么类型。</strong><blockquote><p>字节相乘的结果是字节还是字。OF=CF=0为字节，OF=CF=1为字<br>字相乘的结果是字还是双字。OF=CF=0为字，OF=CF=1为双字</p></blockquote></li></ul><h2 id="除法"><a class="markdownIt-Anchor" href="#除法"></a> 除法</h2><ul><li>无符号除法：DIV SRC</li><li>有符号除法：IDIV SRC</li><li>执行的操作(低位放商，高位放余数)：<ul><li>字节操作：<blockquote><p>(AL)⬅(AX)/(SRC)的商<br>(AH)⬅(AX)/(SRC)的余数</p></blockquote></li><li>字操作：<blockquote><p>(AX)⬅(DX,AX)/(SRC)的商<br>(DX)⬅(DX,AX)/(SRC)的余数</p></blockquote></li></ul></li><li><strong>对标志位没影响，但也会产生溢出</strong></li><li>可能产生编号为0的内部中断：除法错中断</li></ul><h1 id="逻辑指令"><a class="markdownIt-Anchor" href="#逻辑指令"></a> 逻辑指令</h1><h2 id="逻辑运算指令"><a class="markdownIt-Anchor" href="#逻辑运算指令"></a> 逻辑运算指令</h2><h3 id="and"><a class="markdownIt-Anchor" href="#and"></a> AND</h3><p>功能：两个操作数<strong>按位与操作</strong>，结果存入操作数<br>用途：该指令用于清除目的操作数中与源操作数中置0位对应的位</p><ul><li>DST ⬅ DST &amp; SRC</li></ul><h3 id="or"><a class="markdownIt-Anchor" href="#or"></a> OR</h3><p>功能：两个操作数<strong>按位或操作</strong>，结果放入操作数<br>用途：用于设置目的操作数中与源操作数置1位的对应位</p><ul><li>DST ⬅ DST | SRC</li></ul><h3 id="not"><a class="markdownIt-Anchor" href="#not"></a> NOT</h3><p>功能：按位取反</p><ul><li>DST ⬅ ~DST</li></ul><h3 id="xor"><a class="markdownIt-Anchor" href="#xor"></a> XOR</h3><p>功能：两个操作数<strong>按位异或</strong>，将结果放入操作数</p><ul><li>DST ⬅ DST⊕SRC</li></ul><h3 id="test"><a class="markdownIt-Anchor" href="#test"></a> TEST</h3><p>功能：两个操作数相与，但结果不保存，只根据其特征置条件码</p><ul><li>OPR1 &amp; OPR2</li></ul><h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3><ul><li>NOT不允许使用立即数，其他4条指令至少有一个操作数必须在寄存器中</li><li>NOT不影响符号位，其他4条指令 <strong>将CF，OF置0</strong> ，AF无定义，而SF，ZF，PF根据结果来设置</li></ul><h2 id="移位指令"><a class="markdownIt-Anchor" href="#移位指令"></a> 移位指令</h2><ul><li><strong>移位指令后面的数只能为 1，大于1的时候用cl</strong></li><li>如：shr xxx,cl；shr xxx,1</li></ul><h3 id="算术移位arithmetic"><a class="markdownIt-Anchor" href="#算术移位arithmetic"></a> 算术移位(arithmetic)</h3><p>算术移位指令有：算术左移<strong>SAL</strong>和算术右移<strong>SAR</strong></p><ul><li>指令格式为SAL/SAR  OPR,CL/Imm</li><li>受影响的标志位：CF、OF、PF、ZF和SF(AF无定义)</li><li>功能：<ul><li>算术左移SAL把目的操作数的低位向高位移，空出的低位补0</li><li>算术右移SAR把目的操作数的高位向低位移，空出的高位用最高位（符号位）填补</li><li>算术移位指令常用于带符号数*2或/2</li></ul></li></ul><h3 id="逻辑移位logical"><a class="markdownIt-Anchor" href="#逻辑移位logical"></a> 逻辑移位(logical)</h3><p>逻辑左移<strong>SHL</strong>和逻辑右移<strong>SHR</strong>它们的指令格式如下：<br>SHL/SHR　OPR, CL/Imm</p><ul><li>受影响的标志位：CF(移出放在CF)、OF、PF、SF和ZF（AF无定义）。</li><li>逻辑左移/右移指令只有它们的移位方向不同，移位后空出的位都补0</li><li>逻辑移位指令常用于无符号数*2或/2<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191212171032.png" class="lazyload"></li></ul><h3 id="循环移位rotate"><a class="markdownIt-Anchor" href="#循环移位rotate"></a> 循环移位(rotate)</h3><p>循环移位指令有：</p><ol><li>循环：左移<strong>ROL</strong>，右移<strong>ROR</strong>；</li><li>带进位循环：左移<strong>RCL</strong>，右移<strong>RCR</strong></li></ol><ul><li>指令的格式：ROL/ROR　OPR, CL/Imm</li><li>受影响的标志位：CF和OF</li><li>循环左移/右移指令只是移位方向不同，它们移出的位不仅要进入CF，而且还要填补空出的位。</li><li>带进位循环移动将CF加入循环中</li></ul><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>无符号数：逻辑移位<br>有符号数：算术移位</p><ul><li>逻辑左移和算术左移一致，均把移出的放在CF，末位补0</li><li>逻辑右位的方法是逻辑左移镜像</li><li>算术右移移出的放在CF，但是首位补符号位，而不是补0</li></ul><h1 id="串处理指令"><a class="markdownIt-Anchor" href="#串处理指令"></a> 串处理指令</h1><h2 id="方向标志"><a class="markdownIt-Anchor" href="#方向标志"></a> 方向标志</h2><p>执行串处理指令时会根据DF(direction flag)来使地址自动增加/减少</p><ul><li><strong>CLD(DF=0)增加</strong> 和 <strong>STD(DF=1)减少</strong></li></ul><h2 id="重复前缀指令rep"><a class="markdownIt-Anchor" href="#重复前缀指令rep"></a> 重复前缀指令REP</h2><p>重复前缀指令是重复其后的字符串操作指令，<strong>重复的次数由CX来决定</strong>。</p><ul><li>一般格式为：REP　MOVS / STOS / LODS</li></ul><h2 id="相等重复前缀指令reperepz"><a class="markdownIt-Anchor" href="#相等重复前缀指令reperepz"></a> 相等重复前缀指令REPE(REPZ)</h2><p>重复条件：CX != 0 &amp;&amp; ZF = 1</p><h2 id="不等重复前缀指令repnerepnz"><a class="markdownIt-Anchor" href="#不等重复前缀指令repnerepnz"></a> 不等重复前缀指令REPNE(REPNZ)</h2><p>重复条件：CX != 0 &amp;&amp; ZF = 0</p><h2 id="串比较指令-cmps"><a class="markdownIt-Anchor" href="#串比较指令-cmps"></a> 串比较指令 CMPS</h2><ul><li>语句格式：<ul><li>CMPSB——字节串比较</li><li>CMPSW——字串比较</li></ul></li><li>功能：将SI所指的源串中的一个字节（或字）存储单元中的数据与DI所指的目的串中的一个字节（或字）存储单元中的数据相减，并<strong>根据相减的结果设置标志，但结果并不保存</strong></li></ul><h1 id="控制转移指令"><a class="markdownIt-Anchor" href="#控制转移指令"></a> 控制转移指令</h1><h2 id="无条件转移指令"><a class="markdownIt-Anchor" href="#无条件转移指令"></a> 无条件转移指令</h2><p>包括：<strong>JMP</strong>、<strong>子程序调用和返回</strong>、<strong>中断的调用和返回指令</strong></p><h2 id="条件转移指令"><a class="markdownIt-Anchor" href="#条件转移指令"></a> 条件转移指令</h2><p>分为三类:</p><ol><li>基于<strong>无符号数</strong>的条件转移指令</li><li>基于<strong>有符号数</strong>的条件转移指令</li><li>基于<strong>特殊算术标志位</strong>的条件转移指令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JXX  LABEL  ;条件满足：转移，(IP)⬅(IP)+位移量</span><br><span class="line">            ;条件不满足，顺序执行</span><br></pre></td></tr></table></figure><ul><li>操作数LABEL采用短转移，成为相对寻址方式</li><li>JXX不影响标志位，但要利用标志位。</li></ul><h3 id="根据单个条件标志的设置情况转移"><a class="markdownIt-Anchor" href="#根据单个条件标志的设置情况转移"></a> 根据单个条件标志的设置情况转移</h3><table><thead><tr><th>指令助忆符</th><th>检测转移的条件</th><th>功能描述</th></tr></thead><tbody><tr><td>JZ(JE)</td><td>ZF=1</td><td>结果为零或相等则转移</td></tr><tr><td>JNZ(JNE)</td><td>ZF=0</td><td>结果不为0或不等则转移</td></tr><tr><td>JS/JNS</td><td>SF=1/SF=0</td><td>结果为负/正则转移</td></tr><tr><td>JO/JNO</td><td>OF=1/OF=0</td><td>结果溢出/不溢出则转移</td></tr><tr><td>JP/JNP</td><td>PF=1/PF=0</td><td>奇偶位为1/0则转移</td></tr></tbody></table><h3 id="无符号数的条件转移"><a class="markdownIt-Anchor" href="#无符号数的条件转移"></a> 无符号数的条件转移</h3><ul><li>Below，Equal，Above</li></ul><table><thead><tr><th>指令助忆符</th><th>检测转移的条件</th><th>功能描述</th></tr></thead><tbody><tr><td>JB/JNAE</td><td>CF=1</td><td>小于时，或进位为1则转移</td></tr><tr><td>JNB/JAE</td><td>CF=0</td><td>不小于，或进位为0转移</td></tr><tr><td>JBE/JNA</td><td>CFvZF=1</td><td>小于等于则转移</td></tr><tr><td>JNBE/JA</td><td>CF^ZF=0</td><td>不小于等于,即大于,则转移</td></tr></tbody></table><h3 id="有符号数的条件转移"><a class="markdownIt-Anchor" href="#有符号数的条件转移"></a> 有符号数的条件转移</h3><ul><li>Less，Equal，Greater</li></ul><table><thead><tr><th>指令助忆符</th><th>检测转移的条件</th><th>功能描述</th></tr></thead><tbody><tr><td>JL/JNGE</td><td>SF⊕OF=1</td><td>小于则转移</td></tr><tr><td>JNL/JGE</td><td>SF⊕OF=1</td><td>不小于，即大于等于转移</td></tr><tr><td>JLE/JNG</td><td>ZF=1 or SF!=OF</td><td>小于等于则转移</td></tr><tr><td>JG/JNLE</td><td>ZF=0 and SF=OF</td><td>不小于等于,即大于,则转移</td></tr></tbody></table><h2 id="循环指令"><a class="markdownIt-Anchor" href="#循环指令"></a> 循环指令</h2><h3 id="loop"><a class="markdownIt-Anchor" href="#loop"></a> LOOP</h3><ul><li>指令格式：LOOP 短标号</li><li>执行过程：如果CX ≠ 0，转向“标号”所指向的指令，否则，终止循环，执行该指令的下一条指令</li><li>说明：使用LOOP可以代替以下两条指令：<blockquote><p>DEC  CX<br>JNE  短标号</p></blockquote></li></ul><h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3><ul><li>相等/为0循环指令 LOOPE/LOOPZ</li><li>不相等/不为零循环指令LOOPNE/LOOPNZ</li></ul><h2 id="子程序调用和返回"><a class="markdownIt-Anchor" href="#子程序调用和返回"></a> 子程序调用和返回</h2><h3 id="调用指令-call"><a class="markdownIt-Anchor" href="#调用指令-call"></a> 调用指令 CALL</h3><p>类似JMP指令，但是不同于JMP，CALL指令需要保存返回地址(将其入栈)</p><h3 id="返回指令-ret"><a class="markdownIt-Anchor" href="#返回指令-ret"></a> 返回指令 RET</h3><p>将栈内保存的地址弹出，折返调用该子程序的位置</p><h2 id="中断的调用和返回指令"><a class="markdownIt-Anchor" href="#中断的调用和返回指令"></a> 中断的调用和返回指令</h2><h3 id="中断指令-int"><a class="markdownIt-Anchor" href="#中断指令-int"></a> 中断指令 INT</h3><ul><li>一般格式：INT TYPE</li><li>其中：立即数TYPE是一个0~0FFH范围内的整数。</li><li>指令执行的步骤：<ol><li>把标志寄存器压栈，清除标志位IF和TF；</li><li>把代码段寄存器CS和指令指针寄存器IP的内容压栈；</li><li>IP ← TYPE<em>4，CS ← TYPE</em>4+2</li></ol></li></ul><h3 id="溢出指令-into"><a class="markdownIt-Anchor" href="#溢出指令-into"></a> 溢出指令 INTO</h3><p>当标志位OF为1时，引起中断。</p><h3 id="中断返回指令-iret"><a class="markdownIt-Anchor" href="#中断返回指令-iret"></a> 中断返回指令 IRET</h3><ul><li>当一个中断服务程序执行完毕时，CPU将恢复被中断的现场，返回到引起中断的程序中。</li><li>该指令执行的过程基本上是INT指令的逆过程:<ol><li>从栈顶弹出内容送入IP</li><li>再从新栈顶弹出内容送入CS</li><li>再从新栈顶弹出内容送入标志寄存器</li></ol></li></ul><h2 id="中断和子程序的比较"><a class="markdownIt-Anchor" href="#中断和子程序的比较"></a> 中断和子程序的比较</h2><ul><li>相同之处：暂停当前程序的执行，转而执行另一程序段，当该程序段执行完时，CPU都自动恢复原程序的执行。</li><li>不同之处：<ol><li>调用：子程序人为调用；中断不可预见(除了INT引起的中断)</li><li>实现方式：子程序调用是用CALL指令来实现的，但没有调用中断的指令，只有发出中断请求的事件（指令INT是发出内部中断信号，而不要理解为调用中断服务程序）；</li><li>返回方式：子程序RET；中断IRET</li><li>在通常情况下，子程序是由应用系统的开发者编写的，而中断服务程序是由系统软件设计者编写的。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承与派生</title>
      <link href="/2019/12/12/C++%E5%AD%A6%E4%B9%A0/%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/"/>
      <url>/2019/12/12/C++%E5%AD%A6%E4%B9%A0/%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<ul><li>继承的三种方式：<ol><li>public</li><li>private (默认)</li><li>protected</li></ol></li></ul><hr><ul><li>三种继承方式的不同<table><thead><tr><th>继承方式</th><th>public</th><th>protected</th><th>private</th></tr></thead><tbody><tr><td>public</td><td>public</td><td>protected</td><td>不可访问</td></tr><tr><td>private</td><td>private</td><td>private</td><td>不可访问</td></tr><tr><td>protected</td><td>protected</td><td>protected</td><td>不可访问</td></tr></tbody></table></li><li>tips：<ul><li>xx继承的话，访问权限必须 &lt;= xx</li><li>基类的private均不可访问</li><li>protected 成员不能在类外被访问</li></ul></li></ul><hr><ul><li>类里定义的默认成员变量和函数均为private</li><li>类默认为public</li><li>全局成员默认public</li></ul><hr><ul><li>派生类的构成<ol><li>从基类接受成员</li><li>调整从基类接受的成员。</li></ol><ul><li>变化访问权限</li><li>重写，同名即覆盖</li></ul><ol start="3"><li>新增成员</li></ol></li></ul><hr><ul><li>执行派生类构造函数的顺序：<ol><li>调用 <strong>基类</strong> 构造函数，只与 <strong>声明的顺序</strong> 有关，和派生类中的调用顺序无关</li><li>调用 <strong>子对象</strong> (对象中的对象) 构造函数</li></ol><ul><li>调用方法：<strong>子对象名</strong> (参数表)，没有显式调用的话则为默认构造函数</li></ul><ol start="3"><li>再执行 <strong>派生类</strong> 的构造函数本身</li></ol></li></ul><hr><ul><li>虚基类(virtual)的作用：在继承间接共同基类时，只保存<strong>一份成员</strong><ul><li>C++编译系统只执行 <strong>最后的派生类对虚基类的构造函数的调用</strong> ，而忽略虚基类其他的派生类。所以我们可以直接显式的调用虚基类的构造函数。</li></ul></li><li>虚基类和抽象类的区别<ul><li>虚基类式相对它的派生类而言，它可以是个普通的类，被虚继承才叫做虚基类</li><li>而抽象类是类中有一个以上的纯虚函数，只能用于继承，不能生成对象，但是能定义对象指针，然后指向派生类对象，实现多态性</li></ul></li></ul><hr><ul><li>基类和派生类的转换<ul><li>只有public继承的类型才是真正的子类型</li><li>只能用 <strong>派生类对象对基类对象</strong> 赋值，反之不允许<ul><li>因为基类有的派生类都有，而派生类有的基类不一定有</li></ul></li><li>同一基类的不同派生类对象之间不能赋值</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编小知识点</title>
      <link href="/2019/12/11/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96/"/>
      <url>/2019/12/11/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<ul><li>bit(比特)：一个二进制位，电子计算机的最小的信息单元</li><li>Byte(字节)：一个字节，八个二进制位</li><li>Word(字)：两个字节，分为高位字节和地位字节，十六个二进制位</li></ul><hr><ul><li>寻址能力：$ 2 ^ N(N为地址线宽度) $</li><li>传输能力：数据线宽度</li></ul><hr><ul><li>通用寄存器：通常用来存放一般性数据<ul><li>16位：AX, BX, CX, DX</li><li>以上四个可以拆成两个8位寄存器，例如：AX = AH + AL，拆分使用的话，AH和AL是完全独立的寄存器，两者的数据不相关</li></ul></li><li>为了区分不同数制：<ul><li>十六进制：末尾加上H；如果首位位字母，补0</li><li>十进制：什么也不加</li><li>二进制：末尾加上B</li></ul></li></ul><hr><ul><li>8086CPU给出物理地址的方法<ul><li><strong>物理地址 = 段地址 x 16 + 偏移地址</strong><ul><li>上式合成20位地址，1MB的寻址能力</li><li>本质含义：用一个基础地址(段地址x16)和一个相对于基础地址的偏移地址相加。给出物理地址</li><li>段地址 x 16 ：将段地址左移4位即可</li></ul></li></ul></li><li>8086CPU可以分成16个段，每个段有64KB，总共1MB</li><li>段的概念：<ul><li>内存并没有被划分成一个一个段，而只是将<strong>若干地址连续的内存单元<em>看作</em>一个段</strong></li></ul></li></ul><hr><ul><li><p>段寄存器：提供段地址</p><ul><li>16位：CS(代码)，DS(数据)，SS(堆栈)，ES(附加)</li></ul></li><li><p>CS和IP为8086CPU中两个<strong>最关键</strong>的寄存器：</p><ul><li>CS为代码段寄存器</li><li>IP为指令指针寄存器</li><li>8086机中，任何时刻，CPU将 <strong>CS:IP (CS*16 + IP)</strong> 指向的内容当作指令执行。<ul><li>读取一条指令后，<strong>IP = IP + 所读取指令长度</strong>，从而指向下一条指令</li></ul></li><li>要通过Jump指令修改，普通的MOV指令不能修改</li></ul></li></ul><hr><ul><li>内存中字的存储：高高低低<ul><li>高地址放高位，低地址放低位</li></ul></li><li>字单元：存放一个字型数据(16位)的内存单元</li><li>起始地址为N的字单元成为N地址字单元</li></ul><hr><ul><li>DS和[address]<ul><li>DS为数据段寄存器，存放数据的段地址</li><li>address为偏移地址,[address]表示一个偏移地址为address的内存单元</li></ul></li></ul><hr><ul><li>SS和SP<ul><li>SS为栈顶的段寄存器</li><li>SP为指向栈底的指针，可以修改</li><li>任何时刻，<strong>SS:SP指向栈顶元素</strong></li></ul></li><li>8086CPU只记录栈顶的位置，栈空间的大小要自己管理</li><li>POP和PUSH指令<strong>只修改SP指针</strong></li></ul><blockquote><p>初始化栈的操作<br>mov ax,1000H<br>mov ss,ax<br>mov sp,0010H<br>;设置栈顶的偏移地址，因栈为空，SP指向栈最底部单元的下一单元</p></blockquote><hr><ul><li>子程序格式：</li></ul><blockquote><p>过程名     PROC      [NEAR/FAR]<br>┆<br>过程名     ENDP</p></blockquote><ul><li>其中PROC表示过程定义开始，ENDP表示过程定义结束。过程名是过程入口地址的符号表示</li><li>一般过程名同标号一样，具有三种属性，即<strong>段属性、偏移地址属性以及类型属性</strong>（NEAR 或 FAR)</li><li>过程属性确定原则：<ul><li>NEAR：在同一代码段中</li><li>FAR：在不同代码段中</li><li>主程序MAIN应该为FAR属性</li></ul></li><li>CALL和RET完成调用和返回<ul><li>CALL调用时使返回地址入栈</li><li>RET时应能使返回地址正确出栈</li></ul></li><li>保护现场和恢复现场<ul><li>利用堆栈来实现</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PROGPROC</span><br><span class="line">PUSHAX</span><br><span class="line">PUSH BX</span><br><span class="line">        PUSHCX</span><br><span class="line">PUSHDX ;保护现场</span><br><span class="line"></span><br><span class="line">        POPDX</span><br><span class="line">POPCX</span><br><span class="line">POPBX</span><br><span class="line">POPAX  ;恢复现场</span><br><span class="line">RET    ;返回断点处</span><br><span class="line">PROCENDP</span><br></pre></td></tr></table></figure><ul><li>参数传递方法<ol><li>通过寄存器传递参数</li><li>如果过程和调用在同一源文件（同一程序模块中），则过程可以直接访问模块中的变量</li><li>通过地址表传递参数</li><li>通过堆栈传送参数或参数地址</li><li>多个模块间参数传递</li></ol><blockquote><ol><li>public 符号,符号……</li></ol><ul><li>说明其后的符号是全局符号。全局符号能被其他模块引用。</li></ul><ol start="2"><li>extrn 符号:类型,符号:类型……</li></ol><ul><li>说明在本模块中需要引用的、由其他模块定义的符号，即外部符号。</li></ul></blockquote></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOS-21H</title>
      <link href="/2019/12/11/%E6%B1%87%E7%BC%96/DOS-21H/"/>
      <url>/2019/12/11/%E6%B1%87%E7%BC%96/DOS-21H/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AH,xxH</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><p>常用Dos功能调用：</p><ol><li><p><strong>单字符输入（01H号调用）</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AH,01H</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><ul><li>从键盘输入字符的ASCII码送入寄存器AL中，并送显示器显示</li></ul></li><li><p><strong>单字符显示（02H号调用）</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV DL,待显示字符的ASCII码</span><br><span class="line">MOV AH,02H</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><ul><li>将DL寄存器中的字符送显示器显示</li></ul></li><li><p><strong>打印输出（05H号调用）</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV DL,待打印字符的ASCII码</span><br><span class="line">MOV AH,05H</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><ul><li>将DL寄存器中的字符送打印机打印</li></ul></li><li><p><strong>结束调用（4CH号调用）</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AH,4CH</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><ul><li>终止当前程序并返回调用程序</li></ul></li><li><p><strong>显示字符串（09H号调用）</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LEA DX,待显示字符串的首偏移地址</span><br><span class="line">MOV AH,09H</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><ul><li>将当前数据区(DX为首地址)中以 <strong>‘＄’</strong> 结尾的字符串送显示器显示，一般把缓冲区设为全 <strong>‘＄’</strong></li></ul></li><li><p><strong>字符串输入（0AH号调用）</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LEA DX,缓冲区的首偏移地址</span><br><span class="line">MOV AH,0AH</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><ul><li>从键盘上输入一字符串到用户定义的输入缓冲区(DX为首地址)中，并送显示器显示</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态性与虚函数</title>
      <link href="/2019/12/11/C++%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E6%80%81%E6%80%A7%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2019/12/11/C++%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E6%80%81%E6%80%A7%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>静态多态性：函数重载</li><li>动态多态性：运行阶段调用被派生类重写的函数，通过虚函数实现</li></ul><hr><ul><li>派生类对象可以代替基类对象向基类对象的引用初始化或赋值<ul><li>派生类的对象可以初始化基类对象</li></ul></li></ul><hr><ul><li>虚函数：基类中声明函数是 <strong>虚拟的</strong> ，并不是实际存在的函数，然后在 <strong>派生类中才正式定义</strong> 此函数<ul><li>但是，在基类中也可以写出定义，以供基类对象调用，即虚函数可以有定义内容</li><li>在基类中没有定义的函数可以作为纯虚函数声明</li></ul></li></ul><hr><ul><li>纯虚函数：基类对象不会使用该函数，返回值也没有意义，可以只给出函数的原型，并在末尾加上 <em>“=0”</em><ul><li>virtual 函数类型 函数名 (参数表列) = 0；</li></ul></li></ul><hr><ul><li>抽象类<ul><li>定义该类的唯一目的是：<strong>用它作为基类去建立派生类</strong></li><li>凡是包含 <strong>纯虚函数</strong> 的类都是抽象类</li><li>不能定义对象，但是能定义对象指针</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和对象</title>
      <link href="/2019/12/10/C++%E5%AD%A6%E4%B9%A0/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/12/10/C++%E5%AD%A6%E4%B9%A0/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<ul><li>声明对象的两种方式：<ul><li>Object obj(参数表/为空);<ul><li>在栈上</li></ul></li><li>Object *pObj = new Object(参数表/为空);<ul><li>在堆上，这个要记得delete释放</li></ul></li></ul></li></ul><hr><ul><li>默认构造函数种类：<ol><li>没有任何参数，如：Object();</li><li>所有参数都有默认值，如：Object(int x = 0);</li></ol></li><li>两者不能同时共存，一个类只能有一个默认构造函数</li></ul><hr><ul><li>只能有一个析构函数<ul><li>析构函数的作用：<br>不是删除对象，而是撤销对象占用的内存<strong>之前</strong>，完成<strong>一些清理工作</strong></li><li>调用时间：<br>生命期结束时，和变量类似</li></ul></li></ul><hr><ul><li>构造函数和析构函数的调用顺序：<ol><li>先构造的后析构，后构造的先析构<br>类似于栈，先进后出</li><li>子类构造函数必须调用父类的构造函数<br>父类有无参构造函数，会自动调用<br>父类无无参构造函数，必须显式调用，否则报错（Java也是）</li><li>虚基类的构造函数最先调用</li></ol></li></ul><hr><ul><li>对于派生类的构造函数，在定义对象时构造函数的执行顺序为：<ol><li>虚基类的构造函数</li><li>基类的构造函数</li><li>成员对象的构造函数</li><li>派生类本身的构造函数</li></ol></li><li>若一个子类虚继承了两个父类，这两个父类有着共同父类，那么调用构造函数的时候，只调用一次，因为虚继承只保留一份成员</li><li>一个对象能含有多个子对象，因为有可能同一个构造函数调用了多次</li></ul><hr><ul><li>声明对象数组时候，调用n次构造函数(与Java不同)，声明抽象类数组的时候，应该为Object *objs[n]</li></ul><hr><ul><li>编译器不会自动生成默认构造函数，除非迫不得已<blockquote><p>例如：基类有构造函数，而派生类没有，编译器才会生成一个派生类的构造函数</p></blockquote></li></ul><hr><ul><li>构造函数不能为虚函数，析构函数可以是</li></ul><hr><ul><li>对象指针就是对象的起始空间<br>声明对象指针时，注意：Object *p()和(Object *p)()不一样，结合优先级<br>第一个返回一个void指针，等同于void(Object *(p()))<br>第二个才是返回一个对象指针</li></ul><hr><ul><li>常对象，常对象成员：<ol><li>常对象：Object const obj(…)<br>能访问数据成员，但是不能修改<br>只能访问常成员函数</li><li>常数据成员：const int i<br>只能用构造函数的参数初始化，其他任何函数都不能修改</li><li>常成员函数：void get() const //const放在函数名和括号后面<br>可以引用，但是不能改变值</li></ol></li></ul><hr><ul><li>指向对象的<strong>常指针</strong> 和 指向<strong>常对象</strong>的指针<ul><li>类名 * const 指针名，不能改变指向</li><li>const 类名 *指针名，不能改变对象的值<ul><li>一个<strong>常对象</strong>只能用<em>常对象指针</em>指向</li><li>常对象指针也可以指向别的值，但是不能改变该对象</li></ul></li><li>常对象只能调用常成员函数</li></ul></li></ul><hr><ul><li>this指针：指向<strong>本类对象</strong>的指针，它的值是当前被调用的成员函数所在的对象的<strong>起始地址</strong><ul><li>名字固定</li><li>区分对象</li></ul></li></ul><hr><ul><li>复制构造函数：Object(const Object &amp; obj)<ul><li>Object obj1 = obj2; //复制构造函数默认被调用</li><li>return obj; //复制构造函数也被调用，生成一个临时对象</li><li>void fun(Object &amp;obj); //此时也调用了复制拷贝函数，生成了一个临时对象</li></ul></li></ul><hr><ul><li>临时对象<ol><li>以值的方式给函数传参</li><li>类型转换</li><li>函数需要返回对象时</li></ol></li></ul><hr><ul><li>左值和右值<ul><li><p>区别在于：能否获取地址</p><blockquote><p>左值：最早的c++中，左值的定义表示的是可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值。但是修饰符const的出现使得可以声明如下的标识符，它可以取得地址，但是没办法对其进行赋值：</p></blockquote><blockquote><p>右值：右值表示无法获取地址的对象，有常量值、函数返回值、Lambda表达式等。无法获取地址，但不表示其不可改变，当定义了右值的右值引用时就可以更改右值。</p></blockquote></li></ul></li></ul><hr><ul><li>静态成员（static）<ul><li>静态数据成员<ul><li>所有对象公用</li><li>可以初始化，但是只能<strong>在类外初始化</strong>，不能用构造函数初始化，如果时private，也要在类外，在对应的cpp和h文件中初始化<blockquote><p>数据类型 类名::静态数据成员 = 初值; //初始化时不用加static</p></blockquote></li></ul></li><li>静态成员函数<ul><li><strong>不能访问非静态成员</strong></li><li>类的一部分，而不是对象的一部分</li></ul></li></ul></li></ul><hr><ul><li>友元函数（friend）<ul><li>可以访问这个类的<strong>private成员</strong></li><li>可以为普通函数或者成员函数<blockquote><p>还有一个友元类，友元类可以访问该类中所有成员</p></blockquote></li><li>破坏封装性和隐蔽性，但是能提高程序效率</li></ul></li></ul><hr><ul><li>类模板（template）<ul><li>template &lt;typename/class T&gt;</li><li>类模板是类的抽象，类是类模板的实例<blockquote><p>类模板 ⬅ 类 ⬅ 对象</p></blockquote></li><li>类模板函数的声明和定义要放在一起，否则会链接错误</li></ul></li></ul><hr><ul><li>转换构造函数：只能有 <strong>一个形参</strong>，将该形参转换为对象的某个数据，自定义如何转换</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径和最小生成树</title>
      <link href="/2019/11/26/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%92%8C%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2019/11/26/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%92%8C%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>学习数据结构的时候一直忘记了区分这两个，现在正是用博客记录一下。</p><h1 id="一-区别"><a class="markdownIt-Anchor" href="#一-区别"></a> 一、区别</h1><ul><li>最小生成树能保证整个拓扑图的 <strong>所有路径权值之和最小</strong> ，但是不能保证 <strong>任意两点间是最短路径</strong></li><li>最短路径是从 <strong>一点</strong> 出发，到达目的地的路径权值和最小</li></ul><h1 id="二-实现算法"><a class="markdownIt-Anchor" href="#二-实现算法"></a> 二、实现算法</h1><h2 id="最短路径"><a class="markdownIt-Anchor" href="#最短路径"></a> 最短路径</h2><h3 id="dijkstra算法"><a class="markdownIt-Anchor" href="#dijkstra算法"></a> Dijkstra算法</h3><ol><li>指定一个节点为初始点，将其看作一个 <strong>集合S</strong> ，剩余的点看作 <strong>另一个集合U</strong></li><li>根据初始点，求出到其他点的距离 <strong>d[i]</strong>（若相邻，则为边的权值；若不相邻，则为 ∞ ）</li><li>选择最小的<strong>d[i]</strong>，并将其<strong>加入集合S</strong>，在<strong>U中去除</strong>它，暂时用x标记</li><li>再根据x，<strong>更新</strong>跟x相邻点y的d[y]的值：<strong>d[y] = min{ d[y], d[x] + w[x][y] }</strong>，则个操作有可能把距离调小，也有可能没变化，因而称为<strong>松弛操作</strong></li><li>重复3，4两步操作，直至<strong>集合S包括所有的点</strong>，即<strong>集合U为空集</strong>时，求得初始点到其他所有点的最短路径</li></ol><ul><li>时间复杂度 <strong>O(e*logv)</strong></li></ul><h2 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树"></a> 最小生成树</h2><h3 id="prim算法"><a class="markdownIt-Anchor" href="#prim算法"></a> Prim算法</h3><ol><li>选择任意节点为起始点，加入<strong>点集合V</strong>，初始化<strong>边集合E为空</strong></li><li>选取<strong>集合V中的点</strong>到<strong>剩余节点</strong>的<strong>最小权值边</strong>，加入E，然后把该边连接的节点加入V</li><li>重复以上步骤，直至<strong>集合V包括所有的节点</strong></li><li>所求的 <strong>{V，E}</strong> 就是最小生成树</li></ol><ul><li>时间复杂度取决于图的存储方式<ul><li>邻接矩阵 <strong>O(v^2)</strong></li><li>邻接表 <strong>O(e*logv)</strong></li></ul></li></ul><h3 id="kruskal算法"><a class="markdownIt-Anchor" href="#kruskal算法"></a> Kruskal算法</h3><ol><li>新建图 <strong>{V,E}</strong>，<strong>V有原来图的所有顶点</strong>，而 <strong>E为空集</strong>，因而每个节点自成一个连通分量</li><li>在原图的边中选择权值最小的边<ol><li>若该边依附的顶点落在新建图中 <strong>不同的连通分量</strong>，则将此边加入E</li><li>否则舍去此边，寻找下一条权值最小的边</li></ol></li><li>以此类推，直至新建图 <strong>所有的节点在同一连通分量</strong></li></ol><ul><li>时间复杂度 <strong>O(eloge)</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串运算</title>
      <link href="/2019/11/10/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%90%E7%AE%97/"/>
      <url>/2019/11/10/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>实现字符串的加，乘法</p><a id="more"></a><p>一. 加法利用双指针，和人工的竖式运算相同<br>二. 乘法有两个版本：</p><ol><li>版本一为竖式运算普通版</li><li>版本二是优化版的竖式运算。<br>该算法是通过两数相乘时，乘数某位与被乘数某位相乘，与产生结果的位置的规律来完成。具体规律如下：<ul><li>乘数 num1 位数为 M，被乘数 num2 位数为 N， num1 x num2 结果 ans 最大总位数为 M+N，最小位数为 M+N-1</li><li>num[i] x num[j] 的结果 temp (为两位数，“0x&quot;或者&quot;xy”),其第一位位于 ans[i+j]，第二位位于 ans[i+j+1]</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span></span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">int</span> i = num1.length()-<span class="number">1</span>, j = num2.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = n1 + n2 + carry;</span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">        sb.append(temp % <span class="number">10</span>);</span><br><span class="line">        i--;j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry==<span class="number">1</span>) sb.append(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>))   <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    String ans = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num2.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = num2.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num2.length()-i-<span class="number">1</span>;j++)<span class="comment">//补零</span></span><br><span class="line">            sb.append(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = num1.length() - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--)&#123;<span class="comment">//计算 n2*num1</span></span><br><span class="line">            <span class="keyword">int</span> n1 = num1.charAt(k) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = n1 * n2 + carry;</span><br><span class="line">            sb.append(temp%<span class="number">10</span>);</span><br><span class="line">            carry = temp/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>) sb.append(carry);</span><br><span class="line">        ans = addStrings(ans, sb.reverse().toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">multiplyPlus</span><span class="params">(String num1, String num2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>))   <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[num1.length() + num2.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = num2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(n1 == <span class="number">0</span> || n2 ==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = n1 * n2 + ans[i+j+<span class="number">1</span>];</span><br><span class="line">            ans[i+j+<span class="number">1</span>] = temp % <span class="number">10</span>;</span><br><span class="line">            ans[i+j] += temp / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">        <span class="comment">//两个数相乘，位数是n+m(全9)或者n+m-1(只有一个1)，因此只有i=0的时候，才有可能抛弃一位0</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ans[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        result.append(ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长的回文子串</title>
      <link href="/2019/11/09/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E6%9C%80%E9%95%BF%E7%9A%84%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2019/11/09/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E6%9C%80%E9%95%BF%E7%9A%84%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串 s，找到 s 中最长的回文子串。</p><a id="more"></a><h1 id="暴力法"><a class="markdownIt-Anchor" href="#暴力法"></a> 暴力法</h1><p>找出所有的子串，判断它是不是回文串</p><ul><li>时间复杂度O(n^3)</li></ul><h1 id="暴力法优化动态规划"><a class="markdownIt-Anchor" href="#暴力法优化动态规划"></a> 暴力法优化(动态规划)</h1><p>首先定义一个二维数组 <em>P(i,j)</em>,<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191110165844.png" class="lazyload"><br>接下来<br>P(i,j) = (P(i+1,j-1) &amp;&amp; S[i]==S[j])<br>因此，我们不需要去判断S[i,j]是不是回文串，而是通过P(i+1,j-1)和S[i]==S[j]判断，这样时间复杂度减少了O(n)，利用动态规划，空间换时间</p><p>求 长度为 1 和长度为 2 的 P(i,j) 时不能用上边的公式，因为我们代入公式后会遇到 P[i][j] 中 i &gt; j 的情况，比如求 P[1][2] 的话，我们需要知道 P[1+1][2-1]=P[2][1]P[1+1][2−1]=P[2][1] ，而 P[2][1]P[2][1] 代表着 S[2,1] 是不是回文串，显然是不对的，所以我们需要单独判断。</p><p>所以我们先初始化长度是 1 的回文串的 P[i,j]，这样利用上边提出的公式 P(i,j)=(P(i+1,j−1)&amp;&amp;S[i]==S[j])，然后两边向外各扩充一个字符，长度为 3 的，为 5 的，所有奇数长度的就都求出来了。<br>同理，先初始化长度为2的回文串，然后所有偶数长度也能求出</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] P = <span class="keyword">new</span> <span class="keyword">boolean</span>[length][length];</span><br><span class="line">    String ans = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> ansLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= length; len++)&#123;<span class="comment">//遍历所有长度的子串，1~length</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; length; start++)&#123;</span><br><span class="line">            <span class="keyword">int</span> end = start + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(end &gt;= length)<span class="comment">//越界</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            P[start][end] = (len==<span class="number">1</span> || len == <span class="number">2</span> || P[start+<span class="number">1</span>][end-<span class="number">1</span>]) &amp;&amp; s.charAt(start) == s.charAt(end);</span><br><span class="line">            <span class="keyword">if</span>(len&gt;ansLen &amp;&amp; P[start][end])&#123;</span><br><span class="line">                ansLen = len;</span><br><span class="line">                ans = s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="中心扩散法"><a class="markdownIt-Anchor" href="#中心扩散法"></a> 中心扩散法</h1><p>事实上，只需使用恒定的空间，我们就可以在O(n^2)的时间内解决这个问题。</p><p>我们观察到回文中心的两侧互为镜像。因此，回文可以从它的中心展开，并且只有 2n−1 个这样的中心。</p><p>你可能会问，为什么会是 2n−1 个，而不是 n 个中心？原因在于所含字母数为偶数的回文的中心可以处于两字母之间的间隙（例如 “abba” 的中心在两个 ‘b’ 之间）。</p><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);<span class="comment">//字符</span></span><br><span class="line">        <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);<span class="comment">//间隙</span></span><br><span class="line">        <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">            start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            end = i + len / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//left == right，则以字符为中心，传出一个奇数</span></span><br><span class="line">    <span class="comment">//反之，以i，j的间隙为中心，传出一个偶数</span></span><br><span class="line">    <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">    <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">        L--;</span><br><span class="line">        R++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里要小心，跳出 while 循环时，已经不满足 s.charAt(L) == s.charAt(R)</span></span><br><span class="line">    <span class="comment">// 因此L，R与实际匹配的位置多了一次自增自减，因此要 R-L-1,不然原本应该为 R-L+1</span></span><br><span class="line">    <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="manacher马拉车-算法"><a class="markdownIt-Anchor" href="#manacher马拉车-算法"></a> Manacher(马拉车) 算法</h1><p>TBD</p>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode LCP</title>
      <link href="/2019/11/06/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/LeeCode-LCP/"/>
      <url>/2019/11/06/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/LeeCode-LCP/</url>
      
        <content type="html"><![CDATA[<p>LeetCode LCP</p><a id="more"></a><h1 id="lcp1"><a class="markdownIt-Anchor" href="#lcp1"></a> LCP1</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>小A和小B在玩猜数字。小B每次从 1, 2, 3 中随机选择一个，小A每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回小A猜对了几次？</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">game</span><span class="params">(<span class="keyword">int</span>[] guess, <span class="keyword">int</span>[] answer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*int count = 0;</span></span><br><span class="line"><span class="comment">    for(int i = 0 ; i &lt; 3; i++)</span></span><br><span class="line"><span class="comment">        if(guess[i] == answer[i]) count++;</span></span><br><span class="line"><span class="comment">    return count;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用循环时间复杂度较高</span></span><br><span class="line">    <span class="keyword">return</span> (guess[<span class="number">0</span>]==answer[<span class="number">0</span>]?<span class="number">1</span>:<span class="number">0</span>)+(guess[<span class="number">1</span>]==answer[<span class="number">1</span>]?<span class="number">1</span>:<span class="number">0</span>)+(guess[<span class="number">2</span>]==answer[<span class="number">2</span>]?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lcp2"><a class="markdownIt-Anchor" href="#lcp2"></a> LCP2</h1><h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2><p>有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191106210354.png" class="lazyload"><br>输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。返回一个长度为2的数组[n, m]，使得连分数的值等于n / m，且n, m最大公约数为1。</p><h2 id="不需要约分"><a class="markdownIt-Anchor" href="#不需要约分"></a> 不需要约分</h2><p>假设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mfrac><mi>n</mi><mi>d</mi></mfrac></mrow><annotation encoding="application/x-tex">a+\frac{n}{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>中的 <strong>n和d已经约分</strong>，<br>通分后：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>a</mi><mo>∗</mo><mi>d</mi><mo>+</mo><mi>n</mi></mrow><mi>d</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{a*d+n}{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight">d</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>如果需要约分，那么 a<em>d+n 和 d 能写成 x</em>c，y*c，c是公约数，且不为1</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∗</mo><mi>c</mi><mo>=</mo><mi>a</mi><mo>∗</mo><mi>d</mi><mo>+</mo><mi>n</mi><mo>=</mo><mi>a</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>y</mi><mo>∗</mo><mi>c</mi><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">x*c = a*d+n = a*(y*c)+n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span></p><p>那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>a</mi><mo>∗</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">n = (x - a*y)*c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> ，又 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>=</mo><mi>y</mi><mo>∗</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">d = y*c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> ，所以 <strong>n与d有非1的公约数</strong>，与假设矛盾，因此：<strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>a</mi><mo>∗</mo><mi>d</mi><mo>+</mo><mi>n</mi></mrow><mi>d</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{a*d+n}{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight">d</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>不需要约分</strong></p><h2 id="规律"><a class="markdownIt-Anchor" href="#规律"></a> 规律</h2><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191106212849.png" class="lazyload"></p><h2 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] fraction(<span class="keyword">int</span>[] cont) &#123;</span><br><span class="line">    <span class="keyword">int</span> up = <span class="number">1</span>, down = cont[cont.length-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cont.length-<span class="number">2</span>; i &gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">        up += down*cont[i];</span><br><span class="line">        temp = up; up = down; down = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;down,up&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lcp3"><a class="markdownIt-Anchor" href="#lcp3"></a> LCP3</h1><h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191107205446.png" class="lazyload"></p><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><ol><li>判断终点是否在路径内，如果没有，就直接 <em>return false</em>，如果没有接着判断</li><li>先删除在目标后面障碍，因为在目标后面无需再遍历，然后遍历障碍数组，判断是否有障碍在路径内，如果有则 <em>return false</em></li><li>以上全不 <em>false</em> 的话，就可返回 <em>true</em></li></ol><ul><li>写一个判断方法 <em>reach</em> 更加方便，但是Java不能方法内写方法，所以传入较多的参数</li><li><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191107205355.png" class="lazyload"></li></ul><p>啦啦啦<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191107205519.png" class="lazyload"></p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">robot</span><span class="params">(String command, <span class="keyword">int</span>[][] obstacles, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] cmd = command.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, u = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//String转化为char[]数组容易遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : cmd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'U'</span>) u++;</span><br><span class="line">        <span class="keyword">else</span> r++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!reach(r, u, x, y, cmd)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逻辑上删除在目标后面的障碍</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obstacles.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (obstacles[i][<span class="number">0</span>] &lt;= x &amp;&amp; obstacles[i][<span class="number">1</span>] &lt;= y) &#123;</span><br><span class="line">            obstacles[index][<span class="number">0</span>] = obstacles[i][<span class="number">0</span>];</span><br><span class="line">            obstacles[index][<span class="number">1</span>] = obstacles[i][<span class="number">1</span>];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断目标前面的障碍是否在路径上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (reach(r, u, obstacles[i][<span class="number">0</span>], obstacles[i][<span class="number">1</span>], cmd)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">reach</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> u, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span>[] cmd)</span></span>&#123;</span><br><span class="line">    <span class="comment">//求出最小的循环次数</span></span><br><span class="line">    <span class="keyword">int</span> i = Math.min(x/r,y/u);</span><br><span class="line">    <span class="keyword">int</span> nx = i*r, ny = i*u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : cmd)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nx == x &amp;&amp; ny == y)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'U'</span>) ny+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>         nx+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lcp4"><a class="markdownIt-Anchor" href="#lcp4"></a> LCP4</h1><h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191110165924.png" class="lazyload"></p><h2 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h2><p>这是求 <strong>二分图的最大匹配</strong> ，用到的是匈牙利算法，CSDN上有个<a href="https://blog.csdn.net/Dark_Scope/article/details/8880547" target="_blank" rel="noopener">趣写算法系列之–匈牙利算法</a>，讲的很形象</p><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[][] board;<span class="comment">//棋盘，false代表坏点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] dir = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;<span class="comment">//上下左右四个顶点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] link;<span class="comment">//link[v2] = v1,表示目前v1，v2相连</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] visit;<span class="comment">//查找顶点是否被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">domino</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span>[][] broken)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (broken.length == <span class="number">0</span> )&#123;<span class="comment">//棋盘无坏点，直接返回 棋盘个数/2</span></span><br><span class="line">        <span class="keyword">return</span> n * m &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    board = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">boolean</span>[] i : board)&#123;<span class="comment">//棋盘全部初始化为true</span></span><br><span class="line">        Arrays.fill(i,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] i : broken)&#123;<span class="comment">//坏点设为false</span></span><br><span class="line">        board[i[<span class="number">0</span>]][i[<span class="number">1</span>]] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hungary();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span></span>&#123;<span class="comment">//匈牙利算法，返回最大匹配数</span></span><br><span class="line">    <span class="keyword">int</span> maxOfMatch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = board.length, m = board[<span class="number">0</span>].length;</span><br><span class="line">    visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[n*m];<span class="comment">//用一维数组存储二维数组</span></span><br><span class="line">    link = <span class="keyword">new</span> <span class="keyword">int</span>[n*m];</span><br><span class="line">    Arrays.fill(link, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; r++) &#123;<span class="comment">//遍历v1中的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = ((r&amp;<span class="number">1</span>) == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>); c &lt; m; c+=<span class="number">2</span>)&#123;<span class="comment">//让遍历的点不相邻</span></span><br><span class="line">            <span class="keyword">if</span> (board[r][c])&#123;</span><br><span class="line">                Arrays.fill(visit,<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (find(r,c))&#123;</span><br><span class="line">                    maxOfMatch++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxOfMatch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.length, m = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] d : dir)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = row + d[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> c = col + d[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= n || c &gt;= m)&#123;<span class="comment">//越界</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v2 = r * m + c;</span><br><span class="line">        <span class="keyword">if</span> (board [r] [c] &amp;&amp; !visit[v2])&#123;</span><br><span class="line">            visit[v2] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (link[v2] == -<span class="number">1</span> || find(link[v2]/m, link[v2]%m))&#123;<span class="comment">//因为link是用一维数组存储二维数组</span></span><br><span class="line">                link[v2] = row * m + col;                       <span class="comment">//因此row = link[v2]/m, col = lin[v2]%m，由左式可知</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数排序和桶排序</title>
      <link href="/2019/11/05/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%92%8C%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/11/05/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%92%8C%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>比快排更快的算法，在理想情况下，甚至可以做到线性时间的复杂度</p><a id="more"></a><p>以前学过的排序都是基于 <strong>元素之间的比较</strong> 来进行排序的，但是有一些特殊的排序并不基于元素比较，<br>如：计数排序，桶排序，基数排序，</p><ul><li>以计数排序来说，这种算法是利用数组下标来确定元素的位置</li><li>基数排序是将多位数分成个位数进行计数排序</li><li>桶排序是每一个桶代表一个区间范围</li></ul><h1 id="计数排序"><a class="markdownIt-Anchor" href="#计数排序"></a> 计数排序</h1><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><ol><li>创建一个统计数组，数组长度为 <strong>数列的最大值 - 数列的最小值 + 1</strong>，</li><li>同时数列的最小值作为一个偏移量，用于计算整数在统计数组的下标</li><li>遍历无序数列，将元素填入统计数组 <strong>元素值 - 偏移量</strong> 的位置</li><li>对统计数组进行变形，每一个元素都加上前面所有元素之和。<blockquote><p>为什么相加呢？是让统计数组储存的元素值，等于相应整数的最终排序位置的序号。<br>例如：下标为9的元素值为5，那么代表原始数列的整数9，最终排序在第5位</p></blockquote></li><li>倒序遍历数组，从统计数组找到正确的位置，输出到结果数组<blockquote><p>为什么倒序？为了不改变原有顺序，使之稳定</p></blockquote></li></ol><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">     <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">int</span> min = array[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">         <span class="keyword">if</span> (array[i] &gt; max) max = array[i];</span><br><span class="line">         <span class="keyword">if</span> (array[i] &lt; min) min = array[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> d = max -min;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//填写统计数组</span></span><br><span class="line">     <span class="keyword">int</span>[] countArray = <span class="keyword">new</span> <span class="keyword">int</span> [d+<span class="number">1</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">         countArray[array[i] - min]++;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//统计数组变形</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; countArray.length; i++)</span><br><span class="line">         countArray[i] += countArray[i-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">     <span class="comment">//倒序遍历原始数组</span></span><br><span class="line">     <span class="keyword">int</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span>  i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">         sortedArray[countArray[array [i] - min] - <span class="number">1</span>] = array[i];</span><br><span class="line">         countArray[array [i] - min]--;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> sortedArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h2><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><ul><li>时间复杂度仅为O(n+m)</li><li>空间复杂度为O(m)</li></ul><h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3><ol><li>当数列最大和最小值差距过大时，空间浪费，时间复杂度增加</li><li>必须为整数</li></ol><h1 id="桶排序"><a class="markdownIt-Anchor" href="#桶排序"></a> 桶排序</h1><p>桶排序同样是一种线性时间的排序算法。类似于计数排序所创建的统计数组，桶排序需要创建若干个桶来协助排序。</p><ul><li>每一个桶(bucket)代表一个区间范围，里面可以承载一个或多个元素</li></ul><h2 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h2><ol><li>创建若干个桶，并确定每一个桶的区间范围<blockquote><p>创建几个桶，确定区间范围，有很多种不同的方式。我们这里创建的桶数量等于原始数列的元素数量，<em>除了最后一个桶只包含数列最大值外，前面各个桶的区间按照比例来确定</em></p></blockquote></li><li>遍历原始数列，把元素对号入座放入各个桶中</li><li>对每个桶内部的元素分别进行排序</li><li>遍历所有的桶，输出所有元素</li></ol><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] bucketSort(<span class="keyword">double</span>[] array)&#123;</span><br><span class="line">     <span class="keyword">double</span> max = array[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">double</span> min = array[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">         <span class="keyword">if</span> (array[i] &gt; max) max = array[i];</span><br><span class="line">         <span class="keyword">if</span> (array[i] &lt; min) min = array[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">double</span> d = max - min;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> bucketNum = <span class="number">9</span>;</span><br><span class="line">     ArrayList&lt;LinkedList &lt;Double&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;LinkedList &lt;Double&gt;&gt;(bucketNum);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++)</span><br><span class="line">         bucketList.add(<span class="keyword">new</span> LinkedList&lt;Double&gt; ());</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">         <span class="keyword">int</span> num = (<span class="keyword">int</span>)((array[i] - min)*(bucketNum-<span class="number">1</span>)/d);</span><br><span class="line">         bucketList.get(num).add(array[i]);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketList.size(); i++)</span><br><span class="line">         <span class="comment">//JDK底层采用了归并排序或归并的优化版本</span></span><br><span class="line">         Collections.sort(bucketList.get(i));</span><br><span class="line"></span><br><span class="line">     <span class="keyword">double</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">double</span>[array.length];</span><br><span class="line">     <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//增强版的for只能遍历，不能修改值</span></span><br><span class="line">     <span class="keyword">for</span>(LinkedList&lt;Double&gt; list : bucketList) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">double</span> element : list) &#123;</span><br><span class="line">             sortedArray[index++] = element;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> sortedArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优缺点-2"><a class="markdownIt-Anchor" href="#优缺点-2"></a> 优缺点</h2><h3 id="优点-2"><a class="markdownIt-Anchor" href="#优点-2"></a> 优点</h3><ul><li>时间复杂度仅为O(n)</li><li>空间复杂度为O(m)</li></ul><h3 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h3><p>不稳定，第一个桶有n-1个元素，最后一个桶只有一个，此时时间复杂度退化为O(nlogn)，而且白白的创建了许多空桶</p>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2019/11/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/11/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>堆排序是利用二叉堆的特性完成的排序。</p><a id="more"></a><h1 id="二叉堆的特性"><a class="markdownIt-Anchor" href="#二叉堆的特性"></a> 二叉堆的特性</h1><ol><li>最大堆的堆顶是整个堆中最大的元素</li><li>最小堆的堆顶是整个堆中最小的元素</li></ol><ul><li>以最大堆为例，如果删除一个最大堆的堆顶(并不是完全删除，而是跟末尾节点交换位置，然后退出堆)，经过自我调整，第二大的元素就会成为堆顶元素，往复 n-1次即可完成排序</li></ul><h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1><ol><li>把无序数组构建成二叉堆。需要从小到大排序，则构成最大堆；反之，构成最小堆。</li><li>循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶</li></ol><h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下沉调整堆</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parentIndex, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">int</span> childIndex = <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(childIndex &lt; length)&#123;</span><br><span class="line">    <span class="comment">//如果有右孩子，且右孩子的值大于左孩子，则定位到右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(childIndex+<span class="number">1</span> &lt; length &amp;&amp; array[childIndex+<span class="number">1</span>] &gt; array[childIndex])</span><br><span class="line">            childIndex++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果父节点小于任何一个孩子的值，则直接跳出</span></span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= array[childIndex])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">        array[parentIndex] = array[childIndex];</span><br><span class="line">        parentIndex = childIndex;</span><br><span class="line">        childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array[parentIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序(升序)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.将无序数组建成最大堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = array.length/<span class="number">2</span>; i &gt;=<span class="number">0</span>; i--)</span><br><span class="line">        downAdjust(array,i,array.length-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = array.length-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于第一次的调整建成了最大堆，所以堆顶的左右孩子只比最大的元素小，</span></span><br><span class="line">        <span class="comment">//因而只需将堆顶的元素下沉即可重新得到最大堆，参照堆的删除节点操作</span></span><br><span class="line">        downAdjust(array, <span class="number">0</span> ,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h1><p>下沉调整的空间复杂度为O(logn)，需要调整n次，因此时间复杂度为O(nlogn)</p><ul><li>构建堆的时间复杂度为O(n)，而不是(nlogn)</li><li>堆的插入和删除的时间复杂度都是O(logn)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2019/11/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/11/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。</p><a id="more"></a><h1 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h1><p>动态规划与分治法类似，其基本思想也是 <strong>将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</strong>。<br>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。<br>如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，即 <strong>重复利用子问题的答案</strong> 这样就可以避免大量的重复计算，节省时间，这就是动态规划的优势。</p><h1 id="设计步骤"><a class="markdownIt-Anchor" href="#设计步骤"></a> 设计步骤</h1><h2 id="基本步骤"><a class="markdownIt-Anchor" href="#基本步骤"></a> 基本步骤</h2><ol><li><p>划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p></li><li><p>确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足 <em>无后效性</em> 。</p></li><li><p>确定决策并写出 <em><strong>状态转移方程</strong></em>：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p></li><li><p>寻找边界条件：给出的状态转移方程是一个 <em>递推式</em>，需要一个递推的 <em>终止条件或边界条件</em> 。</p></li></ol><h2 id="简化"><a class="markdownIt-Anchor" href="#简化"></a> 简化</h2><p>一般，只要 <strong>解决问题的阶段、状态</strong> 和 <strong>状态转移决策</strong> 确定了，就可以写出 <strong>状态转移方程（包括边界条件）</strong>。实际应用中可以按以下几个简化的步骤进行设计：</p><ol><li>分析最优解的性质，并刻画其结构特征。</li><li>递归的定义最优解。</li><li>以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</li><li>根据计算最优值时得到的信息，构造问题的最优解。</li></ol><h1 id="适用条件"><a class="markdownIt-Anchor" href="#适用条件"></a> 适用条件</h1><ol><li><p><strong>最优化原理</strong>（最优子结构性质）：最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。</p></li><li><p><strong>无后效性</strong>：将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。</p></li><li><p><strong>子问题的重叠性</strong>：动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于 <strong>解决冗余</strong> ，这是动态规划算法的根本目的。动态规划实质上是一种以 <strong>空间换时间</strong> 的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。</p></li></ol><h1 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h1><p>动态规划一般可分为 <strong>线性动规</strong>，<strong>区域动规</strong>，<strong>树形动规</strong>，<strong>背包动规</strong>四类。<br>举例：</p><ul><li>线性动规：拦截导弹，合唱队形，挖地雷，建学校，剑客决斗等；</li><li>区域动规：石子合并， 加分二叉树，统计单词个数，炮兵布阵等；</li><li>树形动规：贪吃的九头龙，二分查找树，聚会的欢乐，数字三角形等；</li><li>背包问题：01背包问题，完全背包问题，分组背包问题，二维背包，装箱问题，挤牛奶（同济ACM第1132题）等；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位为1的个数</title>
      <link href="/2019/11/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E4%BD%8D%E4%B8%BA1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2019/11/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E4%BD%8D%E4%B8%BA1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><a id="more"></a><h1 id="循环和位移动"><a class="markdownIt-Anchor" href="#循环和位移动"></a> 循环和位移动</h1><p>这个方法比较直接。我们遍历数字的 32 位。如果最后一位是 1 ，将计数器加一，然后数字右移。<br>任何数字和 <strong>掩码1</strong> 进行按位与运算，可以让我们获得最后一位数字，检查下一位时，掩码左移或者参数右移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">            bits++;</span><br><span class="line">        &#125;</span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="位移动的小技巧"><a class="markdownIt-Anchor" href="#位移动的小技巧"></a> 位移动的小技巧</h1><p>我们可以把前面的算法进行优化。我们不再检查数字的每一个位，而是不断把数字最后一个 1 反转，并把答案加一。当数字变成 0 的时候，我们就知道它没有 1 的位了，此时返回答案。<br>这里关键的想法是对于任意数字n，将 <em>n</em> 和 <em>n-1</em> 做与运算，会把最后一个 1 的位变成 0 。为什么？考虑 n 和 n−1 的二进制表示。<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191101174947.png" class="lazyload"><br>在二进制表示中，数字 n 中最低位的 1 总是对应 n−1 中的 0 。因此，将 n 和 n−1 与运算总是能把 n 中最低位的 1 变成 0 ，并保持其他位不变。</p><ul><li>之前学到，可以利用这个判断一个数是不是2的整次幂，如果是2的整次幂，则 <strong>最低位为1</strong> 的就是 <strong>最高位</strong> ，因此 <strong>n&amp;n-1</strong>就会得到0</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 数 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fizz Buzz</title>
      <link href="/2019/11/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/Fizz%20Buzz/"/>
      <url>/2019/11/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/Fizz%20Buzz/</url>
      
        <content type="html"><![CDATA[<p>写一个程序，输出从 1 到 n 数字的字符串表示。</p><ol><li>如果 n 是3的倍数，输出“Fizz”；</li><li>如果 n 是5的倍数，输出“Buzz”；</li><li>如果 n 同时是3和5的倍数，输出 “FizzBuzz”。</li></ol><a id="more"></a><h1 id="暴力法"><a class="markdownIt-Anchor" href="#暴力法"></a> 暴力法</h1><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><ol><li>初始化一个空的答案列表。</li><li>遍历 1 … N1…N。</li><li>对于每个数，判断它能不能同时被 3 和 5 整除，如果可以就把 FizzBuzz 加入答案列表。</li><li>如果不行，判断它能不能被 3 整除，如果可以，把 Fizz 加入答案列表。</li><li>如果还是不行，判断它能不能被 5 整除，如果可以，把 Buzz 加入答案列表。</li><li>如果以上都不行，把这个数加入答案列表。</li></ol><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= n; num++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> divisibleBy3 = (num % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">boolean</span> divisibleBy5 = (num % <span class="number">5</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (divisibleBy3 &amp;&amp; divisibleBy5)</span><br><span class="line">        ans.add(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (divisibleBy3)</span><br><span class="line">        ans.add(<span class="string">"Fizz"</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (divisibleBy5)</span><br><span class="line">        ans.add(<span class="string">"Buzz"</span>);</span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">        ans.add(num + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="字符串连接"><a class="markdownIt-Anchor" href="#字符串连接"></a> 字符串连接</h1><p>这个方法不会降低渐进复杂度，但是当 FizzBuzz 的规则变得更复杂的时候，这将会是个更优雅的解法。比方说，玩个 FizzBuzzJazz 的游戏。</p><h2 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h2><p>我们放弃使用之前的联合判断，取而代之依次判断是否能被给定的数整数。这道题中，就是依次判断能不能被 3 整除，能不能被 5 整除。如果能被 3 整除，就把对应的 Fizz 连接到答案字符串，如果能被 5 整除，就把 Buzz 连接到答案字符串。</p><h2 id="实现-2"><a class="markdownIt-Anchor" href="#实现-2"></a> 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= n; num++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> divisibleBy3 = (num % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">boolean</span> divisibleBy5 = (num % <span class="number">5</span> == <span class="number">0</span>);</span><br><span class="line">        String s = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(divisibleBy3) s += <span class="string">"Fizz"</span>;</span><br><span class="line">        <span class="keyword">if</span>(divisibleBy5) s += <span class="string">"Buzz"</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">""</span>) s += num;</span><br><span class="line"></span><br><span class="line">        ans.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="散列表"><a class="markdownIt-Anchor" href="#散列表"></a> 散列表</h1><p>这个方法是对方法二的优化。当数字和答案的映射是定好的，那么方法二用起来也还可以。但是如果你遇到一个变态的面试官，他跟你说他需要更自由的映射关系呢？<br>每个映射一个判断显然是不可行的，这样写出来的代码一定是丑陋不堪且难以维护的。<br>如果老板有这样一个需求，明天你把映射关系换掉或者删除一个映射关系吧。对于这种要求，我们只能一个个去修改判断条件的代码。</p><h2 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h2><p>但我们实际上有个更优雅的做法，那就是把映射关系放在 <em>散列表</em> 里面。</p><ol><li>把所有的映射关系放在散列表 fizzBuzzHash 中，这个散列表形如 { 3: ‘Fizz’, 5: ‘Buzz’ }。</li><li>遍历 1 … N。</li><li>对于每个数字，遍历 fizzBuzzHash 中的键，检查是否能被它整除。</li><li>如果这个数能被键整除，就把当前键映射的值加到到答案字符串后面去。对于散列表的每个键值对，都这样操作。</li><li>最后将答案字符串加入答案列表。</li></ol><ul><li>通过这样的方式你可以对散列表 <em>添加/删除</em> 映射关系，同时还不需要修改太多代码。</li></ul><h2 id="实现-3"><a class="markdownIt-Anchor" href="#实现-3"></a> 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ans list</span></span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hash map to store all fizzbuzz mappings.</span></span><br><span class="line">    HashMap&lt;Integer, String&gt; fizzBizzDict =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;Integer, String&gt;() &#123;</span><br><span class="line">          &#123;</span><br><span class="line">            put(<span class="number">3</span>, <span class="string">"Fizz"</span>);</span><br><span class="line">            put(<span class="number">5</span>, <span class="string">"Buzz"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= n; num++) &#123;</span><br><span class="line"></span><br><span class="line">      String numAnsStr = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Integer key : fizzBizzDict.keySet()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the num is divisible by key,</span></span><br><span class="line">        <span class="comment">// then add the corresponding string mapping to current numAnsStr</span></span><br><span class="line">        <span class="keyword">if</span> (num % key == <span class="number">0</span>) &#123;</span><br><span class="line">          numAnsStr += fizzBizzDict.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (numAnsStr.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="comment">// Not divisible by 3 or 5, add the number</span></span><br><span class="line">        numAnsStr += Integer.toString(num);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Append the current answer str to the ans list</span></span><br><span class="line">      ans.add(numAnsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2019/10/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/10/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>生活中的排序无处不在，因此在算法中也无处不在，排序看似简单，但是有着各种各样的算法和思想。</p><a id="more"></a><h1 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h1><h2 id="根据时间复杂度的不同主流的排序算法可以分为3大类"><a class="markdownIt-Anchor" href="#根据时间复杂度的不同主流的排序算法可以分为3大类"></a> 根据时间复杂度的不同，主流的排序算法可以分为3大类。</h2><ol><li>时间复杂度为 <em>O(n^2)</em></li></ol><ul><li>冒泡算法</li><li>选择排序</li><li>插入排序</li><li>希尔排序(希尔排序比较特殊，它的性能略优于O(n^2)，但又比不上O(nlogn))</li></ul><ol start="2"><li>时间复杂度为 <em>O(nlogn)</em></li></ol><ul><li>快速排序</li><li>归并排序</li><li>堆排序</li></ul><ol start="3"><li>时间复杂度为线性</li></ol><ul><li>计数排序</li><li>桶排序</li><li>基数排序</li></ul><h2 id="此外排序算法还划分为-稳定排序-和-不稳定排序"><a class="markdownIt-Anchor" href="#此外排序算法还划分为-稳定排序-和-不稳定排序"></a> 此外，排序算法还划分为 <strong>稳定排序</strong> 和 <strong>不稳定排序</strong></h2><p>如何划分稳定和不稳定：如果值相同的元素在排序后仍然保持排序前的顺序，排序算法就是稳定的</p><h1 id="总表"><a class="markdownIt-Anchor" href="#总表"></a> 总表</h1><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191103155227.png" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2019/10/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/10/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>同冒泡排序，快速排序也是交换排序</p><a id="more"></a><h1 id="思想"><a class="markdownIt-Anchor" href="#思想"></a> 思想</h1><p>每一轮挑选一个基准元素，并让其他比它大的元素移动到数列的一边，比它小的移动到另一边，从而把数列拆成两个部分，一个部分的数全部比基准元素打，另一个部分全部比它小。</p><ul><li>这种思想叫做 <strong>分治法</strong></li><li>原数列在每一轮都被拆成两部分，两部分中的每一部分又被拆成两部分，一直递归下去，直至不可再分，因此要遍历 <strong>logn</strong> 轮，而且每一轮的交换和比较要遍历数组，因此时间复杂度为 <strong>O(nlogn)</strong></li></ul><h1 id="基准元素的选择"><a class="markdownIt-Anchor" href="#基准元素的选择"></a> 基准元素的选择</h1><p>最简单的方式是选第一个元素，但是在数列基本有序，或者逆序的情况下，数列没有理想的被分为均匀的两半，<em>每一轮只确定基准元素的位置</em>，时间复杂度退化为O(n^2)</p><ul><li>解决方法：<strong>随机选择一个元素作为基准元素</strong>，并让基准元素和数列首位元素交换位置</li></ul><h1 id="元素的交换"><a class="markdownIt-Anchor" href="#元素的交换"></a> 元素的交换</h1><p>选定了基准元素以后，我们要做的就是把其他元素中小于基准元素都交换到基准元素的一边，大于它的交换到另一边。</p><h2 id="实现方法"><a class="markdownIt-Anchor" href="#实现方法"></a> 实现方法</h2><h3 id="双边循环法"><a class="markdownIt-Anchor" href="#双边循环法"></a> 双边循环法</h3><p>也就是数据结构中学的方法，为双指针法。</p><ul><li>首先选定基准元素pivot，并设置两个指针left，right，分别指向数组的最左边和最右边</li><li>进行循环，从right指针开始，让指针所指向的元素和基准元素做比较。<ol><li>如果大于或等于pivot，则right指针右移</li><li>如果小于pivot，则right指针停止移动，right和left指向的值互换，切换到left指针</li><li>让left指针指向的元素和基准元素作比较，如果小于等于pivot，则左移，反之停止移动，right和left指向的值互换，切换到right指针</li></ol></li><li>一直循环下去，直到 <strong>right == left</strong></li><li>最后把pivot的与两指针汇合处的元素与pivot互换，即完成第一次分治</li></ul><h4 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归结束条件，startIndex大于等于endIndex时</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex &gt;= endIndex) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span><br><span class="line">    <span class="comment">//根据基准元素，分成两部分进行递归快速排序</span></span><br><span class="line">    quickSort(arr, startIndex, pivotIndex-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex, endIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">//取第一个位置的元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> left = startIndex;</span><br><span class="line">    <span class="keyword">int</span> right = endIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left != right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt; pivot)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &lt;= pivot)</span><br><span class="line">            left++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换left和right指针所指向的元素</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = arr[left];</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            arr[right] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pivot和指针重合点交换</span></span><br><span class="line">    arr[startIndex] = arr[left];</span><br><span class="line">    arr[left] = pivot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单边循环法"><a class="markdownIt-Anchor" href="#单边循环法"></a> 单边循环法</h3><p>双边循环从数组的两边交替遍历元素，虽然更加直观，但是代码量较多。单边循环法只从数组的一边对元素进行遍历和交换。</p><ul><li>选定基准元素pivot，设置一个mark指针指向数列起始位置，这个mark指针代表 <strong>小于基准元素的区域边界</strong></li><li>接下来，从基准元素的下一个位置开始遍历数组<ol><li>如果遍历到的元素大于基准元素，就继续往后遍历</li><li>如果小于基准元素，需要做两件事：<br>第一，把mark指针右移一位，因为小于pivot的区域边界增加了1；<br>第二，让最新遍历到的元素和mark指针所在位置的元素互换，因为最新遍历的元素归属与小于pivot的区域</li></ol></li><li>按照这个思路，继续遍历，直至末位，最后把pivot元素交换到mark指针所在的位置，第一次分治结束</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归结束条件，startIndex大于等于endIndex时</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex &gt;= endIndex) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partitionV2(arr, startIndex, endIndex);</span><br><span class="line">    <span class="comment">//根据基准元素，分成两部分进行递归快速排序</span></span><br><span class="line">    quickSort(arr, startIndex, pivotIndex-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex+<span class="number">1</span>, endIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partitionV2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> mark = startIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex+<span class="number">1</span>; i &lt;= endIndex; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; pivot)&#123;</span><br><span class="line">            mark++;</span><br><span class="line">            <span class="keyword">int</span> p = arr[mark];</span><br><span class="line">            arr[mark] = arr[i];</span><br><span class="line">            arr[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[startIndex] = arr[mark];</span><br><span class="line">    arr[mark] = pivot;</span><br><span class="line">    <span class="keyword">return</span> mark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡算法</title>
      <link href="/2019/10/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/10/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>冒泡排序(bubble sort)是很经典的 <strong>交换排序</strong> 算法，为什么叫做冒泡，就是因为这个算法的每一个元素都像小气泡一样，根据自身大小，往数组的一侧移动。</p><a id="more"></a><h1 id="思想"><a class="markdownIt-Anchor" href="#思想"></a> 思想</h1><p>把相邻的元素两两比较，当一个元素大于右侧元素时，两个元素交换，如果没有，位置不变</p><ul><li>每一遍历完一轮，总有一个最大的元素移到最右侧</li><li>冒泡算法是一个稳定的算法</li><li>每一轮都要遍历所有没排序的元素，总共遍历 <em>n-1</em> 轮，因此时间复杂度为O(n^2)</li></ul><h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//有序标志，每一轮初值为true</span></span><br><span class="line">        <span class="comment">//如果是执行一轮过后还是true，就是没有进行交换，则数组以有序，循环结束</span></span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                isSorted = <span class="keyword">false</span>;<span class="comment">//发生了交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isSorted) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双向冒泡鸡尾酒排序"><a class="markdownIt-Anchor" href="#双向冒泡鸡尾酒排序"></a> 双向冒泡：鸡尾酒排序</h1><p>冒泡排序的每一个元素都是向右移动的，是单向的，鸡尾酒排序是 <strong>双向 的</strong>，奇数找最大的，偶数找最小的，但是代码量增加了一倍，在大部分元素有序的情况下，鸡尾酒排序更有优势</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doubleBubbleSort</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length/<span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//奇数轮</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; array.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                isSorted = <span class="keyword">false</span>;<span class="comment">//发生了交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSorted) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//偶数轮，重新标记</span></span><br><span class="line">        isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = array.length-i-<span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &lt;&gt; array[j-<span class="number">1</span>])&#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j-<span class="number">1</span>];</span><br><span class="line">                array[j-<span class="number">1</span>] = tmp;</span><br><span class="line">                isSorted = <span class="keyword">false</span>;<span class="comment">//发生了交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSorted) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断一个数是不是2的整次幂</title>
      <link href="/2019/10/29/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%98%AF%E4%B8%8D%E6%98%AF2%E7%9A%84%E6%95%B4%E6%AC%A1%E5%B9%82/"/>
      <url>/2019/10/29/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%98%AF%E4%B8%8D%E6%98%AF2%E7%9A%84%E6%95%B4%E6%AC%A1%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<ul><li>如果一个整数是2的整次幂，那么当它转化为二进制时，只有最高位时1，其他都是0</li><li>把这个整数减1后，二进制数全变成了1，原本最高位变为0</li><li>因此，只需要 <em>原数值</em> 和 <em>它减1的结果</em> 进行按位与运算，也就是 <strong>n&amp;(n-1)</strong> 是否为0，就可以判断它是不是2的整次幂</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">boolean</span> <span class="title">isPowerOf2</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (num &amp; num-<span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大公约数</title>
      <link href="/2019/10/28/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
      <url>/2019/10/28/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>求一个数的最大公约数，getGreatestCommonDivisor简称gcd</p><a id="more"></a><h1 id="辗转相除法"><a class="markdownIt-Anchor" href="#辗转相除法"></a> 辗转相除法</h1><p>又名 <em>欧几里得算法</em></p><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><p>两个正整数a，b（a&gt;b），它们的最大公约数等于 <em>a/b的余数</em> 和 <em>b</em> 之间的最大公约数</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> big = a&gt;b? a:b;</span><br><span class="line">    <span class="keyword">int</span> small = a&lt;b? a:b;</span><br><span class="line">    <span class="keyword">if</span>(big%small == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> gcd(big%small, small);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2><p>两个整数较大时，模运算性能较差</p><h1 id="更相减损术"><a class="markdownIt-Anchor" href="#更相减损术"></a> 更相减损术</h1><h2 id="原理-2"><a class="markdownIt-Anchor" href="#原理-2"></a> 原理</h2><p>两个正整数a，b（a&gt;b），它们的最大公约数等于 <em>a-b的差值</em> 和 <em>较小数b</em>的最大公约数</p><h2 id="实现-2"><a class="markdownIt-Anchor" href="#实现-2"></a> 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> big = a&gt;b? a:b;</span><br><span class="line">    <span class="keyword">int</span> small = a&lt;b? a:b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gcd(big-small, small);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h2><p>不稳定，当两个数悬殊巨大时，要计算多次，例如：100001和1</p><h1 id="移位运算法"><a class="markdownIt-Anchor" href="#移位运算法"></a> 移位运算法</h1><p>这个算法结合了 <em>辗转相除法</em> 和 *更相减损术 的优势，在更相减损术的基础上使用移位运算，整个算法只用到 <em>移位运算</em> 和 <em>减法</em></p><ul><li>这个算法在两个数比较小时看不出优势，但是当数比较大的时候，计算速度明显提高</li></ul><h2 id="原理-3"><a class="markdownIt-Anchor" href="#原理-3"></a> 原理</h2><p>两个正整数a，b（a&gt;b）</p><ol><li>gcd(a,a)=a，也就是一个数和其自身的公约数仍是其自身。</li><li>gcd(ka,kb)=k gcd(a,b)，也就是最大公约数运算和倍乘运算可以交换。特殊地，当k=2时，说明两个偶数的最大公约数必然能被2整除。</li><li>当k与b互为质数，gcd(ka,b)=gcd(a,b)，也就是约掉两个数中只有其中一个含有的因子不影响最大公约数。特殊地，当k=2时，说明计算一个偶数和一个奇数的最大公约数时，可以先将偶数除以2。</li></ol><h2 id="实现-3"><a class="markdownIt-Anchor" href="#实现-3"></a> 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcdPlus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//采用与1进行与的位运算判断奇偶数，速度更快</span></span><br><span class="line">    <span class="keyword">if</span>((a&amp;<span class="number">1</span>)==<span class="number">0</span> &amp;&amp; (b&amp;<span class="number">1</span>) ==<span class="number">0</span>)<span class="comment">//a，b均为偶数</span></span><br><span class="line">        <span class="keyword">return</span> gcdPlus(a&gt;&gt;<span class="number">1</span>, b&gt;&gt;<span class="number">1</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((a&amp;<span class="number">1</span>)==<span class="number">0</span> &amp;&amp; (b&amp;<span class="number">1</span>) !=<span class="number">0</span>)<span class="comment">//a为偶数，b为奇数</span></span><br><span class="line">        <span class="keyword">return</span> gcdPlus(a&gt;&gt;<span class="number">1</span>, b);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((a&amp;<span class="number">1</span>)==<span class="number">0</span> &amp;&amp; (b&amp;<span class="number">1</span>) !=<span class="number">0</span>)<span class="comment">//a为奇数，b为偶数</span></span><br><span class="line">        <span class="keyword">return</span> gcdPlus(a, b&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> big = a&gt;b? a:b;</span><br><span class="line">        <span class="keyword">int</span> small = a&lt;b? a:b;</span><br><span class="line">        <span class="keyword">return</span> gcdPlus(big-small, small);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h1><ol><li>暴力法：O(min(a, b))</li><li>辗转相除法：近似为O(log(max(a, b)))，但是模运算性能较差</li><li>更相减损术：算法不稳定，最坏为O(max(a, b))</li><li>移位运算法：不但避免模运算，而且稳定，复杂度为O(log(max(a, b)))</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小栈的实现</title>
      <link href="/2019/10/28/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%9C%80%E5%B0%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/10/28/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%9C%80%E5%B0%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>实现一个栈，该栈带有出栈（pop），进栈（push），取最小元素（getMin）3个方法，保证时间复杂度为O(1).</p><a id="more"></a><p>如果只声明一个变量储存最小值是不够的，因为如果最小值出栈的话，怎么更新？<br>因而，我们需要储存栈中 <strong>曾经的最小值</strong>，作为“备胎”</p><h1 id="解法步骤"><a class="markdownIt-Anchor" href="#解法步骤"></a> 解法步骤</h1><ol><li>设原有栈为A，此时创建个额外的“备胎”栈B，用于辅助栈A。</li><li>当第一个元素进入栈A时，让新元素也进入栈B。因为这个唯一的元素时栈A目前最小值。</li><li>之后，每当新元素入栈A时，比较 <em>新元素</em> 和 <em>栈A目前最小值</em> 的大小，如果小于 <em>栈A目前的最小值</em>，则让新元素也入栈B，此时 <em>栈B的栈顶元素</em> 是 <em>栈A当前最小值</em>。</li><li>每当有栈A的元素出栈，如果 <em>出栈元素</em> 和 <em>栈B栈顶元素</em> 相同时，栈B栈顶元素也出栈，则接下去栈B栈顶元素变为栈A目前最小值，“备胎转正”。</li><li>当调用getMin()时，返回 <em>栈B的栈顶元素</em> ，这就是栈A目前最小值。</li></ol><ul><li>时间复杂度均是O(1)，最坏情况的空间复杂度为O(n)</li></ul><h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; mainStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> element)</span></span>&#123;</span><br><span class="line">    mainStack.push(element);</span><br><span class="line">    <span class="keyword">if</span>(mainStack.empty() || element &lt;= mainStack.peek())</span><br><span class="line">        mainStack.push(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mainStack.peek().equals(minStack.peek()))</span><br><span class="line">        minStack.pop();</span><br><span class="line">    <span class="keyword">return</span> mainStack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mainStack.empty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"stack is empty"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> minStack.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模式匹配</title>
      <link href="/2019/10/27/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/10/27/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p><a id="more"></a><p>这个是个模式匹配问题，我刚开始没有意识到到，用暴力法匹配所有的子串，解决了问题，虽然在短字符串的匹配中速度比kmp快，但是长字符串的效率很低。<br>看了解答后，才意识到这是我数据结构中学到的 <strong>KMP算法</strong>。</p><h1 id="核心next数组"><a class="markdownIt-Anchor" href="#核心next数组"></a> 核心NEXT数组</h1><p>next数组是求 <strong>前缀，后缀最长的公共子串长度</strong></p><ul><li>求next函数值的问题可以看成另一个模式匹配问题：<strong>整个模式串既是子串又是模式串</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] get_next(String needle)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[needle.length()];</span><br><span class="line">    <span class="comment">//i是后缀，j是前缀，前缀固定，后缀是相对的</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; needle.length()-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || needle.charAt(i) == needle.charAt(j))&#123;</span><br><span class="line">            i++; j++;</span><br><span class="line">            <span class="comment">//next数组优化，当字符失配时，回到相同字符无意义，应继续递归</span></span><br><span class="line">            <span class="keyword">if</span>(needle.charAt(i) != needle.charAt(j)) next[i] = j;</span><br><span class="line">            <span class="keyword">else</span> next[i] = next[j];</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            j = next[j];<span class="comment">//j回溯</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br></pre></td></tr></table></figure><h1 id="strstr的实现"><a class="markdownIt-Anchor" href="#strstr的实现"></a> strStr的实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] next = get_next(needle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; haystack.length() &amp;&amp; j &lt; needle.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || haystack.charAt(i) == needle.charAt(j)) &#123;i++; j++;&#125;</span><br><span class="line">        <span class="keyword">else</span> j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == needle.length()) <span class="keyword">return</span> i-j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
            <tag> KMP算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快乐数</title>
      <link href="/2019/10/27/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
      <url>/2019/10/27/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>编写一个算法来判断一个数是不是“快乐数”。</p><a id="more"></a><p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p><ul><li>例如:19</li></ul><blockquote><p>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 0^2 = 1</p></blockquote><h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1><p>使用“快慢指针”思想找出循环：“快指针”每次走两步，“慢指针”每次走一步，当二者相等时，即为一个循环周期。此时，判断是不是因为1引起的循环，是的话就是快乐数，否则不是快乐数。</p><ul><li>注意：此题不建议用集合记录每次的计算结果来判断是否进入循环，因为这个集合可能大到无法存储；另外，也不建议使用递归，同理，如果递归层次较深，会直接导致调用栈崩溃。不要因为这个题目给出的整数是int型而投机取巧。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = n, p2 = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        p1 = bitSquareSum(p1);</span><br><span class="line">        p2 = bitSquareSum(bitSquareSum(p2));</span><br><span class="line">    &#125;<span class="keyword">while</span>(p1 != p2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果循环点是1，则它是快乐数</span></span><br><span class="line">    <span class="comment">//也有可能循环点不是1</span></span><br><span class="line">    <span class="keyword">return</span> p1 == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bitSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span> ,bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">        bit = n%<span class="number">10</span>;</span><br><span class="line">        sum += bit*bit;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断链表有环</title>
      <link href="/2019/10/27/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF/"/>
      <url>/2019/10/27/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p>有一个单向链表，如何判断链表是否为有环链表？</p><a id="more"></a><h1 id="hashset法"><a class="markdownIt-Anchor" href="#hashset法"></a> HashSet法</h1><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><ul><li>创建一个以节点ID为Key的HashSet集合</li><li>遍历链表并加入HashSet，判断是否重复，重复则有环</li></ul><h2 id="复杂度"><a class="markdownIt-Anchor" href="#复杂度"></a> 复杂度</h2><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul><h1 id="双指针追及法"><a class="markdownIt-Anchor" href="#双指针追及法"></a> 双指针追及法</h1><h2 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h2><ul><li>声明两个指针p1，p2，都指向头节点</li><li>p1为慢指针，速度一个节点，p2为快指针，速度两个节点，速度差一个节点</li><li>让两个指针开始跑，两个指针跑完一次，判断两个指针指向的节点是否相同，相同则有环，不同则继续下一次循环<br>这个思路类似于数学上的 <em>追及问题</em>，如果跑道是环形的，快指针会追上慢指针</li></ul><h2 id="复杂度-2"><a class="markdownIt-Anchor" href="#复杂度-2"></a> 复杂度</h2><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul><h2 id="源码"><a class="markdownIt-Anchor" href="#源码"></a> 源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCycle</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    Node p1 = head, p2 = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p2 != <span class="keyword">null</span> &amp;&amp; p2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ringMeetNode可以在这里获得</span></span><br><span class="line">        <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class Node&#123;</span></span><br><span class="line"><span class="comment">    int data;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node(int data)&#123;</span></span><br><span class="line"><span class="comment">        this.data = data;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="问题扩展"><a class="markdownIt-Anchor" href="#问题扩展"></a> 问题扩展</h1><h2 id="1如何求出环的长度"><a class="markdownIt-Anchor" href="#1如何求出环的长度"></a> 1.如何求出环的长度</h2><p>当两个指针首次相遇，让两个指针接着前进，并统计前进的循环次数，直到两个指针再次相遇。此时统计前进的循环次数就是环长。</p><h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3><p>p1与p2速度差为一个节点，当快指针再次追上慢指针时，快指针多走了慢指针一圈，因此：<br><strong>环长 = 快指针走的步数 - 慢指针走的步数 = 速度差 * 前进次数 = 前进次数</strong></p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRingLength</span><span class="params">(Node ringMeetNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ringLength = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ringMeetNode可以在isCycle()中获得</span></span><br><span class="line">    Node p1 = ringMeetNode, p2 = ringMeetNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next.next;</span><br><span class="line">        ringLength++;</span><br><span class="line">        <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ringLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2如何求入环节点"><a class="markdownIt-Anchor" href="#2如何求入环节点"></a> 2.如何求入环节点</h2><h3 id="原理-2"><a class="markdownIt-Anchor" href="#原理-2"></a> 原理</h3><p>假设从链表头节点到入环的距离时D，从入环点到首次相遇点的距离时S1，从首次相遇点回到入环点的距离时S2</p><ol><li>两次指针首次相遇时，各自所走的距离：</li></ol><ul><li>p1：D + S1</li><li>p2：D + S1 + S2 + S1 = D + 2S1 + S2</li></ul><ol start="2"><li>由于p2的速度是p1的两倍，因此：2(D + S1) = D + 2S1 + S2</li><li>得到 <strong>D = S2</strong>，即：从头节点到入环点的距离 = 从首次相遇点回到入环点的距离</li><li>这样一来，只要把其中一个指针放回头节点，另一个指针保持在远处，然后两个指针的 <strong>速度都是一个节点</strong>，那么：它们 <strong>相遇节点就是入环节点</strong></li></ol><h3 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">getRingStart</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="comment">//ringMeetNode可以在isCycle()中获得</span></span><br><span class="line">    Node p1 = head, p2 = ringMeetNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除指定元素</title>
      <link href="/2019/10/26/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E7%A7%BB%E9%99%A4%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0/"/>
      <url>/2019/10/26/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E7%A7%BB%E9%99%A4%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><a id="more"></a><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br>这个采用 <strong>双指针</strong> ，与之前的 <strong>删除排序数组中的重复项</strong> 极为相似</p><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != val) &#123;</span><br><span class="line">            nums[ans] = nums[i];</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针优化版"><a class="markdownIt-Anchor" href="#双指针优化版"></a> 双指针优化版</h1><p>现在考虑数组包含很少的要删除的元素的情况。例如，num=[1，2，3，5，4]，Val=4num=[1，2，3，5，4]，Val=4。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 num=[4，1，2，3，5]，Val=4，似乎没有必要将 [1，2，3，5] 这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。<br>所以当我们遇到 <strong>nums[ans] == val</strong> 的时候，我们可以将 <strong>当前元素与最后一个元素进行交换，并释放最后一个元素</strong>（ans–）。这实际上使数组的大小减少了 1。</p><ul><li>请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素，因为并没有i++。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">            nums[i] = nums[ans-<span class="number">1</span>];</span><br><span class="line">            ans--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并有序链表</title>
      <link href="/2019/10/25/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/10/25/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><a id="more"></a><p>题设类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="迭代法"><a class="markdownIt-Anchor" href="#迭代法"></a> 迭代法</h1><p>这个在数据结构中学过，虽然那时候学的是 <strong>C语言</strong>，但是思想相同。<br>由于没有头节点，我们可以假设个头节点，更容易的返回合并后的链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置头节点</span></span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode p = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            p.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将两个链表中剩下的一个链表直接接在末尾</span></span><br><span class="line">    p.next = (l1 == <span class="keyword">null</span>)?l2:l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O(n+m)</li><li>空间复杂度 O(1)</li></ul><h1 id="递归法"><a class="markdownIt-Anchor" href="#递归法"></a> 递归法</h1><p>我们可以递归的定义在两个链表的 merge 操作：<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191025171030.png" class="lazyload"><br>也就是说，头部比较小的一个与剩下元素的 merge 操作结果连接起来，就可以得到最终的链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归先考虑边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)  <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O(n+m)</li><li>空间复杂度 O(n+m)，由于需要n+m个栈帧</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习之旅————多线程</title>
      <link href="/2019/10/23/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/10/23/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>多线程（Thread）是软件开发中的重要内容，实际上，多线程最直观的说法是让应用程序看起来好像同时能做好几件事情</p><a id="more"></a><p>线程是独立的线程。它代表独立的执行空间。在Java中，要建立新的线程就得创建 <strong>Thread</strong>，CPU会在执行空间非常快速地来回切换。因为CPU速度很快，所以你会感觉CPU同时在做好几件事</p><ul><li>要记得，Java也只是个在底层操作系统上执行的进程。一旦轮到Java执行的时候，JVM实际执行的是执行空间最上面的字节码！在某个时间片内，目前执行程序代码会被切换到不同空间上的不同方法。</li><li>线程要记录的一项事情是目前线程执行空间做到哪里：保护现场</li></ul><h1 id="实现多线程的两种方法"><a class="markdownIt-Anchor" href="#实现多线程的两种方法"></a> 实现多线程的两种方法</h1><h2 id="继承-thread-类开发多线程"><a class="markdownIt-Anchor" href="#继承-thread-类开发多线程"></a> 继承 <strong>Thread</strong> 类开发多线程</h2><ol><li><p>编写一个类，继承 <strong>java.lang.Thread</strong> 类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure></li><li><p>在这个类重写 <strong>java.lang.Thread</strong> 类中的函数：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>实例化线程对象，调用其 <strong>start()</strong> 函数启动该线程</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li></ol><h2 id="实现-runnable-接口开发多线程"><a class="markdownIt-Anchor" href="#实现-runnable-接口开发多线程"></a> 实现 <strong>Runnable</strong> 接口开发多线程</h2><ol><li><p>编写一个类，实现 <strong>java.lang.Runnable</strong> 接口</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure></li><li><p>在这个类中重写 <strong>java.lang.Runnable</strong> 接口中的函数：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>实例化 <strong>java.lang.Thread</strong> 对象，实例化上面编写的 <strong>Runnable</strong> 实现类，将后者传入 <strong>Thread</strong> 对象的构造函数，调用 <strong>Thread</strong> 对象的 <strong>start()</strong> 函数来启动线程</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Runnable threadJob = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(threadJob);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li></ol><h1 id="两种方法比较"><a class="markdownIt-Anchor" href="#两种方法比较"></a> 两种方法比较</h1><ol><li>第一种每个对象都是一个线程，而第二种每个对象不是一个线程，必须将其传入Thread对象才能运行</li><li>第一种每个线程都有自己的成员变量，而第二种共享成员变量</li><li>Java不支持多重继承，只能继承一个类，但是可以实现多个接口，第一种方法虽然较简单，但是扩展性没有第二种强</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除排序数组中的重复项</title>
      <link href="/2019/10/22/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2019/10/22/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度，不需要考虑超出新长度后面的元素。</p><a id="more"></a><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><ul><li>如果题目没要求O(1)，可以直接用LinkedHashSet解决。</li><li>即使不能有空间要求，这道题也比较简单。这是我第一次速度超过100%，哈哈哈哈哈<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191022112916.png" class="lazyload"></li></ul><h1 id="双指针法"><a class="markdownIt-Anchor" href="#双指针法"></a> 双指针法</h1><p>由于我的答案和LeetCode思路一样，所以我叫他双指针法。</p><ul><li>首先判断数组是不是空或者是不是长度为1，是的话直接返回数组长度</li><li>声明两个变量即 <strong>双指针</strong> ，一个快指针i，一个慢指针ans</li><li>快指针声明在for循环里，每次循环都 i++</li><li>慢指针声明在循环外，当 nums[i] != nums[i+1]时(即不重复时)，令nums[ans] = nums[i]，ans++</li><li>最后返回ans<br></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == nums.length-<span class="number">1</span> || nums[i] != nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            nums[ans] = nums[i];</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后贴上leetcode解法"><a class="markdownIt-Anchor" href="#最后贴上leetcode解法"></a> 最后贴上LeetCode解法</h1><p>思路基本一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>罗马数转整数</title>
      <link href="/2019/10/21/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E7%BD%97%E9%A9%AC%E6%95%B0%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
      <url>/2019/10/21/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E7%BD%97%E9%A9%AC%E6%95%B0%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>罗马数字包含以下七种字符: I(1), V(5), X(10), L(50), C(100), D(500), M(1000)，将一串罗马数转成整数。</p><a id="more"></a><p>通常情况下，罗马数字中小的数字在大的数字的右边。<br>但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。<br>一共有六个特例：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。</li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br></li></ul><h1 id="穷举法"><a class="markdownIt-Anchor" href="#穷举法"></a> 穷举法</h1><ul><li>首先将所有的组合添加到哈希表中，一共有13种</li><li>然后遍历字符串，由于组合只有两类，一类是1个字符，另一类是2个字符，其中，2个字符优先级较高</li><li>返回ans</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">"I"</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">"IV"</span>, <span class="number">4</span>);</span><br><span class="line">    map.put(<span class="string">"V"</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">"IX"</span>, <span class="number">9</span>);</span><br><span class="line">    map.put(<span class="string">"X"</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="string">"XL"</span>, <span class="number">40</span>);</span><br><span class="line">    map.put(<span class="string">"L"</span>, <span class="number">50</span>);</span><br><span class="line">    map.put(<span class="string">"XC"</span>, <span class="number">90</span>);</span><br><span class="line">    map.put(<span class="string">"C"</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">"CD"</span>, <span class="number">400</span>);</span><br><span class="line">    map.put(<span class="string">"D"</span>, <span class="number">500</span>);</span><br><span class="line">    map.put(<span class="string">"CM"</span>, <span class="number">900</span>);</span><br><span class="line">    map.put(<span class="string">"M"</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length();)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &lt; s.length() &amp;&amp; map.containsKey(s.substring(i, i+<span class="number">2</span>)))&#123;</span><br><span class="line">            ans += map.get(s.substring(i,i+<span class="number">2</span>));</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans += map.get(s.substring(i,i+<span class="number">1</span>));</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="更优解法"><a class="markdownIt-Anchor" href="#更优解法"></a> 更优解法</h1><p>因为通常情况下，罗马数字中小的数字在大的数字的右边，所以我们可以和下一个字符比大小，如果比它小，那么就是六种特例中的一种</p><ul><li>定义一个获取罗马字符对应数字的静态方法，使用switch来获取字符对应数字</li><li>遍历字符串，比较当前字符和下一字符的数字大小，大于则加，小于则减</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态方法获得罗马数对应的数字大小</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal character"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = getValue(s.charAt(i));</span><br><span class="line">        <span class="comment">//i为最后一个时，直接加</span></span><br><span class="line">        <span class="keyword">if</span>(i == n-<span class="number">1</span> || t &gt;= getValue(s.charAt(i+<span class="number">1</span>)))&#123;</span><br><span class="line">            ans += t;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans -= t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂等法</title>
      <link href="/2019/10/20/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AD%89%E6%B3%95/"/>
      <url>/2019/10/20/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AD%89%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>实现 <strong>pow(x,n)</strong> ，即求x的n次幂。使用暴力法超时，因而使用快速幂等法。</p><a id="more"></a><h1 id="快速幂等法"><a class="markdownIt-Anchor" href="#快速幂等法"></a> 快速幂等法</h1><p>要求一个数的n次幂，可以先求他的n/2次幂，一直分下去，简化问题，减少运算次数。<br>假设 A = x^(n/2)<br>如果 n%2 == 0，则 x^n = A * A;<br>如果 n%2 != 0，则 x^n = A * A * x;</p><ul><li>可以采用循环法或者是递归法解决问题，时间复杂度均为 <strong>O(logN)</strong></li></ul><h1 id="循环法"><a class="markdownIt-Anchor" href="#循环法"></a> 循环法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//n是32位有符号整数，其数值范围是[−2^31, 2^31 − 1]。</span></span><br><span class="line">        <span class="comment">//如果直接将其 -n 转化为正数，有可能导致溢出</span></span><br><span class="line">        <span class="comment">//所以采用long类型储存n</span></span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            N = -N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> current_product = x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = N; i &gt; <span class="number">0</span>; i /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = ans * current_product;</span><br><span class="line">            &#125;</span><br><span class="line">            current_product = current_product * current_product;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="递归法"><a class="markdownIt-Anchor" href="#递归法"></a> 递归法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> N = n;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        N = -N;</span><br><span class="line">        x = <span class="number">1</span>/x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> myFastPow(x, N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myFastPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">double</span> half = myFastPow(x, n/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> ==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> half*half;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> half*half*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="位运算法"><a class="markdownIt-Anchor" href="#位运算法"></a> 位运算法</h1><p>此外还有一种位运算的方法，只说思路：把指数部分转换成2进制，然后展开成2的幂次的和。借用网上的图展示关系<br>以 x 的 10 次方举例。10 的 2 进制是 1010，然后用 2 进制转 10 进制的方法把它展成 2 的幂次的和。<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191020143802.png" class="lazyload"><br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191020143835.png" class="lazyload"></p><ul><li>时间复杂度为 <strong>O(N)</strong></li><li>以上算法空间复杂度均是 <strong>O(1)</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="/2019/10/19/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2019/10/19/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>滑动窗口是数组/字符串问题中常用的抽象概念。</p><a id="more"></a><h1 id="无重复字符的最长子串-给定一个字符串请你找出其中-不含有重复字符-的-最长子串-的长度"><a class="markdownIt-Anchor" href="#无重复字符的最长子串-给定一个字符串请你找出其中-不含有重复字符-的-最长子串-的长度"></a> <strong>无重复字符的最长子串</strong> :给定一个字符串，请你找出其中 <strong>不含有重复字符</strong> 的 <strong>最长子串</strong> 的长度</h1><h2 id="暴力法"><a class="markdownIt-Anchor" href="#暴力法"></a> 暴力法</h2><p>如果使用暴力法，检查所有的子字符串，则时间复杂度为O(n^3)，耗费时间过多。暴力法会反复检查一个字符串是否含有重复的字符，浪费时间。</p><h2 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h2><p>窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j）（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。<br>-例:[i, j）向右滑动1个元素，则它将变为[i+1, j+1)<br>回到我们的问题，我们使用 HashSet 将字符存储在当前窗口 [i, j)（最初 j = i）中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。</p><h2 id="优化版的滑动窗口"><a class="markdownIt-Anchor" href="#优化版的滑动窗口"></a> 优化版的滑动窗口</h2><p>上述的方法最多需要执行 2n 个步骤。事实上，它可以被进一步优化为仅需要 n 个步骤。我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。</p><ul><li>也就是说，如果 j 对应的字符与[i, j-1]重复，则不再让 i++，而是直接跳过[i, j],令 i=j+1;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, n = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符对应的索引为下一次不重复的位置，即下一位置</span></span><br><span class="line">        <span class="comment">//例：j这个地方与前面重复了，则下一次不重复的位置为j+1</span></span><br><span class="line">        <span class="comment">//声明HashMap，形成字符到索引的映射</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="comment">//如果map中有s[j],则更新i</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(j)))&#123;</span><br><span class="line">                i = Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新ans</span></span><br><span class="line">            ans = Math.max(ans, j-i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将s[j]和它到索引的映射(下一个不重复的位置）加入map</span></span><br><span class="line">            <span class="comment">//若是已经重复，则是更新索引，更新为下一次不重复的位置</span></span><br><span class="line">            map.put(s.charAt(j), j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo + Github 图床</title>
      <link href="/2019/10/12/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/PicGo+Github%E5%AE%9E%E7%8E%B0%E5%BA%8A%E5%9B%BE/"/>
      <url>/2019/10/12/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/PicGo+Github%E5%AE%9E%E7%8E%B0%E5%BA%8A%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>昨天用了七牛云实现了床图，但是突然发现免费的只有30天的时间，到了时间就会换域名。之前的图床就失效了，于是转而薅Github的羊毛。</p><a id="more"></a><h1 id="picgo"><a class="markdownIt-Anchor" href="#picgo"></a> PicGo</h1><p>这是一款图片上传的工具，支持众多图床<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190909113126.png" class="lazyload"></p><h1 id="创建github图床"><a class="markdownIt-Anchor" href="#创建github图床"></a> 创建Github图床</h1><p>Github国内访问较慢，但是免费的，真香</p><h2 id="1注册github"><a class="markdownIt-Anchor" href="#1注册github"></a> 1.注册Github</h2><p>这个就不说呢</p><h2 id="2创建一个新公共仓库"><a class="markdownIt-Anchor" href="#2创建一个新公共仓库"></a> 2.创建一个新公共仓库</h2><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190909113644.png" class="lazyload"></p><h2 id="3生成一个token用于操作github仓库"><a class="markdownIt-Anchor" href="#3生成一个token用于操作github仓库"></a> 3.生成一个token用于操作Github仓库</h2><p>在个人 <strong>Settings</strong> / <strong>Developer settings</strong> / <strong>Personal access tokens</strong> 内 <strong>Generate new token</strong><br>只需勾选 <strong>repo</strong><br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190909114127.png" class="lazyload"></p><ul><li>创建成功后，会生成一串token，这串token只显示一次！<br></li></ul><h1 id="配置picgo"><a class="markdownIt-Anchor" href="#配置picgo"></a> 配置PicGo</h1><h2 id="1下载运行picgo"><a class="markdownIt-Anchor" href="#1下载运行picgo"></a> 1.下载运行PicGo</h2><p>在这个链接下下载<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">PicGo</a><br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190909114643.png" class="lazyload"></p><ul><li>mac 系统选择 .dmg 下载，windwos 选择 .exe系统</li></ul><h2 id="2配置图床"><a class="markdownIt-Anchor" href="#2配置图床"></a> 2.配置图床</h2><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190909114721.png" class="lazyload"></p><ul><li>设定仓库名的时候，是按照“账户名/仓库名的格式填写”</li><li>分支名统一填写“master”</li><li>存储的路径可以按照我这样子写，就会在仓库下创建一个“img”文件夹，当然也可以不填</li></ul><h2 id="3快捷键修改"><a class="markdownIt-Anchor" href="#3快捷键修改"></a> 3.快捷键修改</h2><p>根据个人习惯，我这里是这样配置的<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190909115028.png" class="lazyload"></p><h1 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h1><p>将上面的步骤都设置好之后，就可以让自己的Markdown文档更生动形象呢，每次截图之后，都可以按一下 <strong>ctrl+shift+c</strong>，这样就会将剪切板上面的截图转化为在线网络图片链接，十分快捷。<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/biubiubiu.gif" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+gayhub搭建个人博客</title>
      <link href="/2019/10/12/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/hexo+gayhub/"/>
      <url>/2019/10/12/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/hexo+gayhub/</url>
      
        <content type="html"><![CDATA[<p>经过<strong>学姐</strong>的安利，我用<strong>hexo+gayhub</strong>搭建起了第一个个人博客</p><a id="more"></a><h1 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h1><hr><ol><li>你要有个gayhub账号，虽然在国内访问较慢，但是免费，真香</li><li>安装node.js，npm(也可以装cnpm，为npm的淘宝镜像，国内访问速度快）</li><li>安装git</li><li>有台Windows电脑，还有个女朋友</li></ol><hr><h1 id="创建github博客"><a class="markdownIt-Anchor" href="#创建github博客"></a> 创建github博客</h1><h2 id="1-新建仓库"><a class="markdownIt-Anchor" href="#1-新建仓库"></a> 1. 新建仓库</h2><p>在github上新建个仓库，命名规则必须为：<strong><a href="http://xn--6qqv7i14ofosyrb.github.io" target="_blank" rel="noopener">你的用户名.github.io</a></strong>(我也不知道为什么要这样子哈)，如果没钱的话这个就是你以后的博客地址了。</p><h2 id="2绑定域名"><a class="markdownIt-Anchor" href="#2绑定域名"></a> 2.绑定域名</h2><p>由于我没有钱，所以绑定域名就不说了，你可以买个域名，然后把域名的地址跳转到<strong><a href="http://xn--6qqv7i14ofosyrb.github.io" target="_blank" rel="noopener">你的用户名.github.io</a></strong>就行了。</p><h2 id="3配置ssh"><a class="markdownIt-Anchor" href="#3配置ssh"></a> 3.配置SSH</h2><p>这个有什么用呢？给你的博客加个密，防止其他人提交代码。<br>打开cmd输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/. ssh #检查本机已存在的ssh密钥</span><br></pre></td></tr></table></figure><p>如果提示：No such file or directory 说明你是第一次使用git。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><p>连续三次回车就行了<br>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到 <strong>.ssh\id_rsa.pub</strong> 文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：<br>将刚复制的内容粘贴到key那里，title随便填，保存.</p><h3 id="测试是否成功"><a class="markdownIt-Anchor" href="#测试是否成功"></a> 测试是否成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com # 注意邮箱地址不用改</span><br></pre></td></tr></table></figure><p>然后yes就行了。<br>此外你还配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;****&quot;// 你的github用户名，非昵称</span><br><span class="line">$ git config --global user.email  &quot;xxx@qq.com&quot;// 填写你的github注册邮箱</span><br></pre></td></tr></table></figure><p>这个具体是什么呢？我也不知道呀</p><h1 id="安装hexo"><a class="markdownIt-Anchor" href="#安装hexo"></a> 安装hexo</h1><h2 id="首先我们安装个cnpm"><a class="markdownIt-Anchor" href="#首先我们安装个cnpm"></a> 首先我们安装个cnpm</h2><p>前面也说过了，加快下载速度。<br>我们要用npm下载cnpm，然后以后都用cnpm代替npm (npm:???!!!)<br>在你的blog文件夹，在空白处点击鼠标右键，选择 <strong>Git Bash Here</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install cnpm -g --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><ul><li>开始安装hexo</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm intall -g hexo-cli </span><br><span class="line">#这里原本是 npm intall -g hexo-cli ，但是下载速度较慢所以切换成cnpm，以后都如此</span><br></pre></td></tr></table></figure><p>验证是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>如果你看不到error，那应该就是成功了，哈</p><ul><li>重要的一步来了，初始化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>如果最后一行出现 <strong>Start blogging with Hexo!</strong><br>恭喜你，可以开始编写博客了</p><h2 id="先测试一下"><a class="markdownIt-Anchor" href="#先测试一下"></a> 先测试一下</h2><p>我们经常用的指令是以下几个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean #用来清理缓存文件</span><br><span class="line">hexo g     #hexo generate的缩写，生成文件</span><br><span class="line">hexo s     #hexo serve的缩写，生成本地预览</span><br><span class="line">hexo d     #hexo deploy的缩写，部署到服务器</span><br></pre></td></tr></table></figure><p>还有一个组合指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并部署</span><br></pre></td></tr></table></figure><ul><li>测试本地运行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>打开浏览器，进入 <strong>localhost:4000</strong>，你会看到hexo自带的一个主题还有 <strong>Hello World</strong></p><h1 id="更换主题"><a class="markdownIt-Anchor" href="#更换主题"></a> 更换主题</h1><p>我最喜欢的就是美化了</p><ul><li>由于网上比较推荐的是 <strong>yilia</strong>，所以我下载了它。<br>首先下载这个主题，在你的文件夹你 <strong>Git Bash Here</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><p>下载的主题都在 <strong>themes</strong> 文件夹<br>修改源文件夹下的 <strong>_config.yml</strong> 中的 <strong>theme: landscape</strong> 改为<strong>theme: yilia</strong> ，然后重新执行 <strong>hexo g</strong> 来重新生成。<br><strong>hexo s</strong> 后进入 <strong>localhost:4000</strong> 就能预览你的主题了。<br>如果出现一些莫名其妙的问题，可以先执行 <strong>hexo clean</strong> 来清理一下内容，然后再来重新生成和发布。</p><ul><li>你可以在 <strong>themes</strong>文件夹下的 <strong>_config.yml</strong> 修改有关主题的内容，这里不多加详述了。</li></ul><h1 id="部署到github"><a class="markdownIt-Anchor" href="#部署到github"></a> 部署到Github</h1><p>如果你一切都配置好了，发布上传很容易，一句 <strong>hexo d</strong> 就搞定，当然关键还是你要把所有东西配置好。</p><ul><li>首先，<strong>ssh key</strong>肯定要配置好。</li><li>其次，配置 <strong>_config.yml</strong> 中有关 <strong>deploy</strong>的部分：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: github</span><br><span class="line">  repository: https://github.com/******.github.io.git #你的仓库地址</span><br><span class="line">  branch: master</span><br><span class="line">#注意空格</span><br></pre></td></tr></table></figure><ul><li>此外还装一个插件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ul><li>最后的最后<br><strong>hexo d</strong>就能把你的博客部署到GitHub上了。<br>以后你可以打开 <strong><a href="http://xn--6qqv7i14ofosyrb.github.io" target="_blank" rel="noopener">你的用户名.github.io</a></strong>，进入你的博客。<br>#可以写博客了</li><li>由于我基本不会命令行，所以我没用命令行。<br>你可以直接新建一个 <strong>.md</strong>的文件，然后用 <strong>Markdown</strong>的编辑器打开就可以开始写你的博客了（我用的编辑器是 <strong>VSCode</strong> + <strong>Markdown Preview Enhanced插件</strong>），这里的 <strong>.md</strong>的文件使用 <strong>Markdown</strong>语法写的，十分简单 ，几分钟速成。<br>写好后，把文件放在你的文件夹下的 <strong>source/_posts</strong>就行了。<br>然后用组合命令行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>就能直接生成本地文件并且部署到服务器上。</p><h1 id="最终效果"><a class="markdownIt-Anchor" href="#最终效果"></a> 最终效果</h1><p>也就是本博客 <strong><a href="http://EasonZzZz.github.io" target="_blank" rel="noopener">EasonZzZz.github.io</a></strong><br><img alt data-src="http://pxij6pdrn.bkt.clouddn.com/static/images/biubiubiu.gif" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK-13配置环境</title>
      <link href="/2019/10/12/Java%E5%AD%A6%E4%B9%A0/JDK-13%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/10/12/Java%E5%AD%A6%E4%B9%A0/JDK-13%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>目前最新JDK-13的配置环境方法，虽然我也不懂为什么这样弄，但是能用就行。</p><a id="more"></a><h1 id="下载并安装jdk-13"><a class="markdownIt-Anchor" href="#下载并安装jdk-13"></a> 下载并安装JDK-13</h1><p>当然实在 <a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">官网</a> 下载了</p><h1 id="生成jre文件夹"><a class="markdownIt-Anchor" href="#生成jre文件夹"></a> 生成jre文件夹</h1><p>打开cmd，cd到D:\Java\jdk-13(你的安装文件夹) 然后输入并运行命令：bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre</p><h1 id="配置jdk-13环境"><a class="markdownIt-Anchor" href="#配置jdk-13环境"></a> 配置JDK-13环境</h1><h2 id="系统变量添加"><a class="markdownIt-Anchor" href="#系统变量添加"></a> 系统变量添加</h2><ul><li>Java_Home  D:\Java\jdk-13</li><li>ClassPath  .;%Java_Home%\bin;%Java_Home%\lib\dt.jar;%Java_Home%\lib\tools.jar(注意.号)</li></ul><h2 id="系统变量path里追加"><a class="markdownIt-Anchor" href="#系统变量path里追加"></a> 系统变量Path里追加</h2><ul><li>;%Java_Home%\bin;%Java_Home%\jre\bin</li></ul><h1 id="最后检查是否成功"><a class="markdownIt-Anchor" href="#最后检查是否成功"></a> 最后检查是否成功</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">javac</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><p>能看到很多东西应该就是成功了，哈哈哈哈哈</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm(cnpm)安装/卸载模块</title>
      <link href="/2019/10/12/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/cnpm%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/10/12/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/cnpm%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>因为发现七牛云不行，所以卸载了有关的插件。</p><a id="more"></a><h1 id="安装模块"><a class="markdownIt-Anchor" href="#安装模块"></a> 安装模块</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install xxx      #利用 npm 安装xxx模块到当前命令行所在目录</span><br><span class="line">npm install -g xxx   #利用npm安装全局模块xxx</span><br></pre></td></tr></table></figure><h1 id="本地安装时将模块写入-packagejson"><a class="markdownIt-Anchor" href="#本地安装时将模块写入-packagejson"></a> 本地安装时将模块写入 <strong>package.json</strong></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install xxx             #安装但不写入package.json</span><br><span class="line">npm install xxx –save       #安装并写入package.json的”dependencies”中</span><br><span class="line">npm install xxx –save -dev  #安装并写入package.json的”devDependencies”中</span><br></pre></td></tr></table></figure><h1 id="删除模块"><a class="markdownIt-Anchor" href="#删除模块"></a> 删除模块</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall xxx      #删除xxx模块</span><br><span class="line">npm uninstall -g xxx   #删除全局模块xxx</span><br></pre></td></tr></table></figure><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/biubiubiu.gif" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习之旅————单例模式</title>
      <link href="/2019/10/12/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/10/12/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>郭克华老师在上课讲到的一种设计模式—单例模式。<br>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建 <strong>单一对象</strong> 的最佳方式。</p><a id="more"></a><h1 id="那么问题来了为什么创建单一对象呢"><a class="markdownIt-Anchor" href="#那么问题来了为什么创建单一对象呢"></a> 那么问题来了，为什么创建单一对象呢?</h1><p>有一些实例只需要创建一次就够了，例如：一个班级只有一个班主任，Windows系统只有一个Task Manager(任务管理器)</p><h1 id="单例模式有什么优缺点呢"><a class="markdownIt-Anchor" href="#单例模式有什么优缺点呢"></a> 单例模式有什么优缺点呢？</h1><h2 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h2><ul><li>1.在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。<br></li><li>2.避免对资源的多重占用（比如写文件操作）。</li><li></li></ul><h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2><ul><li>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。<br></li></ul><hr><h1 id="如何实现单例模式"><a class="markdownIt-Anchor" href="#如何实现单例模式"></a> 如何实现单例模式</h1><p>我们将创建一个 SingleObject 类。SingleObject 类有它的 <strong>私有构造函数</strong> 和本身的一个 <strong>静态实例</strong>。<br>SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190925152915.png" class="lazyload"></p><h2 id="step-1"><a class="markdownIt-Anchor" href="#step-1"></a> Step 1</h2><p>创建一个SingleObject类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建SingleObject的一个私有静态对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance = <span class="keyword">new</span> SingObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给外面一个接口，返回唯一可用对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="step-2"><a class="markdownIt-Anchor" href="#step-2"></a> Step 2</h2><p>在外界声明个SingleObject的引用，获取该唯一对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SingleObject instance = SingleObject.getInstance();</span><br></pre></td></tr></table></figure><hr><h1 id="这里的实现方式只是一个大致的抽象方法更详细的如下"><a class="markdownIt-Anchor" href="#这里的实现方式只是一个大致的抽象方法更详细的如下"></a> 这里的实现方式只是一个大致的抽象方法，更详细的如下</h1><ul><li>懒汉式—线程不安全：最基础的实现方式，线程上下文单例，不需要共享给所有线程，也不需要加synchronize之类的锁，以提高性能</li><li>懒汉式—线程安全：加上synchronize之类保证线程安全的基础上的懒汉模式，相对性能很低，大部分时间并不需要同步</li><li>饿汉方式。指全局的单例实例在类装载时构建。</li><li>双检锁式。在懒汉式基础上利用synchronize关键字和volatile关键字确保第一次创建时没有线程间竞争而产生多个实例，仅第一次创建时同步，性能相对较高</li><li>登记式。作为创建类的全局属性存在，创建类被装载时创建</li><li>枚举。java中枚举类本身也是一种单例模式</li></ul><hr><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>单例模式是设计模式中最简单的形式之一。这一模式的目的是使得类的一个对象成为系统中的唯一实例。它有很多种实现方式，但是文中只给出了大致的思路，以后再学习更进一步的实现方式。</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
