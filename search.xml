<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ algorithm</title>
      <link href="/2021/04/13/%E5%AD%A6%E4%B9%A0/C++%E5%AD%A6%E4%B9%A0/C++%20algorithm/"/>
      <url>/2021/04/13/%E5%AD%A6%E4%B9%A0/C++%E5%AD%A6%E4%B9%A0/C++%20algorithm/</url>
      
        <content type="html"><![CDATA[<p>头文件 <code>algorithm</code> 定义一个函数集合，特别设计用于元素范围，主要应用于 STL 的 Containers。</p><ul><li>引入 <code>algorithm</code> ，需在 <code>std</code> 命名空间中。</li></ul><h2 id="max-min-abs"><a class="markdownIt-Anchor" href="#max-min-abs"></a> max()、min()、abs()</h2><p>返回最大值、最小值、绝对值（整数）</p><ul><li>浮点型的绝对值使用 <code>math.h</code> 里的 <code>fabs</code></li></ul><h2 id="swap"><a class="markdownIt-Anchor" href="#swap"></a> swap()</h2><p><code>swap(x, y)</code> 用来交换 x、y 的值</p><h2 id="reverse"><a class="markdownIt-Anchor" href="#reverse"></a> reverse()</h2><p><code>reverse(it1, it2)</code> 可以将数组指针在 <code>[it1, it2)</code> 之间的元素或容器的迭代器在 <code>[it1, it2)</code> 范围内的元素进行反转。</p><h2 id="permutation"><a class="markdownIt-Anchor" href="#permutation"></a> permutation()</h2><p><code>pre_permutation(it1, it2)</code> 给出一个序列在全排列中的 <strong>上一个序列</strong></p><p><code>next_permutation(it1, it2)</code> 给出一个序列在全排列中的 <strong>下一个序列</strong></p><p><code>is_permutation(it1, it2, it3, it4)</code> 检查一个序列是不是另一个序列的排列</p><h2 id="fill"><a class="markdownIt-Anchor" href="#fill"></a> fill()</h2><p><code>fill(it1, it2, value)</code> 可以把数组或容器中的某一段区间赋为某个相同的值。</p><ul><li><code>memset</code> 一般只赋值 0 或 -1</li></ul><h2 id="sort"><a class="markdownIt-Anchor" href="#sort"></a> sort()</h2><p><code>sort</code> 是排序的函数，效率较高，时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><ol><li><p><strong>如何使用 sort 排序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(首地址, 尾地址的下一个地址, 比较函数（可选）)</span><br></pre></td></tr></table></figure><ul><li>不写比较函数默认递增排序</li></ul></li><li><p><strong>如何实现比较函数 cmp</strong></p><p>(1) <strong>基本数据类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回 true 时不交换，false 则交换</span></span><br><span class="line">    <span class="comment">// &gt; 也可以直接看作大的排在前面</span></span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) <strong>结构体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 按 first 递减，相等按 second 递减</span></span><br><span class="line">    <span class="keyword">return</span> a.first != b.first ? a.first &gt; b.first : a.second &gt; b.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3) <strong>容器</strong></p><p>在 STL 的 Containers 中，只有 <code>vector、string、deque</code> 可以使用 <code>sort</code>。<code>set、map</code> 底层使用了红黑树，本身有序。</p><p>根据容器装的内容来重写 <code>cmp</code>。</p></li></ol><h2 id="lower_bound-和-upper_bound"><a class="markdownIt-Anchor" href="#lower_bound-和-upper_bound"></a> lower_bound() 和 upper_bound()</h2><p>用在一个有序数组或容器中。</p><p><code>lower_bound(first, last, val)</code>：寻找 <code>[first, last)</code> 范围内<strong>第一个大于等于 val</strong> 的元素位置。</p><p><code>upper_bound(first, last, val)</code>：寻找 <code>[first, last)</code> 范围内<strong>第一个大于 val</strong> 的元素位置。</p><p>两个方法均返回的是 <strong>指针或迭代器</strong></p><ul><li>如果想获取下标，<strong>直接令返回值减去数组首地址即可</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL容器</title>
      <link href="/2021/04/12/%E5%AD%A6%E4%B9%A0/C++%E5%AD%A6%E4%B9%A0/C++%20STL%E5%AE%B9%E5%99%A8/"/>
      <url>/2021/04/12/%E5%AD%A6%E4%B9%A0/C++%E5%AD%A6%E4%B9%A0/C++%20STL%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>C++ 标准模板库（Standard Template Library，STL）</strong>：STL 的代码从广义上讲分为三类：<em>algorithm</em>（算法）、<em>container</em>（容器）和 <em>iterator</em>（迭代器），几乎所有的代码都采用了模板类和模板函数的方法，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。</p><p>以下主讲 <em>container</em>（容器）和 <em>iterator</em>（迭代器）。</p><ul><li>使用 STL 一般要使用 <code>std</code> 的命名空间</li></ul><h1 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> vector</h1><p><em>vector</em>，向量，可以理解为”变长数组“。添加 <code>vector</code> 头文件即可使用 <code>vector</code> 了。</p><ol><li><p><strong>vector 的定义</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><ul><li>这里的 <code>typename</code> 可以是任何基本类型、结构体，也可以是 STL 标准容器（定义时 <code>&gt; &gt;</code> 记得隔开，因为有些编译器可能会视为移位操作）</li></ul></li><li><p><strong>vector 内元素访问</strong></p><p>可以通过 <strong>下标访问</strong> 或者是 <strong>迭代器</strong>：</p><ul><li><strong>下标访问</strong>：与普通数组一样，直接访问 <code>vi[index]</code> 即可，下标范围：<code>0 ~ vi.size-1</code></li><li><strong>迭代器</strong>：类似于 <strong>指针</strong>，实现了两种自加操作<ul><li>只有 <code>vector</code> 和 <code>string</code> 中允许使用 <code>vi.begin() + 整数</code> 的写法</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 下标访问</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vi.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, vi[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vi.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, *(vi.begin() + i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vi.begin(); it != vi.end(); it++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, *it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vi.begin()</code> 是首元素地址，<code>vi.end</code> 是尾元素的下一个地址，左闭右开</li></ul></li><li><p><strong>vector 常用函数</strong></p><p>(1) <code>push_back(x)</code>：在 <code>vector</code> 后面添加一个元素</p><p>(2) <code>pop_back()</code>：删除 <code>vector</code> 的尾元素</p><p>(3) <code>size()</code>：返回元素个数，<code>unsigned</code> 类型，一般直接用 <code>%d</code> 也不会出问题</p><p>(4) <code>clear()</code>：清空 <code>vector</code></p><p>(5) <code>insert(it, x)</code>：向 <code>vector</code> 的任意迭代器 <code>it</code> 处插入一个元素 x</p><p>(6) <code>erase()</code>：删除单个元素、或删除一个区间内的所有元素</p><ul><li><code>erase(it)</code>：即删除迭代器 it 对应的元素</li><li><code>erase(first, last)</code>：删除 <code>[first, last)</code> 内所有的元素</li></ul></li><li><p><strong>常见用途</strong></p><ul><li>存储数据：可变长度</li><li>作为邻接表存储图</li></ul></li></ol><h1 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h1><p><em>set</em>，集合，是一个 <strong>内部自动有序（递增）</strong> 且 <strong>不含重复元素</strong> 的容器。添加 <code>set</code> 头文件即可使用 <code>set</code> 了</p><ol><li><p><strong>set 的定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><ul><li><code>typename</code> 与 <code>vector</code> 的定义一样</li></ul></li><li><p><strong>set 内元素访问</strong></p><p>set 只能通过 <strong>迭代器</strong> 访问，且只能通过 <strong>自加操作</strong> 遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = st.begin(); it != st.end(); it++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, *it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>set 常用函数</strong></p><p>(1) <code>insert(x)</code>：插入元素到 <code>set</code> 中</p><p>(2) <code>find(value)</code>：返回 <code>set</code> 中对应值为 value 的迭代器</p><p>(3) <code>erase()</code>：删除单个元素、或删除一个区间内的所有元素</p><ul><li><code>erase(it)</code>：即删除迭代器 it 对应的元素</li><li><code>erase(value)</code>：<code>value</code> 为需要删除元素的值</li><li><code>erase(first, last)</code>：删除 <code>[first, last)</code> 内所有的元素</li></ul><p>(4) <code>size()</code>：获得 <code>set</code> 内元素的个数</p><p>(5) <code>clear()</code>：清除 <code>set</code> 中的所有元素</p></li><li><p><strong>扩展</strong></p><ul><li><code>set</code> 是自动去重并升序排序的</li><li><code>multiset</code> 元素不唯一</li><li><code>unordered_set</code> 以散列代替 <code>set</code> 的红黑树，只去重不排序，速度更快<ul><li>可以认为：默认是排序的，即 Java 中的 <code>TreeSet</code>，而 <code>unordered_set</code> 是 <code>HashSet</code></li></ul></li><li>此外还有 <code>unordered_map</code>，使用 hash 的方式，可以认为是 Java 的 <code>HashMap</code>，而Map</li></ul></li></ol><h1 id="string"><a class="markdownIt-Anchor" href="#string"></a> string</h1><p>C 中一般使用 <code>char str[]</code> 来存放字符串，但是容易出错，因此 C++ 对字符串常用的需要功能封装成了 <code>string</code> 类型。添加 <code>string</code> 头文件即可使用 <code>string</code>（<code>string.h</code> 和 <code>string</code> 是不一样的头文件）。</p><ol><li><p><strong>string 的定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"Eason"</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>string 输入</strong></p><p>如果要读入和输出整个字符串，只能用 <code>cin</code> 和 <code>count</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str;</span><br></pre></td></tr></table></figure><p>其实也可以用 <code>printf</code> 来输出，通过 <code>c_str()</code> 将 <code>string</code> 转换为字符数组输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str.c_str());</span><br></pre></td></tr></table></figure></li><li><p><strong>string 中内容的访问</strong></p><p>与 <code>vector</code> 一样，可以通过 <strong>下标访问</strong> 或者是 <strong>迭代器</strong>：</p><ul><li><strong>下标访问</strong>：与字符数组一样，直接访问 <code>str[index]</code> 即可，下标范围：<code>0 ~ vi.length-1</code></li><li><strong>迭代器</strong>：类似于 <strong>指针</strong>，实现了两种自加操作<ul><li>只有 <code>vector</code> 和 <code>string</code> 中允许使用 <code>vi.begin() + 整数</code> 的写法</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"Eason"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">string</span>::iterator it = str.begin(); it != str.end(); it++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, *it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>string 常用函数</strong></p><p>(1) <code>operator+=</code>：<code>+=</code> 的重载，将两个 <code>string</code> 直接拼接起来</p><p>(2) <code>compare operator</code>：两个 <code>string</code> 可以直接使用 <code>==、!=、&lt;、&lt;=、&gt;、&gt;=</code> 比较大小，比较规则是 <strong>字典序</strong></p><p>(3) <code>length()/size()</code>：返回 <code>string</code> 的长度，即存放的字符数</p><p>(4) <code>insert()</code>：<code>string</code> 的插入方式有很多</p><ul><li><code>insert(pos, string)</code>：在 <code>pos</code> 对应的位置插入字符串 <code>string</code></li><li><code>insert(it, begin, end)</code>：<code>it</code> 为原字符串的欲插入位置，<code>begin</code>、<code>end</code> 为待插入字符串的首尾迭代器，将 <code>[begin, end)</code> 插入到 <code>it</code> 的位置上</li></ul><p>(5) <code>erase()</code>：删除单个元素、删除一个区间内的所有元素</p><ul><li><code>erase(it)</code>：即删除迭代器 it 对应的字符</li><li><code>erase(first, last)</code>：删除 <code>[first, last)</code> 内所有的字符</li><li><code>erase(pos, length)</code>：删除 <code>[pos, pos + length)</code> 内的字符，<code>pos</code> 为需要开始删除的起始位置，<code>length</code> 为删除的字符个数</li></ul><p>(6) <code>clear()</code>：清空 <code>string</code> 中的数据</p><p>(7) <code>substr(pos, len)</code>：返回从 <code>pos</code> 开始、长度为 <code>len</code> 的子串</p><p>(8) <code>string::npos</code>：一个常数，值为 <code>-1</code>，但由于是 <code>unsigned_int</code> 类型，用作为 <code>find()</code> 函数失配时的返回值</p><p>(9) <code>find()</code>：在字符串中寻找子串</p><ul><li><code>find(str)</code>：返回 <code>str</code> 在字符串中第一次出现的位置，如果不出现则返回 <code>string::npos</code></li><li><code>find(str, pos)</code>：从字符串的 <code>pos</code> 开始匹配 <code>str</code></li></ul><p>(10) <code>replace()</code>：替换子串</p><ul><li><code>str.replace(pos, len, str2)</code>：将 <code>str</code> 从 <code>pos</code> 开始，长度为 <code>len</code> 的子串替换为 <code>str2</code></li><li><code>str.replace(start, end, str2)</code>：把 <code>str</code> 的 <code>[start, end)</code> 范围的子串替换成 <code>str2</code></li></ul></li></ol><h1 id="map"><a class="markdownIt-Anchor" href="#map"></a> map</h1><p><em>map</em>，映射，<em>key</em> 和 <em>value</em> 唯一，且按 <em>key</em> 自动排序，添加头文件 <code>map</code>。</p><ol><li><p><strong>map 的定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;typename1, typename2&gt; mp;</span><br></pre></td></tr></table></figure><ul><li><code>typename1</code> 可以用 <code>string</code> 但是不能使用 <code>char[]</code></li></ul></li><li><p><strong>map 内元素的访问</strong></p><p>通过 <strong>下标</strong>、<strong>迭代器</strong> 访问</p><ul><li><code>map</code> 的下标并不一定是数字，为 <code>typename1</code> 类型</li><li><code>map</code> 迭代器有两个键：<code>map</code> 可以使用 <code>it-&gt;first</code> 访问键， <code>it-&gt;second</code> 访问值</li></ul></li><li><p><strong>map 常用函数</strong></p><p>(1) <code>find(key)</code>：返回键为 <code>key</code> 的映射的迭代器</p><p>(2) <code>erase()</code>：删除单个元素、删除一个区间内的所有元素</p><ul><li><code>erase(it)</code>：删除迭代器 it 对应的映射</li><li><code>erase(key)</code>：删除键为 <code>key</code> 的映射</li><li><code>erase(first, last)</code>：删除 <code>[first, last)</code> 内所有的字符</li></ul><p>(3) <code>size()</code>：<code>map</code> 中映射的对数</p><p>(4) <code>clear()</code>：清空 <code>map</code></p></li><li><p><strong>扩展</strong></p><ul><li><code>multimap</code> 可以一个键对多个值</li><li><code>unordered_map</code> 以散列代替 <code>map</code> 的红黑树，不排序，速度更快</li></ul></li></ol><h1 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> queue</h1><p><em>queue</em>，队列，先进先出（FIFO）的限制性数据结构。引入头文件 <code>queue</code>。</p><ol><li><p><strong>queue 的定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure></li><li><p><strong>queue 内元素的访问</strong></p><p><code>queue</code> 只能通过 <code>front()</code> 来访问队首元素、<code>back()</code> 来访问队尾元素</p></li><li><p><strong>queue 常用函数</strong></p><p>(1) <code>push(x)</code>：将 x 入队列</p><p>(2) <code>front()、back()</code>：获取队首元素、队尾元素</p><p>(3) <code>pop()</code>：队首元素出队</p><p>(4) <code>empty()</code>：判断队列是否为空</p><ul><li>使用 <code>front()、back()</code> 前必须判断队列是否为空</li></ul></li><li><p><strong>扩展</strong>：</p><ul><li><strong>双端队列(deque)</strong> 和 <strong>优先队列(priority_queue)</strong></li></ul></li></ol><h1 id="priority_queue"><a class="markdownIt-Anchor" href="#priority_queue"></a> priority_queue</h1><p><em>priority_queue</em>，优先队列，底层采用 <strong>堆</strong> 实现，队首元素是优先级最高的那一个。在 <code>queue</code> 头文件中。</p><p><code>priority_queue</code> 的定义、元素访问、常用函数基本相同。</p><p><strong>priority_queue 优先级设置：</strong></p><ol><li><p><strong>基本数据类型的优先级设置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq; <span class="comment">//默认大根堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt; pq;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; pq;</span><br></pre></td></tr></table></figure><ul><li>第二个参数填写的是来承接底层数据结构堆的容器，一般是填 <code>vector&lt;typename&gt;</code></li><li>第三个参数对第一个参数的比较类：<code>less&lt;int&gt;</code> 表示数字大的优先级越大，而 <code>greater&lt;int&gt;</code> 表示数字小的优先级越大</li></ul></li><li><p><strong>结构体的优先级设置</strong></p><ul><li>结构体的优先级设置一般通过 <strong>重载 &lt;</strong> 来实现：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &gt; 会出错，重载 &lt; 可以等价于重载 &gt;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (fruit a, fruit b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.price &lt; b.price; <span class="comment">// 大根堆</span></span><br><span class="line">        <span class="comment">// return a.price &gt; b.price;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>也可以构造 <code>priority_queue</code> 时添加一个类似于 <code>cmp</code> 的结构体</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(fruit a, fruit b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 小根堆</span></span><br><span class="line">        <span class="keyword">return</span> a.price &gt; b.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;fruit, <span class="built_in">vector</span>&lt;fruit&gt;, cmp &gt; pq;</span><br></pre></td></tr></table></figure></li></ol><h1 id="stack"><a class="markdownIt-Anchor" href="#stack"></a> stack</h1><p><em>stack</em>，栈，先进后出（FILO）的数据结构。引入头文件 <code>stack</code>。</p><ol><li><p><strong>stack 定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure></li><li><p><strong>stack 内元素的访问</strong></p><p><code>stack</code> 只能通过 <code>top()</code> 来访问栈顶元素</p></li><li><p><strong>stack 常用函数</strong></p><p>(1) <code>push(x)</code>：将 x 入栈</p><p>(2) <code>top()</code>：获得栈顶元素</p><p>(3) <code>pop()</code>：弹出栈顶元素</p><p>(4) <code>empty()</code>：判断 <code>stack</code> 是否为空</p><p>(5) <code>size()</code>：返回 <code>stack</code> 内元素的个数</p></li></ol><h1 id="pair"><a class="markdownIt-Anchor" href="#pair"></a> pair</h1><p><em>pair</em>，可以理解为一个具有两个元素的简单结构体。引入头文件 <code>utility</code>（<code>map</code> 头文件已添加）。</p><ol><li><p><strong>pair 的定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;typename1, typename2&gt; name;</span><br><span class="line">pair&lt;typename1, typename2&gt; name(first, second);</span><br></pre></td></tr></table></figure><p>也可以临时建立 <code>pair</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">"name"</span>, <span class="string">"Eason"</span>);</span><br><span class="line">make_pair(<span class="string">"name"</span>, <span class="string">"Eason"</span>); <span class="comment">//自带函数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>pair 元素的访问</strong></p><p><code>pair</code> 只有两个元素：<code>first</code> 和 <code>second</code>，只需要按正常结构体访问即可。</p></li><li><p><strong>pair 常用函数</strong></p><p><strong>比较操作符</strong>：<code>pair</code> 类型数据之间可以直接使用 <code>==、!=、&lt;、&lt;=、&gt;、&gt;=</code> 比较大小，比较规则是 <strong>先 first 再 second</strong></p></li><li><p><strong>pair 常见用途</strong></p><ul><li>代替二元结构体</li><li>可以直接插入 <code>map</code></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2021/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
      <url>/2021/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树的定义"><a class="markdownIt-Anchor" href="#树的定义"></a> 树的定义</h1><p>树（<em>tree</em>）是包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>≥</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(n \ge 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 个结点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 条边的有穷集，其中：</p><ul><li>每个元素成为结点 (<em>node</em>)，只有有限个子结点或无子结点</li><li>有一个特定的结点（无父结点）称为根结点 (<em>root</em>)</li><li>每一个非根节点有且只有一个父节点</li><li>除了根节点外，每个子节点可以分为多个不相交的子树 (<em>subtree</em>)</li><li>树里面没有环路 (<em>cycle</em>)</li><li>树没有结点的时候称为空树 (<em>empty tree</em>)</li></ul><p>连通、边数等于顶点数减 1 的结构一定是一棵树</p><h1 id="术语"><a class="markdownIt-Anchor" href="#术语"></a> 术语</h1><ul><li><strong>结点的度(degree)</strong>：一个结点含有的子树的个数称为该节点的度</li><li><strong>树的度</strong>：一棵树中，最大的结点度称为树的度</li><li><strong>叶结点</strong>：又称 <strong>终端结点</strong>，度为零的结点</li><li><strong>分支结点</strong>：又称 <strong>非终端结点</strong>，度不为零的结点</li><li><strong>兄弟结点</strong>：具有相同父结点的节点互称为兄弟结点；</li><li><strong>层次(layer)</strong>：从根开始定义起，根为第1层，根的子结点为第2层，以此类推</li><li><strong>深度(depth)</strong>：对于任意节点 i，i 的深度为从根到 i 的唯一路径长，根的深度为 0</li><li><strong>高度(height)</strong>：对于任意节点 i，i 的高度为从 i 到一片树叶的最长路径长，所有树叶的高度为 0</li><li><strong>祖先</strong>：从根到该结点所经分支上的所有结点</li><li><strong>子孙</strong>：以某结点为根的子树中任一结点都称为该结点的子孙</li><li><strong>森林(forest)</strong>：由 m（m&gt;=0）棵互不相交的树的集合称为森林；</li></ul><h1 id="种类"><a class="markdownIt-Anchor" href="#种类"></a> 种类</h1><ul><li><strong>无序树</strong>：树中任意结点的子结点之间没有顺序关系，也称为 <strong>自由树</strong><ul><li>无回路的连通图</li></ul></li><li><strong>有序树</strong>：树中任意结点的子结点之间有顺序关系</li><li><strong>二叉树</strong>：每个结点最多含有两个子树的树称为二叉树<ul><li><strong>完全二叉树</strong>：对于一棵二叉树，假设其深度为 d（d&gt;1）。除了第 d 层外，其它各层的节点数目均已达最大值，且第 d 层所有节点从左向右连续地紧密排列</li><li><strong>满二叉树</strong>：所有叶节点都在最底层的完全二叉树</li><li><strong>二叉查找树</strong>、<strong>AVL 树</strong></li><li><strong>哈夫曼树 (Huffman)</strong>：带权路径最短的二叉树，又称最优二叉树</li><li><strong>B 树</strong>：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="/2021/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"/>
      <url>/2021/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="堆的定义"><a class="markdownIt-Anchor" href="#堆的定义"></a> 堆的定义</h1><p><strong>堆（Heap）</strong> 是通常是一个可以被看作 <strong>完全二叉树</strong> 的 <strong>数组</strong> 对象。总是满足以下性质：</p><ul><li><p>堆中某个结点的值总是不大于或不小于其父结点的值</p><ul><li>不大于：大根堆；不小于：小根堆</li></ul></li><li><p>堆总是一棵完全二叉树</p><ul><li><p>具有 n 个结点，深度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>k</mi><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lfloor log_2k \rfloor + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p></li><li><p>根据结点编号可以得出父结点、左右孩子</p></li></ul></li></ul><p>堆虽然是数组对象，但是它是非线性数据结构，相当于一维数组，有两个直接后继。对于任意结点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i \in[1, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span></p><ul><li>若 i = 1，则结点 i 是二叉树的根，无双亲；若 i &gt;= 1，则双亲是 i/2</li><li>若 2i &gt; n，则无左孩子，否则左孩子是 2i</li><li>若 2i + 1 &gt; n，则无右孩子，否则右孩子是 2i + 1</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> heap[maxn], n = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>i 也可以是 0 基的，则对应的双亲、左右孩子变为：(i - 1)/2、2i + 1、2i + 2</p><h1 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h1><p>堆的基本操作有：调整成堆（向下、向上）、建堆、插入、删除。下面以大根堆为例。</p><h2 id="向下调整"><a class="markdownIt-Anchor" href="#向下调整"></a> 向下调整</h2><p>总是将当前结点 V 与它的左右孩子进行比较，假如存在比 V 大的孩子，则将最大的孩子与 V 进行交换；交换完毕后，继续让结点 V 与孩子比较，直至 V 比它的孩子都大或者没有孩子了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = low, j = low * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">1</span> &lt;= high &amp;&amp; heap[j + <span class="number">1</span>] &gt; heap[j]) &#123;</span><br><span class="line">j = j + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (heap[j] &gt; heap[i]) &#123;</span><br><span class="line">swap(heap[j], heap[i]);</span><br><span class="line">i = j;</span><br><span class="line">j = <span class="number">2</span> * i;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="向上调整"><a class="markdownIt-Anchor" href="#向上调整"></a> 向上调整</h2><p>从最下面的叶子结点开始往上调整：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = high, j = high / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (j &gt;= low) &#123;</span><br><span class="line"><span class="keyword">if</span> (heap[j] &lt; heap[i]) &#123;</span><br><span class="line">swap(heap[j], heap[i]);</span><br><span class="line">i = j;</span><br><span class="line">j = i / <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="建堆"><a class="markdownIt-Anchor" href="#建堆"></a> 建堆</h2><p>建堆的过程一般采用的向下调整的方式。假设有 n 个元素，由于完全二叉树的叶子结点为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⌈</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil n/2 \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌉</span></span></span></span>，因此下标从在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mo stretchy="false">⌊</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, \lfloor n/2 \rfloor]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">⌊</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span><span class="mclose">]</span></span></span></span> 的都是非叶子结点，因此可以从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⌊</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor n/2 \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span></span></span></span> 倒着枚举结点 i，进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span> 的调整。</p><ul><li>倒着枚举可以保证当前子树的根结点是最大值，使得建堆正确</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">downAdjust(i, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="删除堆顶"><a class="markdownIt-Anchor" href="#删除堆顶"></a> 删除堆顶</h2><p>删除堆顶较为简单，只需要将最后一个元素覆盖堆顶，然后重新向下调整堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">heap[<span class="number">1</span>] = heap[n--];</span><br><span class="line">downAdjust(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h2><p>在向上调整的基础上，可以很容易实现插入元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">heap[++n] = x;</span><br><span class="line">upAdjust(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul><h1 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h1><ul><li>堆排序：每次取出根结点，就能得到一个有序列了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> c++ </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态链表</title>
      <link href="/2021/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>静态链表：需要预先分配一个较大的空间，但在作为线性表的插入和删除操作时不需移动元素，仅需修改指针，故仍具有链式存储结构的主要优点。</p><p>静态链表的实现原理是 hash，即通过建立一个结构体数组，并令数组的下标直接表示结点的地址，来达到直接访问数组中的元素就能访问结点的效果。</p><ul><li>由于结点的访问十分方便，因此静态链表不需要头结点</li></ul><p>若结点的地址是比较小的整数，就可以直接使用静态链表</p><h1 id="通用解题步骤"><a class="markdownIt-Anchor" href="#通用解题步骤"></a> 通用解题步骤</h1><ol><li><strong>定义链表</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> address;</span><br><span class="line"><span class="keyword">typename</span> data;</span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">xxx; <span class="comment">//某个结点的性质</span></span><br><span class="line">&#125; nodes[maxn];</span><br></pre></td></tr></table></figure><ul><li>预留了一个 xxx来适应不同的题目（例如可以设置为结点是否为链表上的一个结点）</li></ul><ol start="2"><li><strong>初始化</strong>：一般是对 xxx 初始化，将其定义为正常情况下达不到的数字（一般是小于所有能达到的数字）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">nodes[i].xxx = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>标记</strong>：题目一般是会给出一条链表的首结点的地址，这一步我们对结点的 xxx 进行标记，同时计数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p = head, count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">xxx = <span class="number">1</span>;</span><br><span class="line">count++;</span><br><span class="line">p = nodes[p].next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>排序</strong>：使用静态链表的采用直接地址映射的方式，这使得有效结点的下标并不连续，因此可以将有效结点移到数组左端</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a.xxx == <span class="number">-1</span> || b == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> a.xxx &gt; b.xxx;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 升序</span></span><br><span class="line"><span class="keyword">return</span> a.data &lt; b.data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>经过了 4 的排序，链表中的有效结点都已经在数组的左端了，并且按照数组的 data 进行排序，可以根据题目处理了</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2021/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2021/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集定义"><a class="markdownIt-Anchor" href="#并查集定义"></a> 并查集定义</h1><p>并查集是一种树型的数据结构，用于处理一些不相交集合（disjoint sets）的合并及查询问题。常常在使用中以森林来表示。</p><ul><li>名字取自：Union、Find、Set 三个单词，Union-Find Disjoint Sets。</li></ul><p>并查集的实现就是用一个数组：<code>father[]</code></p><ul><li><code>father[i]</code> 表示元素 i 的父亲结点，而父亲结点本身也是这个集合的元素（1 &lt;= i &lt;= N）</li><li>若 <code>father[i] == i</code> 则说明元素 i 是该集合的根结点</li><li>对同一个集合而言，只有一个根节点，将其作为该集合的标识</li></ul><p>此外，并查集的实现也可以用一个 <code>Map</code> 来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; father;</span><br></pre></td></tr></table></figure><p>并查集产生的<strong>每一个集合都是一棵树</strong></p><h1 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h1><p>并查集的使用需要先初始化 father 数组，然后再根据需要进行查找或者合并的操作。</p><h2 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h2><p>一开始，每个元素都是独立的一个集合，因此所有的 <code>father[i] = i</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    father = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h2><p>由于一个集合只有一个根结点，因此查找操作就是根据给定的结点寻找其根结点的过程，可以使用<strong>递推/递归</strong>的方式，思路都一样：<strong>反复寻找父亲结点，直至找到根节点</strong>（<code>father[i] = i</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == father[x]) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findFather(father[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并"><a class="markdownIt-Anchor" href="#合并"></a> 合并</h2><p>根据给定的两个元素，将其所在的集合合并，步骤如下：</p><ol><li>判断给定的两个元素 a、b 是否属于同一个集合，用查找找出根结点 faA、faB，判断是否相同，若相同则直接结束；否则进入下一步，将两个集合合并</li><li>根据 1 中获得的两个根结点 faA、faB，只需要将其中一个的父亲结点指向另一个结点即可，<code>father[faA] = faB</code> 或者 <code>father[faB] = faA</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = find(a);</span><br><span class="line">    <span class="keyword">int</span> faB = find(b);</span><br><span class="line">    <span class="keyword">if</span> (faA != faB) &#123;</span><br><span class="line">        father[faA] = faB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数"><a class="markdownIt-Anchor" href="#计数"></a> 计数</h2><p>我们可以通过遍历 <code>father[]</code> 来获得集合的个数，但是效率较低。最高效的方法是维护一个变量 <code>count</code>，初始化成  <code>father[]</code> 的大小，然后每次 <code>union()</code> 成功后减一，便可高效计数。</p><h1 id="路径压缩"><a class="markdownIt-Anchor" href="#路径压缩"></a> 路径压缩</h1><p>并查集没有优化的话，在极端情况下效率很低，为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，退化为链式树。</p><p>由于 <code>find</code> 函数就是为了找到根结点，因此我们可以将 <code>father</code> 优化，使其直接指向根结点，将查找操作时间复杂度降低到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p><img alt="路径压缩" data-src="assets/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9.jpg" class="lazyload"></p><p>路径压缩的步骤如下：</p><ol><li>按原先的方法获取 x 的根结点 r</li><li>重新从 x 开始走一遍寻找根结点的过程，把路径上经过的所有结点的父亲全部改为根结点 r</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = x;</span><br><span class="line">    <span class="keyword">while</span> (x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (a != father[a]) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a;</span><br><span class="line">        a = father[a];</span><br><span class="line">        father[temp] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == father[x]) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> f = find(father[x]);</span><br><span class="line">        father[x] = f;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然在 <code>find</code> 的过程中进行了路径压缩，但是 <code>find</code> 的均摊效率近乎为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h1 id="并查集的应用"><a class="markdownIt-Anchor" href="#并查集的应用"></a> 并查集的应用</h1><p>LeetCode 399.除法求值：</p><p><img alt="image-20210404111642646" data-src="assets/image-20210404111642646.png" class="lazyload"></p><p>这个其实是一个图问题：给定图中的一些点（变量），以及某些边的权值（两个变量的比值），试对任意两点（两个变量）求出其路径长（两个变量的比值）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> equationSize = equations.size();</span><br><span class="line"></span><br><span class="line">        UnionFind unionFind = <span class="keyword">new</span> UnionFind(<span class="number">2</span> * equationSize);</span><br><span class="line">        <span class="comment">// 第 1 步：预处理，将变量的值与 id 进行映射，使得并查集的底层使用数组实现，方便编码</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span> * equationSize);</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equationSize; i++) &#123;</span><br><span class="line">            List&lt;String&gt; equation = equations.get(i);</span><br><span class="line">            String x = equation.get(<span class="number">0</span>);</span><br><span class="line">            String y = equation.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(x)) &#123;</span><br><span class="line">                map.put(x, id++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(y)) &#123;</span><br><span class="line">                map.put(y, id++);</span><br><span class="line">            &#125;</span><br><span class="line">            unionFind.union(map.get(x), map.get(y), values[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> querySize = queries.size();</span><br><span class="line">        <span class="keyword">double</span>[] ans = <span class="keyword">new</span> <span class="keyword">double</span>[querySize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; querySize; i++) &#123;</span><br><span class="line">            String x = queries.get(i).get(<span class="number">0</span>);</span><br><span class="line">            String y = queries.get(i).get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            Integer id1 = map.get(x);</span><br><span class="line">            Integer id2 = map.get(y);</span><br><span class="line">            <span class="keyword">if</span> (id1 == <span class="keyword">null</span> || id2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ans[i] = -<span class="number">1.0</span>d;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[i] = unionFind.isConnected(id1, id2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span>[] weight;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">this</span>.weight = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                weight[i] = <span class="number">1.0</span>d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">            <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">                parent[rootX] = rootY;</span><br><span class="line">                <span class="comment">// 这里需要推导一下</span></span><br><span class="line">                weight[rootX] = weight[y] * value / weight[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (x != parent[x]) &#123;</span><br><span class="line">                <span class="keyword">int</span> origin = parent[x];</span><br><span class="line">                parent[x] = find(parent[x]);</span><br><span class="line">                weight[x] *= weight[origin];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">            <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootX == rootY) &#123;</span><br><span class="line">                <span class="keyword">return</span> weight[x] / weight[y];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1.0</span>d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AVL 树</title>
      <link href="/2021/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AVL%20%E6%A0%91/"/>
      <url>/2021/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AVL%20%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="avl-树的定义"><a class="markdownIt-Anchor" href="#avl-树的定义"></a> AVL 树的定义</h1><p>AVL 树本质上是：<strong>带了平衡功能的二叉查找树</strong>，它的特点是：</p><ul><li>是一棵二叉查找树</li><li>带有平衡条件：每个结点的左右子树的高度之差的绝对值（<strong>平衡因子</strong>）最多为 1。<ul><li>平衡二叉树上所有结点的平衡因子只可能是 -1，0 或 1。</li></ul></li><li>每次插入元素之后仍然保持 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的高度</li></ul><p>AVL 树得名于它的发明者 G. M. Adelson-Velsky 和 E. M. Landis，他们在1962年的论文《An algorithm for the organization of information》中发表了它。</p><h1 id="基本结构"><a class="markdownIt-Anchor" href="#基本结构"></a> 基本结构</h1><p>由于需要得到每个结点的平衡因子，因此需要知道结点的高度，因此比 BST 的基本结构多了一个新变量 Height：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value, height;</span><br><span class="line">    Node left, right;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.height = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单函数"><a class="markdownIt-Anchor" href="#简单函数"></a> 简单函数</h2><ul><li><p>获取结点所在子树的高度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>计算平衡因子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getHeight(root.left) - getHeight(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更新 height</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    root.height = Math.max(root.left.height, root.right.height) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h1><p>AVL 树的基本操作：查找、插入、建树、删除，除此之外还有 AVL 旋转</p><h2 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h2><p>由于 AVL 树仍然是一颗 BST，因此查找方式相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(Node root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == root.value) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; root.value) &#123;</span><br><span class="line">        <span class="keyword">return</span> search(root.left, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> search(root.right, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="avl-旋转"><a class="markdownIt-Anchor" href="#avl-旋转"></a> AVL 旋转</h2><h3 id="左旋left-rotation"><a class="markdownIt-Anchor" href="#左旋left-rotation"></a> 左旋（Left Rotation）</h3><p><img alt="image-20210402142606500" data-src="assets/image-20210402142606500.png" class="lazyload"></p><ul><li>B 代替 A 作为根节点，调整后仍然是 AVL</li></ul><p>调整步骤分为三个步骤：</p><ol><li>让 B 的左子树成为 A 的右子树</li><li>让 A 成为 B 的左子树</li><li>将 B 设置为 根节点</li></ol><p><img alt="image-20210402143416212" data-src="assets/image-20210402143416212.png" class="lazyload"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRotation</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Node temp = root.right;</span><br><span class="line">    root.right = temp.left;</span><br><span class="line">    temp.left = root;</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="右旋right-rotation"><a class="markdownIt-Anchor" href="#右旋right-rotation"></a> 右旋（Right Rotation）</h3><p>与左旋互为镜像，两者互为逆操作</p><p><img alt="image-20210402143643608" data-src="assets/image-20210402143643608.png" class="lazyload"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightRotation</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Node temp = root.left;</span><br><span class="line">    root.left = temp.right;</span><br><span class="line">    temp.right = root;</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h2><p>可以证明：<strong>只要把最靠近插入结点的失衡结点调整到正常，路径上的所有结点就都会平衡</strong></p><p>假设最靠近插入结点的失衡结点是 A，显然它的平衡因子只可能是 2 / -2，这两种情况完全对称，因此下面以平衡因子为 2 做例子。</p><p>若结点 A 的平衡因子是 2，因此以 A 为根节点的子树只有两种形态：LL、LR</p><p><img alt="image-20210402145602058" data-src="assets/image-20210402145602058.png" class="lazyload"></p><ul><li>左孩子平衡因子是 1 为 LL 型，-1 为 LR 型</li></ul><p>如何调整这两种树型，才能使树平衡？</p><ol><li><p>LL 型：容易看出，以 A 作为 root 进行右旋，便可达到平衡</p><p><img alt="image-20210402150103991" data-src="assets/image-20210402150103991.png" class="lazyload"></p></li><li><p>LR 型：由于左旋、右旋互为逆操作，而 LL 和 LR 在忽略根节点 A 的时候也是对称的，因此可以先将 LR 型转化为 LL 型，即：</p><ol><li>先以 C 为根节点进行左旋</li><li>然后再以 A 为根节点进行右旋</li></ol><p><img alt="image-20210402150419637" data-src="assets/image-20210402150419637.png" class="lazyload"></p></li></ol><p>若 A 的平衡因子为 -2，则也有两种树型：RR、RL</p><p><img alt="image-20210402150623474" data-src="assets/image-20210402150623474.png" class="lazyload"></p><p>可以看出与 RR、RL 对称，因此调整的原理也对称</p><p>因此调整方法汇总如下：（BF 表示平衡因子 Balance Factor）</p><table><thead><tr><th style="text-align:center">树型</th><th style="text-align:center">判定条件</th><th style="text-align:center">调整方法</th></tr></thead><tbody><tr><td style="text-align:center">LL</td><td style="text-align:center">BF(root) = 2，BF(root.left) = 1</td><td style="text-align:center">对 root 右旋</td></tr><tr><td style="text-align:center">LR</td><td style="text-align:center">BF(root) = 2，BF(root.left) = -1</td><td style="text-align:center">先对 root.left 左旋，再对 root 右旋</td></tr><tr><td style="text-align:center">RR</td><td style="text-align:center">BF(root) = -2，BF(root.right) = -1</td><td style="text-align:center">对 root 左旋</td></tr><tr><td style="text-align:center">RL</td><td style="text-align:center">BF(root) = -2，BF(root.right) = 1</td><td style="text-align:center">先对 root.right 右旋，再对 root 左旋</td></tr></tbody></table><p>在 BST 的插入操作的基础上增加平衡操作，由于需要从插入的结点开始从下往上判断结点是否失衡，因此在每个 insert 函数之后需要更新当前子树的 height，并根据树型进行调整：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; root.value) &#123;</span><br><span class="line">        insert(root.left, x);</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        <span class="keyword">if</span> (getBalanceFactor(root) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getBalanceFactor(root.left) == <span class="number">1</span>) &#123;</span><br><span class="line">                rightRotation(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getBalanceFactor(root.right) == -<span class="number">1</span>) &#123;</span><br><span class="line">                leftRotation(root.left);</span><br><span class="line">                rightRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(root.right, x);</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        <span class="keyword">if</span> (getBalanceFactor(root) == -<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getBalanceFactor(root.right) == -<span class="number">1</span>) &#123;</span><br><span class="line">                leftRotation(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getBalanceFactor(root.left) == <span class="number">1</span>) &#123;</span><br><span class="line">                rightRotation(root.right);</span><br><span class="line">                leftRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建树"><a class="markdownIt-Anchor" href="#建树"></a> 建树</h2><p>有了插入操作的基础，AVL 的建立变得十分简单，只需要依次插入即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">create</span><span class="params">(<span class="keyword">int</span>[] values)</span> </span>&#123;</span><br><span class="line">    Node root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : values) &#123;</span><br><span class="line">        insert(root, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h2><p>查找、插入和删除在<strong>平均和最坏情况下都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡塔兰数（catalan）</title>
      <link href="/2021/04/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0%EF%BC%88catalan%EF%BC%89/"/>
      <url>/2021/04/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0%EF%BC%88catalan%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>卡塔兰数</strong>是组合数学中一个常在各种计数问题中出现的数列。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>n</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mi mathvariant="normal">，</mi><mi>C</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup><mo>−</mo><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mfrac><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">Catalan(0) = 1，Catalan(n) = C^n_{2n}-C^{n+1}_{2n} = \frac{C^n_{2n}}{n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9613919999999999em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1205469999999997em;vertical-align:-0.256439em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4435610000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.256439em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.1296600000000003em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>为了更快地计算，又得到：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>n</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mi mathvariant="normal">，</mi><mi>C</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mn>4</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></mfrac><mi>C</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Catalan(0) = 1，Catalan(n+1) = \frac{4n+2}{n+2}Catalan(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">catalan</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        c = c * (<span class="number">4</span> * i + <span class="number">2</span>) / (i + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1、1、2、5、14、42、132、429……</li></ul><h1 id="理解应用"><a class="markdownIt-Anchor" href="#理解应用"></a> 理解应用</h1><ol><li><p><strong>出栈次序问题</strong></p><p>一个无穷大栈的进栈序列为1,2,3,…n，有多少个不同的出栈序列?</p></li><li><p><strong>找零钱（找一半）</strong></p><p>有 2n 个人排成一行进入剧场。入场费 5 元。其中只有 n 个人有一张 5 元钞票，另外 n 人只有 10 元钞票，剧院无其它钞票，问有多少中方法使得只要有 10 元的人买票，售票处就有 5 元的钞票找零？</p></li><li><p><strong>三角网格</strong></p><p>形如这样的直角三角形网格，从左上角开始，只能向右走和向下走，问总共有多少种走法？</p><p><img alt data-src="https://bkimg.cdn.bcebos.com/pic/83025aafa40f4bfbeb577fbc0d4f78f0f6361856?x-bce-process=image/resize,m_lfit,w_220,limit_1/format,f_auto" class="lazyload"></p></li><li><p><strong>括号排列</strong></p><p>矩阵连乘，共有（n+1）项，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？或者说：有n对括号，可以并列或嵌套排列，共有多少种情况？</p></li><li><p><strong>球盒问题</strong></p><p>球分两种颜色，黑色和白色分别各有n只，盒子数量和球的个数相同，每个盒子里面只能放一只球，并且必须满足如下限制,即每一个白球必须和一只黑球配对（白球在黑球前，<strong>允许嵌套</strong>）。</p><p>例.用0表示白球，1表示黑球，则：</p><p>0011，010101，001011合法。</p><p>1100，101010，010110不合法。</p></li><li><p><strong>最适合理解的模型</strong></p><p>n个0和n个1组成一个2n位的2进制数，要求从左到右扫描时，1的累计数始终都<strong>小于等于</strong>0的累计数，求满足条件的数有多少？</p></li></ol><h2 id="理解方式"><a class="markdownIt-Anchor" href="#理解方式"></a> 理解方式</h2><table><thead><tr><th>模型</th><th>事件1</th><th>事件2</th></tr></thead><tbody><tr><td>(1)</td><td>入栈</td><td>出栈</td></tr><tr><td>(2)</td><td>用5元支付</td><td>用10元支付</td></tr><tr><td>(3)</td><td>向下走</td><td>向右走</td></tr><tr><td>(4)</td><td>左括号</td><td>右括号</td></tr><tr><td>(5)</td><td>0</td><td>1</td></tr><tr><td>(6)</td><td>0</td><td>1</td></tr></tbody></table><ul><li><strong>同列</strong>事件可视为<strong>等价</strong>，且在题目要求中<strong>事件1</strong>的<strong>次数/大小</strong>需要<strong>始终大于事件2</strong>。</li></ul><p>观察模型 6：在2n位上填入n个0的方案数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">C^n_{2n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.931438em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span></span> 。而从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">C^n_{2n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.931438em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span></span> 中减去不符合要求的方案数即为所求答案。</p><p>在从左往右扫时，必然会在某一个奇数位 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>p</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2p+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 上首先出现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个 1，和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 个 0</p><p>此后的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mi>p</mi><mo>+</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2p+2, 2n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>上的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi><mi mathvariant="normal">−</mi><mo stretchy="false">(</mo><mn>2</mn><mi>p</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2n−(2p+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 位有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">−</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">n−p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord mathdefault">p</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">−</mi><mi>p</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">n−p−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord mathdefault">p</span><span class="mord">−</span><span class="mord">1</span></span></span></span> 个1。如若把后面这部分 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi><mi mathvariant="normal">−</mi><mo stretchy="false">(</mo><mn>2</mn><mi>p</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2n−(2p+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 位的 1 与 0 互换，使之成为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">−</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">n−p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord mathdefault">p</span></span></span></span> 个 1，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">−</mi><mi>p</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">n−p−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord mathdefault">p</span><span class="mord">−</span><span class="mord">1</span></span></span></span> 个 0，结果得 1 个由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个 1 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">n−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">1</span></span></span></span> 个 0 组成的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span></span></span></span> 位数，<strong>即一个不合法的方案必定对应着一个由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个 1 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个 0 组成的一个排列</strong>。</p><p>于是，不合法的方案数就可以写作：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">C^{n+1}_{2n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.120547em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span></span></span></span></p><p>所以</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup><mo>−</mo><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mfrac><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">Catalan(n) = C^n_{2n}-C^{n+1}_{2n} = \frac{C^n_{2n}}{n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9613919999999999em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1205469999999997em;vertical-align:-0.256439em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4435610000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.256439em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.1296600000000003em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h1 id="类似题目"><a class="markdownIt-Anchor" href="#类似题目"></a> 类似题目</h1><ul><li><p>将多边行划分为三角形问题。将一个凸多边形区域分成三角形区域的方法数?</p></li><li><p>有 N 个节点的二叉树共有多少种情形？</p><ul><li>有 N 个结点且不同的 BST</li></ul></li><li><p>一位大城市的律师在她住所以北n个街区和以东n个街区处工作。每天她走2n个街区去上班。如果他</p><p>从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉查找树（BST）</title>
      <link href="/2021/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
      <url>/2021/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>二叉查找树（Binary Search Tree，BST），（又：二叉搜索树，二叉排序树）是一中特殊的二叉树：</p><ul><li>要么是一棵空树</li><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树</li></ul><p>二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势。</p><h1 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h1><p>BST 的基本操作有：查找、插入、建树、删除。</p><h2 id="结点数据结构"><a class="markdownIt-Anchor" href="#结点数据结构"></a> 结点数据结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(Node root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == root.data) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; root.data) &#123;</span><br><span class="line">        <span class="keyword">return</span> search(root.left, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> search(root.right, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(Node root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node(x);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == root.data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; root.data) &#123;</span><br><span class="line">        <span class="keyword">return</span> insert(root.left, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> insert(root.right, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建树"><a class="markdownIt-Anchor" href="#建树"></a> 建树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">create</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">    Node root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d : data) &#123;</span><br><span class="line">        insert(root, d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h2><p>BST 的删除比较麻烦，下面有一种较为简易的方法：</p><ul><li><strong>叶子节点</strong>：直接删除，不影响原树。</li><li><strong>仅仅有左或右子树的节点</strong>：节点删除后，将它的左子树或右子树整个移动到删除节点的位置就可以，子承父业。</li><li><strong>既有左又有右子树的节点</strong>：找到须要删除的节点p的直接前驱或者直接后继s，用s来替换节点p，然后再删除节点s。<ul><li><strong>前驱</strong>：BST 中比结点权值小的最大结点</li><li><strong>后继</strong>：BST 中比结点权值大的最小结点</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找最大权值结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findMax</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找最小权值结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findMin</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(Node root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.data == x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node pre = findMax(root.left);</span><br><span class="line">            root.data = pre.data;</span><br><span class="line">            <span class="keyword">return</span> delete(root.left, pre.data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node next = findMin(root.right);</span><br><span class="line">            root.data = next.data;</span><br><span class="line">            <span class="keyword">return</span> delete(root.right, next.data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.data &lt; x) &#123;</span><br><span class="line">        <span class="keyword">return</span> delete(root.left, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> delete(root.right, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h2><p>不论哪一种操作，所花的时间都和树的高度成正比。因此，如果共有n个元素，那么平均每次操作需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的时间。</p><ul><li>但是在最坏的情况下，BST 是链式的，此时退化为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul><h1 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h1><p>BST 的中序遍历是有序的。</p><h1 id="卡塔兰数catalan"><a class="markdownIt-Anchor" href="#卡塔兰数catalan"></a> 卡塔兰数（catalan）</h1><p>n 个节点的 BST 的数量符合 catalan：</p><p>易知：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>0</mn></msub><mo>=</mo><mn>1</mn><mi mathvariant="normal">，</mi><msub><mi>C</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">C_0 = 1，C_1 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p>假设以 i（1 &lt;= i &lt;= n）为根节点，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 构建左子树，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i+1, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span> 构建右子树，而他们也可以构造不同的 BST，因此得到以下递归表达式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>n</mi></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>∗</mo><msub><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_n = \sum ^N _{i=1} C_{i-1} * C_{n-i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.106005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>以上推导出的公式在数学上成为卡塔兰数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">C_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，有以下通项公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>0</mn></msub><mo>=</mo><mn>1</mn><mi mathvariant="normal">，</mi><msub><mi>C</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mfrac><mrow><mn>4</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></mfrac><msub><mi>C</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">C_0 = 1，C_{n+1} = \frac{4n+2}{n+2}C_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><ul><li>1、1、2、5、14、42、132、429……</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numOfBST</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        c = c * <span class="number">2</span> * (<span class="number">2</span> * i + <span class="number">1</span>) / (i + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯法</title>
      <link href="/2021/03/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
      <url>/2021/03/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>**<em>回溯法（Backtracking）<em><strong>：基本做法是</strong>搜索</em></em>，是一种避免不必要搜索的穷举式搜索法。</p><ul><li><p>有”通用的解题法“之称</p></li><li><p>按<strong>深度优先</strong>策略，从根结点出发搜索解空间树</p></li><li><p>根据剪枝函数来避免无用搜索</p></li></ul><p>回溯法设计过程：</p><ol><li>确定问题的<strong>解空间</strong><ul><li>常见解空间：<strong>排列树和子集树</strong></li></ul></li><li>确定结点的<strong>扩展规则</strong></li><li><strong>搜索</strong>解空间</li></ol><hr><p><em><strong>N 皇后问题</strong></em></p><p>要在n*n的国际象棋棋盘中放n个皇后，使任意两个皇后都不能互相攻击。皇后能吃掉同一行、同一列、同一对角线的任意棋子。</p><p>暴力法求解需遍历 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><msup><mi>n</mi><mn>2</mn></msup><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">C_{n^2}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00275em;vertical-align:-0.31942000000000004em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.38058em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.31942000000000004em;"><span></span></span></span></span></span></span></span></span></span> 种可能，过于庞大，因此使用回溯法可以大量地剪掉那些不必要的搜索。</p><p>这里以八皇后问题为例，设八个皇后为 x<sub>i</sub>，分别在第 i 行，因此解可以用一个 8 个单位的数组表示。</p><p>问题的<strong>解空间</strong>：(x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>, x<sub>4</sub>, x<sub>5</sub>, x<sub>6</sub>, x<sub>7</sub>, x<sub>8</sub>)，共有 8<sup>8</sup> 个可能，是一棵<strong>排列树</strong></p><p><strong>约束条件</strong>：可以整合成：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mi>j</mi></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">≠</mi><mi mathvariant="normal">∣</mi><mi>i</mi><mo>−</mo><mi>j</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|x_i-x_j| \neq |i-j|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">∣</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">≠</mi><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_i \neq x_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p><ul><li>不在同一列：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">≠</mi><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_i \neq x_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>；不在同一主对角线上：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>i</mi><mi mathvariant="normal">≠</mi><msub><mi>x</mi><mi>j</mi></msub><mo>−</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">x_i-i \neq x_j-j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>；不在同一负对角线上：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><mi>i</mi><mi mathvariant="normal">≠</mi><msub><mi>x</mi><mi>j</mi></msub><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">x_i+i \neq x_j+j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++)</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">abs</span><span class="params">(a[i]-a[n])</span> </span>== <span class="built_in">abs</span>(i-n) <span class="keyword">or</span> a[i]=a[n]</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用递归的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">backtrack(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k &gt; n)</span><br><span class="line">找到解，输出结果;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">a[k] = i;</span><br><span class="line"><span class="keyword">if</span> (check(a, k))</span><br><span class="line">backtrack(k + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 由于先将 a[k] 赋值，因此回溯前无需清理工作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em><strong>01背包问题</strong></em></p><p><strong>解空间</strong>：x[n] 数组，表示第 i 个物品是否选择，是一棵<strong>子集树</strong></p><p><strong>剪枝函数</strong>：</p><ul><li><p>curWeight + w[i] &gt; W，背包装不下则剪去左子树</p></li><li><p>rest + curValue &lt;= bestValue，剩余价值加上当前价值都小于最优解，因此剪去右子树</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">backtrack(<span class="keyword">int</span> k) &#123;</span><br><span class="line"><span class="keyword">if</span> (k &gt; n)</span><br><span class="line">得到一个解，输出并返回；</span><br><span class="line">rest -= values[k];</span><br><span class="line"><span class="comment">// 左子树</span></span><br><span class="line"><span class="keyword">if</span> (curWeight + weights[i] &lt; W) &#123;</span><br><span class="line">        curValue += values[k];</span><br><span class="line">            curWeight += weights[k];</span><br><span class="line">            backTrack(k+<span class="number">1</span>);</span><br><span class="line">            curValue -= values[k];</span><br><span class="line">            curWeight -= weights[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右子树</span></span><br><span class="line"><span class="keyword">if</span> (curValue + rest &gt; curBest)</span><br><span class="line">backTrack(k+<span class="number">1</span>);</span><br><span class="line">rest += values[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><hr><p><em><strong>子集和</strong></em></p><p><strong>解空间</strong>：是否选择当前数字，是一棵<strong>子集树</strong></p><p><strong>剪枝函数</strong>：</p><ul><li>sum + W[k] = M，则为一个解</li><li>sum + W[k] + W[k+1] &lt;= M，进入左子树</li><li>sum + rest - W[k] &gt;= M and sum + W[k+1] &lt;= M，进入右子树</li></ul><hr><p><em><strong>TSP</strong></em></p><p><strong>解空间</strong>：给出n个点，以0为起点，构造一个<strong>排列树</strong>，共有(n-1)!的叶子结点，每次选择剩下的元素中的一个，从根到叶结点表示一条可选路径</p><p><strong>剪枝条件</strong>：</p><ul><li>判断当前路径是否连通，连通继续，不连通剪掉</li><li>判断当前路径是否比已经求得的路径小，小于继续，大于等于剪掉</li></ul><hr><p>估值&amp;检查机制</p><ul><li>好的机制能显著地减少所生成的结点数</li><li>但往往计算量大</li><li>折衷问题：“剪枝”节约的 vs.估值检查机制消耗的</li></ul><p>回溯算法的效率很大程度依赖于：</p><ul><li>产生一个 x[k] 的时间</li><li>过程中经过检查的x[k]的个数</li><li>计算估值(约束)函数的时间代价</li></ul><p>递归的算法框架</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[n]; <span class="comment">// 解的表达式形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k &gt; n)</span><br><span class="line">获得一个解，输出;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (i = 下界; i &lt;= 上界; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (check(i)) &#123;</span><br><span class="line">a[k] = i;</span><br><span class="line">backtrack(k+<span class="number">1</span>); <span class="comment">// 深度搜索子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 回溯前的清理工作，比如将 a[k] 置为空</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法思想 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序</title>
      <link href="/2021/03/30/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/03/30/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>对一个 <strong>有向无环图(Directed Acyclic Graph，DAG)</strong> G 进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，<strong>若边 &lt;u,v&gt; ∈ E(G)，则 u 在线性序列中出现在 v 之前</strong>。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称<strong>拓扑序列</strong>。</p><h1 id="图的数据结构"><a class="markdownIt-Anchor" href="#图的数据结构"></a> 图的数据结构</h1><p>采用邻接表的形式，较为方便的进行拓扑排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; graph;</span><br></pre></td></tr></table></figure><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><p>开始时，所有入度为00 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p><p>在广度优先搜索的每一步中，我们取出队首的节点 <em>u</em>：</p><ul><li>我们将 <em>u</em> 放入答案中；</li><li>我们移除 <em>u</em> 的所有出边，也就是将 <em>u</em> 的所有相邻节点的入度减少 1。如果某个相邻节点 <em>v</em> 的入度变为 0，那么我们就将 <em>v</em> 放入队列中。</li></ul><p>在广度优先搜索的过程结束后。如果答案中包含了这 <em>n</em> 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] topologicalSort(List&lt;List&lt;Integer&gt;&gt; graph) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = graph.size();</span><br><span class="line">    <span class="keyword">int</span>[] inDegrees = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; list : graph) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">            inDegrees[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegrees[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = queue.poll();</span><br><span class="line">        ans[index++] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> adj : graph.get(u)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--inDegrees[adj] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(adj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p><ul><li><p>「未搜索」：我们还没有搜索到这个节点；</p></li><li><p>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</p></li><li><p>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</p></li></ul><p>所以我们只要在节点已完成后将其入栈。可以发现，如果我们从栈顶往栈底的顺序看，由于 u 处于栈顶的位置，那么 u 出现在所有 u 的相邻节点的前面。因此对于 u 这个节点而言，它是满足拓扑排序的要求的。</p><p>因此我们只需在 dfs 完成后将其入栈，拓扑排序就是栈顶往栈底的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; graph;</span><br><span class="line"><span class="comment">// 0 表示未搜索、1 表示搜索中、2 表示已完成</span></span><br><span class="line"><span class="keyword">int</span>[] visited;</span><br><span class="line"><span class="comment">// 因为无须出栈，直接使用数组模拟栈</span></span><br><span class="line"><span class="keyword">int</span>[] ans;</span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">boolean</span> hasCircle = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] topologicalSort(List&lt;List&lt;Integer&gt;&gt; graph) &#123;</span><br><span class="line">    <span class="keyword">this</span>.graph = graph;</span><br><span class="line">    <span class="keyword">int</span> n = graph.size();</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    index = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasCircle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    visited[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : graph.get(u)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(v);</span><br><span class="line">            <span class="keyword">if</span> (hasCircle) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">            hasCircle = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = <span class="number">2</span>;</span><br><span class="line">    ans[index--] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h1><p>两者就是 BFS、DFS 的变种，因此：</p><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>【邻接表】，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>【邻接矩阵】</li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全为1的正方形子矩阵</title>
      <link href="/2021/03/30/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%85%A8%E4%B8%BA1%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
      <url>/2021/03/30/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%85%A8%E4%B8%BA1%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 221：在一个由 <code>0</code> 和 <code>1</code> 组成的二维矩阵内，找到只包含 <code>1</code> 的<strong>最大正方形</strong>。</p><p>LeetCode 1277：统计并返回其中完全由 <code>1</code> 组成的 <strong>正方形</strong> 子矩阵的个数。</p><p>两题思想一致，都可以用动态规划的算法来解决，递推式如下：</p>\begin{equation}dp[i][j] = \begin{cases}matrix[i][j]&\mbox{if $i == 0$ or $j ==0$}\\0&\mbox{if $matrix[i][j] == 0$}\\min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])+1&\mbox{if $maxtrix[i][j] == 1$}\end{cases}\end{equation}<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n = matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][j] = matrix[i][j];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[i][j] =  Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>dp[i][j]</code>  的含义：以 <code>matrix[i][j]</code> 为右下角的所有小正方形数目之和，由于固定了右下角，所以计算一定不会重复。<ul><li>同时可以知道，dp 中的最大值就是只包含 <code>1</code> 的 <strong>最大正方形</strong> 的边长【以该单元为右下角，最多能够延展的长度】</li><li>dp 的和就是由 <code>1</code> 组成的 <strong>正方形</strong> 子矩阵的个数</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单词搜索</title>
      <link href="/2021/03/30/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
      <url>/2021/03/30/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 212：给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个单词（字符串）列表 <code>words</code>，找出所有同时在二维网格和字典中出现的单词。</p><p>单词必须按照字母顺序，通过 <strong>相邻的单元格</strong> 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p><p>示例：</p><p><img alt data-src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg" class="lazyload"></p><ul><li>输入：board = [[“o”,“a”,“a”,“n”],[“e”,“t”,“a”,“e”],[“i”,“h”,“k”,“r”],[“i”,“f”,“l”,“v”]], words = [“oath”,“pea”,“eat”,“rain”]</li><li><strong>输出</strong>：[“eat”,“oath”]</li></ul><h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1><ul><li>将 words 构建成 Trie  树，加快用于后面的匹配过程</li><li>从每个单元格开始，如果字典中存在以单元格中的字母开头的单词,则我们开始回溯探索，即 <code>backtrack(cell)</code></li><li>在递归函数 <code>backtracking(cell)</code> 调用过程中，我们探索当前单元格周围的相邻单元格（即 <code>neighborCell</code>）以进行下一个递归调用 <code>backtracking(neighborCell)</code>。在每次调用时，我们都会检查到目前为止遍历的字母序列是否与字典中的任何单词匹配，这需要借助于我们在开始时构建的 Trie 数据结构。</li></ul><h1 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h1><ul><li><p>沿着 Trie 的节点回溯，而不是在回溯的每一步，都从Trie 的根开始。</p><ul><li>将 <code>TrieNode</code> 加入 <code>backtrack</code> 的参数中，沿 Trie 的节点回溯</li></ul></li><li><p>在回溯过程中逐渐剪除 Trie 中的节点（剪枝）</p><ul><li>一旦遍历到 Trie 中的叶节点，说明已经匹配到了，就不需要再遍历它了，所以可以将其删除</li><li>在极端情况下，一旦我们找到字典中所有单词的匹配项，Trie 就会变成空的</li><li><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl90cmllX3BydW5lLnBuZw?x-oss-process=image/format,png" class="lazyload"></li></ul></li><li><p>从 Trie 中删除匹配的单词</p><ul><li>我们被要求返回所有匹配的单词，而不是潜在匹配的数量。因此，一旦到达包含单词匹配的特定 Trie 节点，我们就可以从 Trie 中删除匹配单词。</li></ul></li></ul><h1 id="源码"><a class="markdownIt-Anchor" href="#源码"></a> 源码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span>[][] board;</span><br><span class="line">TrieNode root;</span><br><span class="line">List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span>[] rowOffset = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] colOffset = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.n = board.length;</span><br><span class="line">    <span class="keyword">this</span>.m = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">this</span>.board = board;</span><br><span class="line"></span><br><span class="line">    root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.children.containsKey(ch)) &#123;</span><br><span class="line">                node = node.children.get(ch);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TrieNode newNode = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                node.children.put(ch, newNode);</span><br><span class="line">                node = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node.word = word;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.children.containsKey(board[i][j])) &#123;</span><br><span class="line">                backtrack(i, j, root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, TrieNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> letter = board[row][col];</span><br><span class="line">    TrieNode curNode = node.children.get(letter);</span><br><span class="line">    <span class="keyword">if</span> (curNode.word != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ans.add(curNode.word);</span><br><span class="line">        curNode.word = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    board[row][col] = <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> newRow = row + rowOffset[i];</span><br><span class="line">        <span class="keyword">int</span> newCol = col + colOffset[i];</span><br><span class="line">        <span class="keyword">if</span> (newRow &lt; <span class="number">0</span> || newRow &gt;= n || newCol &lt; <span class="number">0</span> || newCol &gt; m) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curNode.children.containsKey(board[newRow][newCol])) &#123;</span><br><span class="line">            backtrack(newRow, newCol, curNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历到了叶子节点</span></span><br><span class="line">    board[row][col] = letter;</span><br><span class="line">    <span class="keyword">if</span> (curNode.children.isEmpty()) &#123;</span><br><span class="line">        node.children.remove(letter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 HashMap 节约空间</span></span><br><span class="line">    HashMap&lt;Character, TrieNode&gt; children;</span><br><span class="line">    <span class="comment">// 非叶子节点 word 为 null</span></span><br><span class="line">    String word;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        children = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        word = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 回溯 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Trie 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tier字典树</title>
      <link href="/2021/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Tier%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>/2021/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Tier%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><p>Trie (发音为 “try”) 或前缀树是一种树数据结构，用于检索字符串数据集中的键。</p><p>Trie 树是一种哈希树的变种，它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。可以做到：</p><ul><li>找到具有同一前缀的全部键值。</li><li>按词典序枚举字符串的数据集。</li></ul><p>Trie 树常用于搜索引擎系统的文本词频统计，可以进行自动补全、拼写检查、拼写预测……</p><h1 id="trie-树的结点结构"><a class="markdownIt-Anchor" href="#trie-树的结点结构"></a> Trie 树的结点结构</h1><p>Trie 树是一个有根的树，其结点具有以下字段：</p><ul><li>最多 <em>R</em> 个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母。<ul><li>以下代码假定 R 为 26，小写拉丁字母的数量。</li></ul></li><li>布尔字段，以指定节点是对应键的结尾还是只是键前缀。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TrieNode[] links;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        links = <span class="keyword">new</span> TrieNode[R];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> links[ch - <span class="string">'a'</span>] != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> links[ch - <span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">char</span> ch, TrieNode node)</span> </span>&#123;</span><br><span class="line">        links[ch - <span class="string">'a'</span>] = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="trie-树的操作"><a class="markdownIt-Anchor" href="#trie-树的操作"></a> Trie 树的操作</h1><p>Trie 树中最常见的操作是键的插入、查找，前缀查询。</p><h2 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h2><p>我们通过搜索 Trie 树来插入一个键。我们从根开始搜索它对应于第一个键字符的链接。有两种情况：</p><ul><li>链接存在。沿着链接移动到树的下一个子层。算法继续搜索下一个键字符。</li><li>链接不存在。创建一个新的节点，并将它与父节点的链接相连，该链接与当前的键字符相匹配。</li></ul><p>重复以上步骤，直到到达键的最后一个字符，然后将当前节点标记为结束节点，算法完成。</p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，m 为键长</p><h1 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h1><p>每个键在 trie 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始，检查当前节点中与键字符对应的链接。有两种情况：</p><ul><li>存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。</li><li>不存在链接。若已无键字符，且当前结点标记为 <code>isEnd</code>，则返回 true。否则有两种可能，均返回 false：<ul><li>还有键字符剩余，但无法跟随 Trie 树的键路径，找不到键。</li><li>没有键字符剩余，但当前结点没有标记为 <code>isEnd</code>。也就是说，待查找键只是Trie树中另一个键的前缀。</li></ul></li></ul><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h2 id="前缀查询"><a class="markdownIt-Anchor" href="#前缀查询"></a> 前缀查询</h2><p>与查找十分相似，不过我们不需要判断 Trie 当前节点是否<code>isEnd</code>，找得到 Trie 节点就是 True</p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h2 id="java-源代码"><a class="markdownIt-Anchor" href="#java-源代码"></a> java 源代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node.containsKey(ch)) &#123;</span><br><span class="line">                node.put(ch, <span class="keyword">new</span> TrieNode());</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.get(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        node.setEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/** search a prefix or whole key in trie and */</span></span><br><span class="line">     <span class="comment">/** returns the node where search ends */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> TrieNode <span class="title">searchPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">         TrieNode node = root;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">char</span> ch : prefix.toCharArray()) &#123;</span><br><span class="line">             <span class="keyword">if</span> (node.containsKey(ch)) &#123;</span><br><span class="line">                 node = node.get(ch);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> node;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.isEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PDO(PHP 数据对象)</title>
      <link href="/2020/08/14/%E5%AD%A6%E4%B9%A0/Web/PHP/PHP-PDO/"/>
      <url>/2020/08/14/%E5%AD%A6%E4%B9%A0/Web/PHP/PHP-PDO/</url>
      
        <content type="html"><![CDATA[<p>PDO 全称 PHP Data Object，PHP 数据对象，可以用相同的函数来查询和获取数据。</p><ul><li>PDO可以应用在12种不同的数据库，而 MySQLi 只能用于 MySql</li></ul><p>从 PHP 5.1开始附带了 PDO，在 PHP 5.0 中是作为一个 PECL 扩展使用。</p><ul><li>可以直接在 php.ini 中开启相应的数据库扩展</li></ul><p>官方文档：<a href="https://www.php.net/manual/zh/book.pdo.php" target="_blank" rel="noopener">PHP 数据对象</a></p><h1 id="pdo-类"><a class="markdownIt-Anchor" href="#pdo-类"></a> PDO 类</h1><h2 id="实例化-pdo-对象"><a class="markdownIt-Anchor" href="#实例化-pdo-对象"></a> 实例化 PDO 对象</h2><p><em><strong>PDO::__construct</strong></em>：创建一个连接到请求数据库的数据库连接 PDO 实例</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PDO::__construct ( string $dsn [, string $username [, string $password [, <span class="keyword">array</span> $driver_options ]]] )</span><br></pre></td></tr></table></figure><ul><li><p>$dsn：data source name 数据源名称，包含了请求连接到数据库的信息。</p><ul><li>通常，一个 DSN 由 <em>PDO 驱动名</em>、<em>紧随其后的冒号</em>、以及<em>具体 PDO 驱动</em>的连接语法组成。</li></ul></li><li><p>$username、$password：用户名和密码</p></li><li><p>$driver_options：默认即可</p></li></ul><p>举个栗子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 设置数据源相关参数</span></span><br><span class="line">$dbms = <span class="string">'mysql'</span>;</span><br><span class="line">$host = <span class="string">'localhost'</span>;</span><br><span class="line">$port = <span class="string">'3306'</span>;</span><br><span class="line">$dbname = <span class="string">'study'</span>;</span><br><span class="line">$charset = <span class="string">'utf8'</span>;</span><br><span class="line"><span class="comment">// 冒号:后面的顺序任意，不过键值对要正确</span></span><br><span class="line">$dsn = <span class="string">"$dbms:host=$host;port=$port;dbname=$dbname;charset=$charset"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置用户名和密码</span></span><br><span class="line">$username = <span class="string">'root'</span>;</span><br><span class="line">$password = <span class="string">'root'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化 PDO</span></span><br><span class="line">$pdo = <span class="keyword">new</span> PDO($dsn, $username, $password);</span><br></pre></td></tr></table></figure><h2 id="增删改"><a class="markdownIt-Anchor" href="#增删改"></a> 增删改</h2><p>**<em>PDO::exec()<em><strong>：在一个单独的函数调用中执行一条 SQL 语句，返回</strong>受此语句影响的行数</em></em>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PDO::exec ( string $statement ) : int</span><br></pre></td></tr></table></figure><ul><li>$statement：待执行的 sql 语句</li></ul><h2 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h2><p><em><strong>PDO::query</strong></em>：执行 SQL 语句，以 <strong>PDOStatement 对象</strong>形式返回<strong>结果集</strong>。</p><p>最简单的一个使用方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PDO::query ( string $statement ) : PDOStatement</span><br></pre></td></tr></table></figure><h2 id="预处理语句"><a class="markdownIt-Anchor" href="#预处理语句"></a> 预处理语句</h2><p><em><strong>PDO::prepare</strong></em>：准备要执行的语句，并返回语句对象</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PDO::prepare ( string $statement [, <span class="keyword">array</span> $driver_options = <span class="keyword">array</span>() ] ) : PDOStatement</span><br></pre></td></tr></table></figure><p>占位符可以为：命名（<strong>:name</strong>）或问号（<strong>?</strong>），不能同时使用</p><p>常用到的 PDOStatement 方法：</p><ul><li><em><strong>bindValue</strong></em>：把一个<strong>值</strong>绑定到一个参数</li><li><em><strong>bindParam</strong></em>：绑定一个<strong>参数</strong>到指定的变量名<ul><li>通常有两个参数：$parameter（:name或者索引【1基】）和 $variable（要绑定的变量）</li></ul></li><li><em><strong>execute</strong></em>：<strong>执行</strong>一条预处理语句<ul><li>调用 bindParam() 或者 bindValue 绑定 PHP 变量到参数标记：如果有的话，通过关联参数标记绑定的变量来传递输入值和取得输出值</li><li>或传递一个只作为输入参数值的数组</li></ul></li></ul><h1 id="pdostatement-类"><a class="markdownIt-Anchor" href="#pdostatement-类"></a> PDOStatement 类</h1><p>代表一条预处理语句，并在该语句被执行后代表一个相关的结果集。</p><p>有一个只读属性：***$queryString***，为查询的语句</p><p>有着许多方法：</p><ul><li><em><strong>rowCount</strong></em>：获取查询结果的总行数</li><li><em><strong>columnCount</strong></em>：获取查询结果的总字段数</li><li><em><strong>fetch</strong></em>：从 PDOStatement 对象中，获取一条记录，同时游标下移<ul><li><em><strong>PDO::FETCH_ASSOC</strong></em>：返回一个关联数组（索引值为字段名）</li><li><em><strong>PDO::FETCH_NUM</strong></em>：返回一个索引数组</li><li><em><strong>PDO::FETCH_BOTH</strong></em>（默认）：返回一个索引为结果集列名和以0开始的列号的数组</li><li><em><strong>PDO::FETCH_OBJ</strong></em>：返回一个属性名对应结果集列名的匿名对象</li></ul></li><li><em><strong>fetchAll</strong></em>：返回一个包含结果集中所有行的数组</li><li><em><strong>fetchColumn</strong></em>：从结果集中的下一行返回单独的一列</li></ul><h1 id="pdo-相关属性"><a class="markdownIt-Anchor" href="#pdo-相关属性"></a> PDO 相关属性</h1><p><em><strong>setAttribute</strong></em>：设置一个语句属性</p><p><em><strong>getAttribute</strong></em>：取回一个数据库连接的属性</p><p>常用属性：</p><ul><li>PDO::ATTR_AUTOCOMMIT：自动提交<ul><li>0 和 1</li></ul></li><li>PDO::ATTR_CASE：结果集的大小写<ul><li>PDO::CASE_LOWER、PDO::CASE_UPPER、PDO::CASE_NATURAL</li></ul></li><li>PDO::ATTR_ERRMODE：错误模式<ul><li>PDO::ERRMODE_SILENT：静默模式（默认）</li><li>PDO::ERRMODE_WARNING：警告模式</li><li>PDO::ERRMODE_EXCEPTION：异常模式</li></ul></li></ul><h1 id="pdoexception-类"><a class="markdownIt-Anchor" href="#pdoexception-类"></a> PDOException 类</h1><p>PDOException 继承了 RuntimeException，使用方法与 PHP 中的异常一致。</p><p>修改 PDO 对象中的 PDO::ATTR_ERRMODE 为 PDO::ERRMODE_EXCEPTION，PDO 才会抛出异常。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> PDO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript DOM</title>
      <link href="/2020/08/02/%E5%AD%A6%E4%B9%A0/Web/JS/JavaScript%20DOM/"/>
      <url>/2020/08/02/%E5%AD%A6%E4%B9%A0/Web/JS/JavaScript%20DOM/</url>
      
        <content type="html"><![CDATA[<p>通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素。</p><h1 id="dom"><a class="markdownIt-Anchor" href="#dom"></a> DOM</h1><p>当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。</p><p><img alt="HTML DOM树" data-src="https://www.runoob.com/images/pic_htmltree.gif" class="lazyload"></p><p>通过 DOM，JavaScript 可以创建动态的 HTML：改变 HTML 元素、HTML 属性、CSS 样式，对事件做出响应。</p><h1 id="dom-节点"><a class="markdownIt-Anchor" href="#dom-节点"></a> DOM 节点</h1><p>在 HTML DOM 中，所有事物都是节点。DOM 是被视为节点树的 HTML。</p><ul><li>整个文档是一个文档节点</li><li>每个 HTML 元素是元素节点</li><li>HTML 元素内的文本是文本节点</li><li>每个 HTML 属性是属性节点</li><li>注释是注释节点</li></ul><p>所有 HTML 元素被定义为对象，而编程接口则是对象方法和对象属性。</p><h2 id="dom-方法"><a class="markdownIt-Anchor" href="#dom-方法"></a> DOM 方法</h2><p>你可以通过三种方法来找到 HTML 元素</p><ul><li>document.getElementById<ul><li>能够获取唯一元素</li></ul></li><li>document.getElementsByClassName<ul><li>返回的是 NodeList 对象，文档节点的集合</li></ul></li><li>document.getElementsByTagName<ul><li>返回 HTMLCollection 对象，HTML 元素的集合</li></ul></li></ul><p>对象的方法：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">removeChild()</td><td style="text-align:left">删除子节点。</td></tr><tr><td style="text-align:left">replaceChild()</td><td style="text-align:left">替换子节点。</td></tr><tr><td style="text-align:left">insertBefore()</td><td style="text-align:left">在指定的子节点前面插入新的子节点。</td></tr><tr><td style="text-align:left">createAttribute()</td><td style="text-align:left">创建属性节点。</td></tr><tr><td style="text-align:left">createElement()</td><td style="text-align:left">创建元素节点。</td></tr><tr><td style="text-align:left">createTextNode()</td><td style="text-align:left">创建文本节点。</td></tr><tr><td style="text-align:left">getAttribute()</td><td style="text-align:left">返回指定的属性值。</td></tr><tr><td style="text-align:left">setAttribute()</td><td style="text-align:left">把指定属性设置或修改为指定的值。</td></tr></tbody></table><h2 id="dom-属性"><a class="markdownIt-Anchor" href="#dom-属性"></a> DOM 属性</h2><p><em><strong>innerHTML</strong></em></p><p>获取<strong>元素内容</strong>的最简单方法是使用 innerHTML 属性。</p><ul><li>innerHTML 属性可用于获取或改变任意 HTML 元素，包括 <code>&lt;html&gt;</code> 和 <code>&lt;body&gt;</code>。</li><li>除了 innerHTML 属性，您也可以使用 childNodes 和 nodeValue 属性来获取元素的内容。</li></ul><p><em><strong>nodeName</strong></em></p><ul><li>nodeName 是<strong>只读</strong>的</li><li>元素节点的 nodeName 与<strong>标签名</strong>相同</li><li>属性节点的 nodeName 与<strong>属性名</strong>相同</li><li>文本节点的 nodeName 始终是 <strong>#text</strong></li><li>文档节点的 nodeName 始终是 <strong>#document</strong></li></ul><p>nodeName 始终包含 HTML 元素的***大写***字母标签名。</p><p><em><strong>nodeValue</strong></em></p><p>nodeValue 属性规定<strong>节点的值</strong>。</p><ul><li>元素节点的 nodeValue 是 undefined 或 null</li><li>文本节点的 nodeValue 是文本本身</li><li>属性节点的 nodeValue 是属性值</li></ul><p><em><strong>nodeType</strong></em></p><p>nodeType 属性返回<strong>节点的类型</strong>。nodeType 是只读的。</p><p>比较重要的节点类型：</p><ul><li>元素：1；属性：2；文本：3；注释：8；文档：9</li></ul><h1 id="dom-修改"><a class="markdownIt-Anchor" href="#dom-修改"></a> DOM 修改</h1><h2 id="html"><a class="markdownIt-Anchor" href="#html"></a> HTML</h2><p><em><strong>改变 HTML 输出流</strong></em></p><p>JavaScript 能够创建动态的 HTML 内容：使用 <strong>document.write()</strong> 可用于直接向 HTML 输出流写内容。</p><ul><li>绝对不要在文档(DOM)加载完成之后使用 document.write()。这会覆盖该文档。</li></ul><p><em><strong>改变 HTML 内容</strong></em></p><p>修改 HTML 内容的最简单的方法是使用 innerHTML 属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(id).innerHTML=新的 HTML</span><br></pre></td></tr></table></figure><ul><li>通过 getElementById 寻找元素，然后替换 innerHTML</li></ul><p><em><strong>改变 HTML 属性</strong></em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(id).attribute=新属性值</span><br></pre></td></tr></table></figure><ul><li>attribute 为属性名</li></ul><h2 id="dom-css"><a class="markdownIt-Anchor" href="#dom-css"></a> DOM CSS</h2><p>改变 HTML 元素的样式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(id).style.property=新样式</span><br></pre></td></tr></table></figure><ul><li>property 是要修改的样式名</li></ul><h1 id="dom-事件"><a class="markdownIt-Anchor" href="#dom-事件"></a> DOM 事件</h1><p>我们可以在事件发生时执行 JavaScript</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发生的事件 = JavaScript代码</span><br></pre></td></tr></table></figure><h2 id="html-事件"><a class="markdownIt-Anchor" href="#html-事件"></a> HTML 事件</h2><p>HTML 有许多的事件：当用户点击鼠标时、当网页已加载时、当图像已加载时、当鼠标移动到元素上时、当输入字段被改变时、当提交 HTML 表单时、当用户触发按键时……</p><ul><li><p>onload 和 onunload：用户进入/离开界面时被触发</p></li><li><p>onchange：常结合对输入字段的验证来使用</p></li><li><p>onmouseover 和 onmouseout：用户的鼠标移至 HTML 元素上方或移出元素时触发</p></li><li><p>onmousedown、onmouseup 以及 onclick：构成了鼠标点击事件的所有部分，按下-释放-完成</p></li></ul><h2 id="响应-分配事件"><a class="markdownIt-Anchor" href="#响应-分配事件"></a> 响应、分配事件</h2><p>HTML 元素有事件属性，触发时执行相应的动作。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"document.write('onlick')"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时也可以使用 JavaScript 来分配事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>).onclick = <span class="function"><span class="keyword">function</span></span>&#123;<span class="built_in">document</span>.write(<span class="string">"onlick"</span>)&#125;;</span><br></pre></td></tr></table></figure><h2 id="eventlistener"><a class="markdownIt-Anchor" href="#eventlistener"></a> EventListener</h2><h3 id="addeventlistener"><a class="markdownIt-Anchor" href="#addeventlistener"></a> addEventListener()</h3><p><strong>addEventListener()</strong> 方法用于向指定元素添加事件句柄。</p><ul><li>不会覆盖已存在的事件句柄，因此可以添加多个同类型的事件句柄</li><li>可以向任何 DOM 对象添加事件监听，不仅仅是 HTML 元素。如： window 对象。</li><li>addEventListener() 方法可以更简单的控制事件（冒泡与捕获）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(event, <span class="function"><span class="keyword">function</span>, <span class="title">useCapture</span>);</span></span><br></pre></td></tr></table></figure><ul><li><p>第一个参数是事件的类型（如&quot;click&quot;）</p><ul><li>不要加&quot;on&quot;前缀</li></ul></li><li><p>第二个参数是事件触发后调用的函数</p><ul><li><p>如果传递参数，则采用&quot;匿名函数&quot;来调用带参数的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; myFunction(p1, p2); &#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>第三个参数是个布尔值用于描述事件是冒泡还是捕获</p><ul><li>默认为 false，即冒泡传递</li></ul></li></ul><h4 id="冒泡和捕获"><a class="markdownIt-Anchor" href="#冒泡和捕获"></a> 冒泡和捕获</h4><p>事件传递有两种方式：<strong>冒泡</strong>与<strong>捕获</strong>。</p><p>事件传递定义了元素事件触发的顺序。</p><ul><li><em><strong>冒泡</strong></em>：内部元素的事件会先被触发，然后再触发外部元素</li><li><em><strong>捕获</strong></em>：外部元素的事件会先被触发，然后才会触发内部元素的事件</li></ul><p>如果你将 <code>&lt;p&gt;</code> 元素插入到 <code>&lt;div&gt;</code> 元素中，用户点击 <code>&lt;p&gt;</code> 元素</p><ul><li>冒泡中，<code>&lt;p&gt;</code> 元素的点击事件先触发</li><li>捕获中，<code>&lt;div&gt;</code> 元素的点击事件先触发</li></ul><h3 id="removeeventlistener"><a class="markdownIt-Anchor" href="#removeeventlistener"></a> removeEventListener()</h3><p><strong>removeEventListener()</strong> 方法来移除事件的监听。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.removeEventListener(<span class="string">"mousemove"</span>, myFunction);</span><br></pre></td></tr></table></figure><h1 id="dom-元素"><a class="markdownIt-Anchor" href="#dom-元素"></a> DOM 元素</h1><p>每一个元素都是 DOM 树的一个节点</p><p><em><strong>创建新的 HTML 元素</strong></em></p><ul><li><p><strong>document.createElement()</strong> 用于创建一个新的元素。</p></li><li><p><strong>document.createTextNode()</strong> 创建一个新的文本。</p></li></ul><p><em><strong>插入新节点</strong></em></p><ul><li><p><strong>appendChild()</strong> 向 DOM 树插入新节点，它用于添加新元素到尾部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形成一个新节点 para</span></span><br><span class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</span><br><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.createTextNode(<span class="string">"这是一个新的段落。"</span>);</span><br><span class="line">para.appendChild(node);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放入 body 元素中</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(para);</span><br></pre></td></tr></table></figure></li><li><p><strong>insertBefore()</strong> 将新元素插入指定位置，传入两个参数</p><ul><li>第一个是要插入的节点，第二个是一个子元素，表示在它前插入</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 放入 div 元素中，然后插入到 div 元素的子元素 p 之前</span></span><br><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>);</span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">document</span>.getElementById(<span class="string">"p"</span>);</span><br><span class="line">element.insertBefore(para, child);</span><br></pre></td></tr></table></figure></li></ul><p><em><strong>移除节点</strong></em></p><p>使用 removeChild() 来移除一个元素，你需要知道该元素的父元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>);</span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">document</span>.getElementById(<span class="string">"p"</span>);</span><br><span class="line">parent.removeChild(child);</span><br></pre></td></tr></table></figure><p><em><strong>替换节点</strong></em></p><p>使用 replaceChild() 方法来替换 DOM 节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.replaceChild(para, child);</span><br></pre></td></tr></table></figure><h1 id="dom-导航"><a class="markdownIt-Anchor" href="#dom-导航"></a> DOM 导航</h1><p>使用节点之间的关系在 DOM 树中导航。</p><p>length：节点列表的长度</p><p>节点属性：parentNode、firstChild 以及 lastChild</p><p>有两个特殊的属性来获取根节点：</p><ul><li>document.documentElement - 全部文档</li><li>document.body - 文档的主体</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript入门</title>
      <link href="/2020/07/28/%E5%AD%A6%E4%B9%A0/Web/JS/JavaScript%E5%85%A5%E9%97%A8/"/>
      <url>/2020/07/28/%E5%AD%A6%E4%B9%A0/Web/JS/JavaScript%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 是一种轻量级的编程语言。可插入 HTML 页面，兼容所有现代浏览器。</p><ul><li>JavaScript 与 Java 是两种完全不同的语言，只是名字有 Java</li><li>JavaScript 大小写敏感</li></ul><hr><p>HTML 中的脚本必须位于 <code>&lt;script&gt;</code> 与 <code>&lt;/script&gt;</code> 标签之间。</p><p>脚本可被放置在 HTML 页面的 <code>&lt;body&gt;</code> 和 <code>&lt;head&gt;</code> 部分中。</p><ul><li>可能会在 <code>&lt;script&gt;</code> 标签中使用 type=“text/javascript”，不过已经不必要了</li></ul><p>外部 JavaScript 文件的文件扩展名是 .js。</p><ul><li>在 <code>&lt;script</code>&gt; 标签的 “src” 属性中设置该 .js 文件即可导入</li><li>js 文件无需包含 <code>&lt;script&gt;</code> 标签</li></ul><h1 id="显示数据"><a class="markdownIt-Anchor" href="#显示数据"></a> 显示数据</h1><ul><li><p>使用 <strong>window.alert()</strong> 弹出警告框。</p><ul><li>可以直接写 <strong>alert()</strong></li></ul></li><li><p>使用 <strong>document.write()</strong> 方法将内容写到 HTML 文档中。</p><ul><li>如果在文档加载后使用，会覆盖整个文档</li></ul></li><li><p>使用 <strong>innerHTML</strong> 写入到 HTML 元素。</p><ul><li>使用 <code>document.getElementById(id)</code> 来获得 HTML 元素，然后修改 <strong>innerHTML</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"段落已修改。"</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用 <strong>console.log()</strong> 写入到浏览器的控制台。</p></li></ul><h1 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h1><ul><li><strong>字面量</strong>：一般固定值称为字面量</li><li><strong>var</strong> 关键字告诉浏览器创建一个新的变量<ul><li>声明无值的变量时，其值实际上是 undefined。</li><li><strong>let</strong> 声明的变量只在 let 命令所在的代码块内有效。</li><li><strong>const</strong> 声明一个只读的常量，一旦声明，常量的值就不能改变。<ul><li>const 本质并不是常量，而是不可改变引用，如果是对象或数组则是可变的，只是不能更改对象的引用</li></ul></li></ul></li><li>注释方法：<strong>//</strong> 和 <em><em>/</em> <em>/</em></em></li><li>语句之间要用 <strong>分号;</strong> 分隔</li><li><strong>变量命名规则</strong><ul><li>变量必须以<strong>字母开头</strong></li><li>变量也能以 $ 和 _ 符号开头（不过我们不推荐这么做）</li><li>变量名称对<strong>大小写敏感</strong>（y 和 Y 是不同的变量）</li></ul></li></ul><h1 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h1><ul><li><strong>值类型(基本类型)</strong>：字符串(String)、数字(Number)、布尔(Boolean)、对空(Null)、未定义(Undefined)、Symbol。<ul><li>Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。</li></ul></li><li><strong>引用数据类型</strong>：对象(Object)、数组(Array)、函数(Function)。</li></ul><p>JavaScript 拥有<strong>动态类型</strong>，也就是说相同的变量可用作不同的类型。</p><p>JavaScript 变量均为对象。当您声明一个变量时，就创建了一个新的对象。</p><p><strong>typeof</strong> 操作符来检测变量的数据类型。</p><ul><li>数组是一种特殊的对象类型，因此 typeof [1,2,3,4] 返回 object</li><li>null 也表示为 object，undefined 还是为 undefined，两者都能用于清空对象</li></ul><p><strong>constructor</strong> 属性返回所有 JavaScript 变量的构造函数。</p><ul><li>可以用 constructor 属性来查看对象的类型</li></ul><p><strong>类型转换</strong>的方法：</p><ul><li>通过使用 JavaScript 函数，如 <code>String()</code>、<code>Number()</code><ul><li>使用 Number() 时会返回 NaN(Not a Number)</li></ul></li><li>通过 JavaScript 自身自动转换，如 <code>x.toString()</code></li><li>Operator + 可用于将变量转换为数字：</li></ul><p>当 JavaScript 尝试操作一个 “错误” 的数据类型时，会自动转换为 “正确” 的数据类型。</p><ul><li>当 String 与 Number 相加时会自动调用 Number 的 toString()</li></ul><p><strong>变量提升(hoisting)</strong>：函数及变量的声明都将被提升到函数的最顶部。</p><ul><li><p>只有声明的变量会提升，初始化的不会。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x; <span class="comment">//提升</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">5</span>; <span class="comment">//不会提升</span></span><br></pre></td></tr></table></figure></li><li><p>let、const 声明的不会被提升</p></li></ul><h1 id="对象"><a class="markdownIt-Anchor" href="#对象"></a> 对象</h1><p>JavaScript 对象是拥有属性和方法的数据。</p><ul><li>JavaScript 对象是变量（属性和方法）的容器。</li></ul><p>对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>:<span class="string">"Eason"</span>, <span class="attr">age</span>:<span class="number">20</span>, <span class="attr">school</span>:<span class="string">"CSU"</span>&#125;;</span><br></pre></td></tr></table></figure><p>可以通过两种方式访问对象属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.name;</span><br><span class="line">person[<span class="string">"name"</span>];</span><br></pre></td></tr></table></figure><p>由于方法也是一种变量，因此可以使用键值对来放入对象中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name : <span class="string">"Eason"</span>,</span><br><span class="line">    age : <span class="number">20</span>,</span><br><span class="line">    school : <span class="string">"CSU"</span>,</span><br><span class="line">    info : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Name: "</span> + <span class="keyword">this</span>.name + <span class="string">" Age: "</span> + <span class="keyword">this</span>.age + <span class="string">" School: "</span> + <span class="keyword">this</span>.school;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用对象方法时，需加上 ()，如果不加返回一个定义函数的字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> info = person.info();</span><br><span class="line"><span class="keyword">var</span> infoDefinition = person.info;</span><br></pre></td></tr></table></figure><h1 id="作用域"><a class="markdownIt-Anchor" href="#作用域"></a> 作用域</h1><p><strong>在 JavaScript 中, 作用域为可访问变量，对象，函数的集合。</strong></p><ul><li><p>变量在函数内声明时，为局部变量，拥有局部作用域</p></li><li><p>变量在函数外定义，即为全局变量</p><ul><li>全局变量有 <strong>全局作用域</strong>：网页中所有脚本和函数均可使用。</li><li>如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。</li></ul></li><li><p>在每个代码块中 JavaScript 不会创建一个新的作用域，一般各个代码块的作用域都是全局的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i; <span class="comment">//返回10，而不是undefined</span></span><br></pre></td></tr></table></figure></li></ul><p>JavaScript 变量生命周期在它声明时初始化。局部变量在函数执行完毕后销毁。全局变量在页面关闭后销毁。</p><p>在 HTML 中, 全局变量是 window 对象: 所有数据变量都属于 window 对象。</p><h1 id="事件"><a class="markdownIt-Anchor" href="#事件"></a> 事件</h1><p>HTML 事件是发生在 HTML 元素上的事件。当在 HTML 页面中使用 JavaScript 时， JavaScript 可以触发这些事件。</p><p>HTML 事件可以是浏览器行为，也可以是用户行为：</p><ul><li>HTML 页面完成加载</li><li>HTML input 字段改变时</li><li>HTML 按钮被点击</li></ul><p>HTML 元素中可以添加事件属性，使用 JavaScript 代码来添加元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">some-HTML-element</span> <span class="attr">some-event</span>=<span class="string">"JavaScript 代码"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>常见的 HTML 事件：</p><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>onchange</td><td>HTML 元素改变</td></tr><tr><td>onclick</td><td>用户点击 HTML 元素</td></tr><tr><td>onmouseover</td><td>用户在一个HTML元素上移动鼠标</td></tr><tr><td>onmouseout</td><td>用户从一个HTML元素上移开鼠标</td></tr><tr><td>onkeydown</td><td>用户按下键盘按键</td></tr><tr><td>onload</td><td>浏览器已完成页面的加载</td></tr></tbody></table><p>JavaScript 事件可以用于处理表单验证，用户输入，用户行为及浏览器动作……</p><h1 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> 正则表达式</h1><p>JavaScript 的正则表达式语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/正则表达式主体/修饰符(可选)</span><br></pre></td></tr></table></figure><p>正则表达式通常用于两个字符串方法 : search() 和 replace()。</p><ul><li><strong>search() 方法</strong> 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。</li><li><strong>replace() 方法</strong> 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</li></ul><p><strong>修饰符</strong> 可以在全局搜索中不区分大小写：</p><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>i</td><td>执行对大小写不敏感的匹配</td></tr><tr><td>g</td><td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td></tr><tr><td>m</td><td>执行多行匹配。</td></tr></tbody></table><h2 id="regexp-对象"><a class="markdownIt-Anchor" href="#regexp-对象"></a> RegExp 对象</h2><p>在 JavaScript 中，RegExp 对象是一个预定义了属性和方法的正则表达式对象。</p><p>test() 方法是一个正则表达式方法：用于检测一个字符串是否匹配某个模式</p><ul><li>如果字符串中含有匹配的文本，则返回 true，否则返回 false</li></ul><p>exec() 方法是一个正则表达式方法：exec() 方法用于检索字符串中的正则表达式的匹配</p><ul><li>该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null</li></ul><h1 id="错误"><a class="markdownIt-Anchor" href="#错误"></a> 错误</h1><p><strong>try</strong> 语句测试代码块的错误。<strong>catch</strong> 语句处理错误。</p><ul><li><strong>try</strong> 和 <strong>catch</strong> 是成对出现的。</li></ul><p><strong>throw</strong> 语句创建自定义错误。</p><ul><li>异常可以是 JavaScript 字符串、数字、逻辑值或对象。</li></ul><p><strong>finally</strong> 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。</p><h1 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h1><p>很多浏览器都内置了调试工具，按下 <strong>F12</strong> 键，并在调试菜单中选择 <strong>Console</strong>。</p><p>如果浏览器支持调试，你可以使用 <strong>console.log()</strong> 方法在调试窗口上打印 JavaScript 值。</p><p><strong>debugger</strong> 关键字用于停止执行 JavaScript（设置断点），并调用调试函数。</p><ul><li>打开 F12 中的 Source 刷新网页就可以调试了</li></ul><h1 id="严格模式"><a class="markdownIt-Anchor" href="#严格模式"></a> 严格模式</h1><p><strong>&quot;use strict&quot;</strong> 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。</p><ul><li>它是一个字面量表达式，在 JavaScript 旧版本中会被忽略。</li><li>在函数内部声明是局部作用域 (只在函数内使用严格模式)</li></ul><p>严格模式的限制：</p><ul><li>不能使用未声明的变量。<ul><li>对象也是一个变量</li></ul></li><li>不允许删除变量或对象</li><li>不允许删除函数</li><li>不允许变量重名</li><li>不允许使用八进制</li><li>不允许使用转义字符</li><li>不允许对只读属性赋值</li><li>不允许对一个使用getter方法读取的属性进行赋值</li><li>不允许删除一个不允许删除的属性</li><li>变量名不能使用 “eval” 字符串</li><li>变量名不能使用 “arguments” 字符串</li><li>禁止this关键字指向全局对象</li><li>等等</li></ul><p>为什么使用严格模式：消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为；也为了向新版本的JavaScript 过渡。</p><h1 id="表单"><a class="markdownIt-Anchor" href="#表单"></a> 表单</h1><p>HTML 表单验证可以通过 JavaScript 来完成。</p><ul><li>通过 document.forms：所有表单的集合</li></ul><p>设置一个方法，让它验证表单，出错时返回 false 来阻止表单的提交：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validateForm</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = docment.forms[<span class="string">"myForm"</span>][<span class="string">"fname"</span>].value;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="literal">null</span> || x == <span class="string">""</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 form 表单提交时被调用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"myForm"</span> <span class="attr">action</span>=<span class="string">"demo.php"</span> <span class="attr">onsubmit</span>=<span class="string">"return validateForm()"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"fname"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="验证-api"><a class="markdownIt-Anchor" href="#验证-api"></a> 验证 API</h1><p>约束验证 DOM 方法：</p><ul><li><strong>checkValidity()</strong>：如果 input 元素中的数据是合法的返回 true，否则返回 false</li><li><strong>setCustomValidity()</strong>：设置 input 元素的 validationMessage 属性，用于自定义错误提示信息的方法。<ul><li>使用 setCustomValidity 设置了自定义提示后，validity.customError 就会变成true，则 checkValidity 总是会返回 false。</li></ul></li></ul><p>约束验证 DOM 属性：</p><ul><li><strong>validity</strong>：布尔属性值，返回 input 输入值是否合法<ul><li>包含了一系列关于 validity 数据属性</li></ul></li><li><strong>validationMessage</strong>：浏览器错误提示信息</li><li><strong>willValidate</strong>：指定 input 是否需要验证</li></ul><h1 id="this-关键字"><a class="markdownIt-Anchor" href="#this-关键字"></a> this 关键字</h1><p>面向对象语言中 this 表示当前对象的一个引用。</p><ol><li>在对象方法中， this 指向调用它所在方法的对象。</li><li>单独使用 this，它指向全局(Global)对象。</li></ol><ul><li>在浏览器中，window 就是该全局对象为 [<strong>object Window</strong>]</li></ul><ol start="3"><li>函数使用中，this 指向函数的所属者。</li><li>严格模式下函数是没有绑定到 this 上，这时候 this 是 undefined。</li><li>在 HTML 事件句柄中，this 指向了接收事件的 HTML 元素。</li><li>apply 和 call 允许切换函数执行的上下文环境（context），即 this 绑定的对象，可以将 this 引用到任何对象。</li></ol><h1 id="json"><a class="markdownIt-Anchor" href="#json"></a> JSON</h1><p>JSON 是用于存储和传输数据的格式。全称：<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation</p><ul><li>JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本（可以在其他语言使用）。</li></ul><p>JSON 格式在语法上与创建 JavaScript 对象代码是相同的。</p><h2 id="json-语法规则"><a class="markdownIt-Anchor" href="#json-语法规则"></a> JSON 语法规则</h2><ul><li>数据为 键/值 对<ul><li>全部加了双引号，与对象区分开来</li></ul></li><li>数据由逗号分隔</li><li>大括号保存对象</li><li>方括号保存数组</li></ul><p>JSON 对象保存在大括号内。与 JavaScript 一样，对象可以保存多个 键/值 对：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"Google"</span>, <span class="attr">"url"</span>:<span class="string">"www.google.com"</span>&#125;</span><br></pre></td></tr></table></figure><p>JSON 数组保存在中括号内。就像 JavaScript 中，数组可以包含对象：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"sites":[ </span><br><span class="line">    &#123;"name":"Google", "url":"www.google.com"&#125;,</span><br><span class="line">    &#123;<span class="attr">"name"</span>:<span class="string">"Taobao"</span>, <span class="attr">"url"</span>:<span class="string">"www.taobao.com"</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>最后用大括号将其包裹起来，这样就是一个 JSON 对象了：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"sites"</span>:[ </span><br><span class="line">    &#123;<span class="attr">"name"</span>:<span class="string">"Google"</span>, <span class="attr">"url"</span>:<span class="string">"www.google.com"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"name"</span>:<span class="string">"Taobao"</span>, <span class="attr">"url"</span>:<span class="string">"www.taobao.com"</span>&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><h2 id="json-字符串-leftrightarrow-javascript-对象"><a class="markdownIt-Anchor" href="#json-字符串-leftrightarrow-javascript-对象"></a> JSON 字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇔</mo></mrow><annotation encoding="application/x-tex">\Leftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇔</span></span></span></span> JavaScript 对象</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>JSON.parse()</td><td>用于将一个 JSON 字符串转换为 JavaScript 对象。</td></tr><tr><td>JSON.stringify()</td><td>用于将 JavaScript 值转换为 JSON 字符串。</td></tr></tbody></table><h1 id="异步编程"><a class="markdownIt-Anchor" href="#异步编程"></a> 异步编程</h1><p><strong>回调函数</strong>：一个函数，它是在我们启动一个异步任务的时候就告诉它：等你完成了这个任务之后要干什么。</p><ul><li><strong>setTimeout(回调函数, 毫秒数)</strong></li></ul><p>除了 setTimeout 函数以外，异步回调广泛应用于 AJAX(Asynchronous JavaScript and XML) 编程。</p><h2 id="promise"><a class="markdownIt-Anchor" href="#promise"></a> Promise</h2><p>Promise 是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。</p><p><em><strong>构造 Promise</strong></em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(funciton(resolve, reject) &#123;</span><br><span class="line"><span class="comment">// 要做的事情……</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise 可以多次调用异步函数，而不是使用 setTimeout 嵌套完成。</p><ul><li><p>Promise 构造函数只有一个参数，是一个函数，这个函数在构造之后会直接被异步运行，所以我们称之为起始函数。起始函数包含两个参数 resolve 和 reject。</p><ul><li><p>resolve 和 reject 都是函数，其中调用 resolve 代表一切正常，reject 是出现异常时所调用的</p><ul><li>resolve 可以放置一个参数传递给下一个 then</li><li>reject() 参数中一般会传递一个异常给之后的 catch 函数用于处理异常。</li></ul></li><li><p>resolve 和 reject 并不能够使起始函数停止运行，别忘了 return</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) reject(<span class="string">"Diveide zero"</span>);</span><br><span class="line">    <span class="keyword">else</span> resolve(a / b);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Promise 类有 .then() .catch() 和 .finally() 三个方法，参数全是一个函数</p><ul><li>.then() 可以将参数中的函数添加到当前 Promise 的正常执行序列<ul><li>then 中的函数可以返回一个值传递给 then</li><li>如果 then 中返回的是一个 Promise 对象，那么下一个 then 将相当于对这个返回的 Promise 进行操作</li></ul></li><li>.catch() 则是设定 Promise 的异常处理序列</li><li>.finally() 是在 Promise 执行的最后一定会执行的序列</li><li>.then() 传入的函数会按顺序依次执行，有任何异常都会直接跳到 catch 序列</li></ul></li></ul><h2 id="异步函数"><a class="markdownIt-Anchor" href="#异步函数"></a> 异步函数</h2><p>异步函数（async function）是 ECMAScript 2017 (ECMA-262) 标准的规范</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> print(<span class="number">1000</span>, <span class="string">"First"</span>);</span><br><span class="line">    <span class="keyword">await</span> print(<span class="number">4000</span>, <span class="string">"Second"</span>);</span><br><span class="line">    <span class="keyword">await</span> print(<span class="number">3000</span>, <span class="string">"Third"</span>);</span><br><span class="line">&#125;</span><br><span class="line">asyncFunc();</span><br></pre></td></tr></table></figure><ul><li>异步函数 async function 中可以使用 await 指令，await 指令后必须跟着一个 Promise，异步函数会在这个 Promise 运行中暂停，直到其运行结束再继续运行。</li><li>实际上原理与 Promise 原生 API 的机制是一模一样的，只不过更便于程序员阅读。</li></ul><h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1><p>使用关键字 <strong>function</strong> 定义函数。</p><p>函数也是一个对象，也可以使用函数构造器（Function()）定义。</p><p>亦可以使用箭头函数，与Lamda类似。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数<span class="number">1</span>, 参数<span class="number">2</span>, …, 参数N) =&gt; &#123; 函数声明 &#125;</span><br></pre></td></tr></table></figure><p>函数的参数没有个数检测，如果过少会默认设置为 undefined，过多则只能使用 arguments 对象来调用。</p><ul><li>JavaScript 函数有个内置的对象 arguments 对象。argument 对象包含了函数调用的参数数组。</li></ul><p>ES6 函数可以自带参数（默认参数）</p><p>JavaScript 闭包使用函数自我调用实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> counter += <span class="number">1</span>;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"> </span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 计数器为 3</span></span><br></pre></td></tr></table></figure><ul><li>闭包可以使得函数拥有私有变量(counter)，然后只有 add() 可以修改 counter</li><li>闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。直观的说就是形成一个不销毁的栈环境。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP进阶</title>
      <link href="/2020/07/23/%E5%AD%A6%E4%B9%A0/Web/PHP/PHP%E8%BF%9B%E9%98%B6/"/>
      <url>/2020/07/23/%E5%AD%A6%E4%B9%A0/Web/PHP/PHP%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p><em><strong>date() 函数</strong></em></p><p>PHP date() 函数可把时间戳格式化为可读性更好的日期和时间。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string date ( string $format [, int $timestamp ] )</span><br></pre></td></tr></table></figure><ul><li>format：必需，规定时间戳的格式<ul><li>d-天、m-月、Y-年</li><li>c - ISO 8061格式日期、r - RFC 822格式日期</li></ul></li><li>timestamp：可选，规定时间戳。默认当前时间</li></ul><hr><p><em><strong>include 和 require</strong></em></p><p>include 和 require 语句用于在<strong>执行流中插入写在其他文件中的有用的代码</strong>。</p><p>但是两者<strong>处理错误</strong>的方式不同：</p><ul><li>require 生成一个致命错误（E_COMPILE_ERROR），在错误发生后脚本会<strong>停止</strong>执行。</li><li>include 生成一个警告（E_WARNING），在错误发生后脚本会<strong>继续</strong>执行。</li></ul><p>include 一般放在程序的流程控制中，require 一般放在 PHP 文件的开头</p><hr><p><em><strong>文件操作</strong></em></p><p>fopen() 函数用于在 PHP 中打开文件，与 Python 类似。</p><ul><li>有两个必需参数：文件的URL、文件的访问模式</li><li><code>$file=fopen(&quot;welcome.txt&quot;,&quot;r&quot;) or exit(&quot;Unable to open file!&quot;);</code> 使用这个方法打开文件，找不到的话会提示。</li></ul><p>fclose() 函数用于关闭打开的文件。</p><p>feof() 函数检测是否已到达文件末尾（EOF）。</p><p>fgets() 函数用于从文件中逐行读取文件。</p><ul><li>在调用该函数之后，文件指针会移动到下一行。</li></ul><p>fgetc() 函数用于从文件中逐字符地读取文件。</p><ul><li>与fgets 一样，读取后会自动移到下一个字符</li></ul><hr><p><em><strong>文件上传</strong></em></p><p><code>&lt;form&gt;</code> 标签的 <strong>enctype</strong> 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 “<strong>multipart/form-data</strong>”。</p><p>通过使用 PHP 的全局数组 $_FILES，来获取 HTML 提交的文件。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> ($_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"错误："</span>  . $_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>] . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"上传文件名: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>] . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"文件类型: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"文件大小: "</span> . ($_FILES[<span class="string">"file"</span>][<span class="string">"size"</span>] / <span class="number">1024</span>) . <span class="string">" kB&lt;br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"文件临时存储的位置: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li>第一个参数是表单的 input name，第二个下标可以是 “name”、“type”、“size”、“tmp_name” 或 “error”。<ul><li>$_FILES[“file”][“name”] - 上传文件的名称</li><li>$_FILES[“file”][“type”] - 上传文件的类型</li><li>$_FILES[“file”][“size”] - 上传文件的大小，以字节计</li><li>$_FILES[“file”][“tmp_name”] - 存储在服务器的文件的临时副本的名称</li><li>$_FILES[“file”][“error”] - 由文件上传导致的错误代码</li></ul></li></ul><p><strong>上传限制</strong>，举个栗子：用户只能上传 .gif、.jpeg、.jpg、.png 文件，文件大小必须小于 200 kB：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 允许上传的图片后缀</span></span><br><span class="line">$allowedExts = <span class="keyword">array</span>(<span class="string">"gif"</span>, <span class="string">"jpeg"</span>, <span class="string">"jpg"</span>, <span class="string">"png"</span>);</span><br><span class="line">$temp = explode(<span class="string">"."</span>, $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>]);</span><br><span class="line">$extension = end($temp);        <span class="comment">// 获取文件后缀名</span></span><br><span class="line"><span class="keyword">if</span> ((($_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/gif"</span>)</span><br><span class="line">|| ($_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/jpeg"</span>)</span><br><span class="line">|| ($_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/jpg"</span>)</span><br><span class="line">|| ($_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/pjpeg"</span>)</span><br><span class="line">|| ($_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/x-png"</span>)</span><br><span class="line">|| ($_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/png"</span>))</span><br><span class="line">&amp;&amp; ($_FILES[<span class="string">"file"</span>][<span class="string">"size"</span>] &lt; <span class="number">204800</span>)    <span class="comment">// 小于 200 kb</span></span><br><span class="line">&amp;&amp; in_array($extension, $allowedExts))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ($_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"错误：: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>] . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"上传文件名: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>] . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"文件类型: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"文件大小: "</span> . ($_FILES[<span class="string">"file"</span>][<span class="string">"size"</span>] / <span class="number">1024</span>) . <span class="string">" kB&lt;br&gt;"</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"文件临时存储的位置: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"非法的文件格式"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><code>move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]);</code> 用来<strong>保存上传的文件</strong>。</p><ul><li>将临时存储的文件移动到指定目录</li></ul><hr><p><em><strong>Cookie</strong></em></p><p>cookie 常用于识别用户。cookie 是一种服务器留在用户计算机上的小文件。每当同一台计算机通过浏览器请求页面时，这台计算机将会发送 cookie。通过 PHP，您能够创建并取回 cookie 的值。</p><p><strong>创建 Cookie</strong></p><p><strong>setcookie() 函数</strong>用于设置 cookie。</p><ul><li>setcookie() 函数<strong>必须位于 <code>&lt;html&gt;</code> 标签之前</strong>。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcookie(name, value, expire, path, domain);</span><br></pre></td></tr></table></figure><ul><li>name：cookie 名</li><li>value：cookie 的值，会自动编码，取回时自动解码<ul><li>为防止 URL 编码，请使用 setrawcookie() 取而代之。</li></ul></li><li>expire：cookie 的过期时间，单位为 s<ul><li>一般采用 <strong>time()+保存时间</strong> 设置</li></ul></li></ul><p><strong>取回 Cookie</strong></p><p><strong>$_COOKIE 变量</strong>用于取回 cookie 的值。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_COOKIE[<span class="string">"user"</span>]))</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"欢迎 "</span> . $_COOKIE[<span class="string">"user"</span>] . <span class="string">"!&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"普通访客!&lt;br&gt;"</span>;</span><br></pre></td></tr></table></figure><p><strong>删除 Cookie</strong></p><p>当删除 cookie 时，您应当使过期日期变更为过去的时间点。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcookie(<span class="string">"user"</span>, <span class="string">""</span>, time()<span class="number">-3600</span>);</span><br></pre></td></tr></table></figure><hr><p><em><strong>Session</strong></em></p><p>session 变量用于存储关于用户会话的信息，或者更改用户会话的设置。</p><p>Session 的工作机制是：为每个访客创建一个唯一的 id (UID)，并基于这个 UID 来存储变量。UID 存储在 cookie 中，或者通过 URL 进行传导。</p><p><strong>开始 Session</strong></p><p>使用 session_start() 函数，<strong>必须位于 <code>&lt;html&gt;</code> 标签之前</strong>。</p><p><strong>存取 Session</strong></p><p>通过对 <strong>$_SESSION 变量</strong> 的存取就能实现存取 Session</p><p>可以通过这个来设置一个简单网页浏览计数器：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">session_start();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_SESSION[<span class="string">'views'</span>])) &#123;</span><br><span class="line">    $_SESSION[<span class="string">'views'</span>]=$_SESSION[<span class="string">'views'</span>]+<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $_SESSION[<span class="string">'views'</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"浏览量："</span>. $_SESSION[<span class="string">'views'</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>销毁 Session</strong></p><p>可以使用 <strong>unset()</strong> 或 <strong>session_destroy()</strong> 函数。</p><ul><li>unset() 函数用于<strong>释放</strong>指定的 session 变量</li><li>session_destroy() 函数<strong>彻底销毁</strong> session，将重置 session，失去所有已存储的 session 数据。</li></ul><hr><p><em><strong>E-mail</strong></em></p><p>mail() 函数用于从脚本中发送电子邮件。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mail(to,subject,message,headers,parameters)</span><br></pre></td></tr></table></figure><ul><li>to：必需，规定 Email 的接收者</li><li>subject：必需，规定 Email 的主题<ul><li>不能包含任何新行字符</li></ul></li><li>message：必需，定义要发送的消息<ul><li>应使用 LF (\n) 来分隔各行。每行应该限制在 70 个字符内。</li></ul></li><li>headers：可选，规定附加的标题</li><li>parameters：可选，对邮件发送程序规定额外的参数。</li></ul><hr><p><em><strong>错误处理</strong></em></p><p>PHP 默认的错误处理：一条错误消息会被发送到浏览器，这条消息带有文件名、行号以及描述错误的消息。</p><p>以下有三种错误处理方法：die()、自定义错误和错误触发器、错误报告</p><p><strong>die()</strong>：在产生错误时，输入错误消息，然后终止脚本</p><p><strong>自定义错误处理器</strong></p><p>创建一个专用函数，发生错误时调用该函数，该函数必须有能力处理至少两个参数 (error level 和 error message)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error_function</span><span class="params">(error_level,error_message,</span></span></span><br><span class="line"><span class="function"><span class="params">error_file,error_line,error_context)</span></span></span><br></pre></td></tr></table></figure><p><strong>设置错误处理程序</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_error_handler(<span class="string">"error_function"</span>);</span><br></pre></td></tr></table></figure><p><strong>触发错误</strong></p><p>由 trigger_error() 函数完成.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$test=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> ($test&gt;<span class="number">1</span>) &#123;</span><br><span class="line">    trigger_error(<span class="string">"变量值必须小于等于 1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误记录</strong></p><p>在默认的情况下，根据在 <strong>php.ini</strong> 中的 <strong>error_log</strong> 配置，PHP 向服务器的记录系统或文件发送错误记录。通过使用 <strong>error_log()</strong> 函数，您可以<strong>向指定的文件或远程目的地发送错误记录</strong>。</p><hr><p><em><strong>异常处理</strong></em></p><ul><li><strong>基本使用</strong>：try-catch、throw</li><li><strong>自定义 Exception</strong>：继承 Exception</li><li><strong>设置顶层异常处理器</strong>：set_exception_handler() 函数可设置处理所有未捕获异常的用户定义函数。</li></ul><p>异常的规则：</p><ul><li>需要进行异常处理的代码应该放入 try 代码块内，以便捕获潜在的异常。</li><li>每个 try 或 throw 代码块必须至少拥有一个对应的 catch 代码块。</li><li>使用多个 catch 代码块可以捕获不同种类的异常。</li><li>可以在 try 代码块内的 catch 代码块中抛出（再次抛出）异常。</li></ul><p>如果异常没有进行 try 和 catch，则发生的是语法错误而不是抛出异常</p><hr><p><em><strong>过滤器</strong></em></p><p>PHP 过滤器用于验证和过滤来自非安全来源的数据（外部数据）。</p><p>外部数据：来自表单的输入数据、Cookies、Web services data、服务器变量、数据库查询结果</p><p><strong>函数和过滤器</strong></p><p>过滤变量的过滤器函数：</p><ul><li>filter_var() - 通过一个指定的过滤器来过滤单一的变量</li><li>filter_var_array() - 通过相同的或不同的过滤器来过滤多个变量</li><li>filter_input() - 获取一个输入变量，并对它进行过滤</li><li>filter_input_array() - 获取多个输入变量，并通过相同的或不同的过滤器对它们进行过滤</li></ul><p>完整的函数和过滤器列表：<a href="https://www.runoob.com/php/php-ref-filter.html" target="_blank" rel="noopener">PHP 过滤器</a></p><p><strong>Validating 和 Sanitizing</strong></p><p>有两种过滤器：</p><p>Validating 过滤器：</p><ul><li>用于验证用户输入</li><li>严格的格式规则（比如 URL 或 E-Mail 验证）</li><li>如果成功则返回预期的类型，如果失败则返回 FALSE</li></ul><p>Sanitizing 过滤器：</p><ul><li>用于允许或禁止字符串中指定的字符</li><li>无数据格式规则</li><li>始终返回字符串</li></ul><p><strong>选项和标志</strong>：向指定的过滤器添加额外的过滤选项。不同的过滤器有不同的选项和标志。</p><p><strong>验证输入</strong>：用 filter_input() 函数过滤输入的数据</p><p><strong>净化输入</strong>：用 filter_input() 函数来净化输入数据</p><p><strong>过滤多个输入</strong>：使用 filter_var_array 或 filter_input_array 函数。</p><p><strong>Filter Callback</strong>：使用 FILTER_CALLBACK 过滤器，可以调用自定义的函数，把它作为一个过滤器来使用。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3</title>
      <link href="/2020/07/22/%E5%AD%A6%E4%B9%A0/Web/%E5%89%8D%E7%AB%AF/CSS/"/>
      <url>/2020/07/22/%E5%AD%A6%E4%B9%A0/Web/%E5%89%8D%E7%AB%AF/CSS/</url>
      
        <content type="html"><![CDATA[<p>CSS基本语法如下：</p><p><img alt="CSS基本语法" data-src="https://cdn.jsdelivr.net/gh/EasonZzZz/BlogPic/img/20200722152210.png" class="lazyload"></p><p>在网页中插入CSS样式表的三种方式：</p><ol><li><p>内联样式（Inline Style）</p><ul><li>利用全局属性 style</li></ul></li><li><p>内部样式表（Internal Style Sheet）</p><ul><li>利用 <code>&lt;style&gt;</code> 元素定义内部样式</li></ul></li><li><p>外部样式表（External Style Sheet）</p><ul><li>利用 <code>&lt;link&gt;</code> 元素引入外部样式表，实现语义与样式分离</li></ul></li></ol><ul><li>CSS没有限制空格的使用<ul><li>有部分特定情况不能使用空格</li></ul></li><li>对大小写不敏感（除了id、class）</li><li>内联样式 &gt; 内部样式表 &gt; 外部样式表</li></ul><hr><p>CSS 五类选择器：基本、复合、伪类、伪元素、属性</p><ul><li>伪类：已有元素处于某个状态时</li><li>伪元素：创建一些不在文档树的的元素</li></ul><p><em><strong>基本选择器</strong></em>：</p><ul><li><p>*** **：通用选择器选取<em>所有</em>元素</p><ul><li>* 选择器也能选取另一个元素中的所有元素。</li></ul></li><li><p><strong>element</strong>：元素选择器设定<em>某元素</em>的样式。</p></li><li><p><strong>.class</strong>：类选择器允许以一种独立于文档元素的方式来指定样式。</p></li><li><p><strong>#id</strong>：id选择器可以为标有<em>特定 id</em> 的 HTML 元素指定特定的样式。</p><ul><li>id 是唯一的，因此 id 选择器只针对一个特定的元素</li></ul></li></ul><hr><p><em><strong>复合选择器</strong></em></p><ul><li><p><strong>交集</strong>：找到指定标签间的<em>共有</em>部分</p><ul><li>element.class 或者 element#id</li></ul></li><li><p><strong>并集</strong>：找到<em>所有</em>满足的标签</p><ul><li>element1,element2,element3,…</li></ul></li><li><p><strong>后代</strong>：选择elment1元素<em>内部</em>的element2元素</p><ul><li>element1 element2</li></ul></li><li><p><strong>子元素</strong>：选择element1元素中符合<em>直接子元素</em>的element2元素</p><ul><li>element1 &gt; element2</li><li>如果元素不是父元素的直接子元素，则不会被选择。</li></ul></li><li><p><strong>相邻兄弟</strong>：选择具有相同父元素且同级的element1<em>相邻</em>的element2</p><ul><li>element1 + element2</li></ul></li><li><p><strong>通用兄弟</strong>：选择具有相同父元素且同级的element1<em>之后</em>的element2</p><ul><li>element1 ~ element2</li></ul></li></ul><hr><p><em><strong>伪元素选择器</strong></em></p><ul><li><p><strong>::first-line</strong>：选取指定选择器的<em>首行</em>。</p><ul><li>仅对块级元素起作用</li></ul></li><li><p><strong>::first-letter</strong>：选取指定选择器的<em>首字母</em>。</p></li><li><p><strong>::before</strong>：在被选元素的内容<em>前面插入</em>内容。</p></li><li><p><strong>::after</strong>：在被选元素的内容<em>后面插入</em>内容。</p><ul><li>使用 <strong>content</strong> 属性来指定要插入的内容</li></ul></li><li><p><strong>::selection</strong>：选匹配元素中被用户选中或处于高亮状态的部分。</p></li></ul><p>伪元素选择器并不使用于所有 CSS 样式，只能操作部分属性</p><hr><p><em><strong>伪类选择器</strong></em></p><ul><li><p><strong>动态伪类选择器</strong>：根据条件的改变动态选择</p><p>超链接 a 适用的四种状态：</p><ul><li><strong>:link</strong>：选取<em>未被访问的链接</em></li><li><strong>:visited</strong>：选取<em>已被访问的链接</em></li><li><strong>:hover</strong>：鼠标<em>指针浮动</em>在上面的元素。</li><li><strong>:active</strong>：用于<em>选择活动</em>链接。</li></ul><p>必需按照固定顺序写：a:<strong>l</strong>ink 、a:<strong>v</strong>isited 、a:<strong>h</strong>over 、a:<strong>a</strong>ctive</p><ul><li>爱恨准则：<strong>l</strong>o<strong>v</strong>e <strong>ha</strong>te</li></ul><p>:link、:visited 只适用于 a 标签，:hover、:active 适用于所有标签</p><p>还有一个动态伪类选择器：</p><ul><li><strong>:focus</strong>：选取<strong>获得焦点的元素</strong>。</li></ul></li><li><p><strong>UI伪类选择器</strong>：选择处于某种状态下的UI元素，主要用于HTML表单</p><ul><li><strong>:enable</strong> 和 <strong>:disabled</strong>：可用/禁用元素</li><li><strong>:checked</strong>：单选框、复选框、下拉列表的选项<ul><li>常与 span 和 兄弟选择器搭配</li></ul></li><li><strong>:required</strong> 和 <strong>:optional</strong>：必填项和可选项</li><li><strong>:default</strong>：默认状态的元素，如按钮</li><li><strong>:valid</strong> 和 <strong>:invalid</strong>：合法输入和非法输入</li><li><strong>:in-range</strong> 和 <strong>:out-of-range</strong>：输入的数字在范围内和超出范围</li><li><strong>:read-only</strong> 和 <strong>:read-write</strong>：只读和可读写</li></ul></li><li><p><strong>结构伪类选择器</strong></p><ul><li><strong>:root</strong> 和 <strong>:empty</strong>：根元素和空元素，比较少用</li><li><strong>:first-child</strong> 和 <strong>:last-child</strong>：第一个子元素和最后一个子元素</li><li><strong>:only-child</strong> 和 <strong>:only-of-type</strong>：唯一子元素和唯一类型子元素</li><li><strong>:first-of-type</strong> 和 <strong>:last-of-type</strong>：相同类型的子元素的第一个/最后一个</li><li><strong>:nth-child(n)</strong> 和 <strong>:nth-last-child(n)</strong>：（倒数）第 n 个子元素</li><li><strong>:nth-of-type(n)</strong> 和 <strong>:nth-last-of-type(n)</strong>：指定类型的（倒数）第 n 个子元素<ul><li>n 可以是数字、关键词或公式。</li></ul></li></ul></li><li><p><strong>其他伪类选择器</strong></p><ul><li><strong>:target</strong>：页面<em>内锚点</em></li><li><strong>:lang</strong>：带有以指定值开头的 lang 属性的元素</li><li><strong>:not(selector)</strong>：非指定元素/选择器的每个元素</li></ul></li></ul><hr><p><em><strong>属性选择器</strong></em></p><ul><li><strong>[attribute]</strong>： 用于选取带有指定属性的元素。</li><li><strong>[attribute=value]</strong>：用于选取带有指定属性和值的元素。</li><li><strong>[attribute~=value]</strong>：选取属性值中包含指定词汇的元素</li><li><strong>[attribute|=value]</strong>：用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。</li><li><strong>[attribute^=value]</strong>：匹配属性值以指定值开头的每个元素。</li><li><strong>[attribute$=value]</strong>：匹配属性值以指定值结尾的每个元素。</li><li><em><em>[attribute</em>=value]</em>*：匹配属性值中包含指定值的每个元素。</li></ul><hr><p><em><strong>CSS 的颜色表达</strong></em></p><p>CSS 支持 RGB、HEX、HSL、RGBA、HSLA 五种方式表示配色。</p><p>RGBA、HSLA 引入了 Alpha 透明度</p><p><a href="https://man.ilovefishc.com/color/index.html" target="_blank" rel="noopener">标准颜色名称参考</a></p><p><a href="https://man.ilovefishc.com/color/colorChange.html" target="_blank" rel="noopener">RGB调色器</a></p><hr><p>HTML 每个元素都是一个盒子：</p><p><img alt data-src="https://cdn.jsdelivr.net/gh/EasonZzZz/BlogPic/img/20200729181438.png" class="lazyload"></p><hr><p><em><strong>颜色相关的属性</strong></em></p><ul><li><p>前景色 color</p></li><li><p>背景颜色 backgroud-color</p></li><li><p>背景图片 background-image</p><ul><li>背景图片会覆盖背景颜色</li><li>设置 <code>background-repeat: no-repeat;</code> 使图像不重复</li><li><code>background-position</code> 设置图片相对位置</li><li><code>background-size</code> 设置图像大小</li><li><code>background-attachment</code> 设置背景图像是否固定或者随着页面的其余部分滚动。</li><li><code>background-origin</code> 设置图像绘制起始位置</li></ul></li></ul><hr><p><em><strong>边框的设置</strong></em></p><ul><li><p>边框样式 border-style</p></li><li><p>边框宽度 border-width</p></li><li><p>边框颜色 border-color</p></li><li><p>为每一条边框设置单独的样式、宽度和颜色</p><p><img alt data-src="https://cdn.jsdelivr.net/gh/EasonZzZz/BlogPic/img/20200729174904.png" class="lazyload"></p></li><li><p>设置圆角边框 border-radius 一系列属性</p><ul><li>左下角和右下角，右上角和左下角成对，传入两个参数是设置这两对，而并不是设置四个角</li><li>用 斜杠/ 隔开两个参数就可以设置四个角了，如 <code>15px / 15px</code></li></ul></li><li><p>图像边框 border-imgae 一系列属性</p><ul><li>border-image-slice 不用加单位</li></ul></li></ul><hr><p><em><strong>边距的设置</strong></em></p><ul><li>内边距 padding 系列</li><li>外边距 margin 系列<ul><li>纵向两个相邻的元素同时设置了外边距，会出现塌陷现象，以最大的外边距为准</li></ul></li><li>margin 可以设置为 auto 来实现水平居中<ul><li>对象必须是块级元素，必须指定元素的宽度</li></ul></li></ul><hr><p><em><strong>元素的大小</strong></em>：width * height + padding * 2 + margin * 2</p><ul><li><p>box-sizing 允许以某种方式定义某些元素，以适应指定区域</p><ul><li>四个值：margin-box、border-box、padding-box、content-box</li><li>如果设置为border-box，则 width * height 就是包含边框的元素大小</li></ul></li><li><p>min/max-width 和 min/max-height</p><ul><li>可以用 max-width 代替 width 来适应不同的尺寸</li></ul></li><li><p>overflow 规定当内容溢出元素框时发生的事情</p><ul><li>visible（默认值）、hidden、scroll、auto、inherit</li></ul></li><li><p>resize 属性指定一个元素是否是由用户调整大小的。</p><ul><li>none、both、horizontal、vertical</li></ul></li></ul><hr><p><em><strong>轮廓</strong></em></p><p>不属于元素大小的一部分，永远是方的</p><ul><li>outline 属性</li><li>outline-offset 与元素的偏移距离</li></ul><p><em><strong>阴影</strong></em></p><p>阴影与边框一致形状</p><ul><li>box-shadow<ul><li>可以设置多个阴影效果，用 <strong>逗号,</strong> 隔开</li></ul></li></ul><hr><p>每一个 HTML 元素都有一个默认的 display 属性值。</p><p>display 属性决定了一个元素的显示角色。</p><ul><li>block 和 inline</li></ul><p>块级元素独占一行，高度宽度可控，可包含块级元素和行内元素。</p><p>行内元素不独占一行，高度宽度不可控，只能包含行内元素。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>One Piece</title>
      <link href="/2020/07/22/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/One%20Piece/"/>
      <url>/2020/07/22/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/One%20Piece/</url>
      
        <content type="html"><![CDATA[<p>转载微博 <a href="https://weibo.com/632251283?is_all=1" target="_blank" rel="noopener">@niao床高手</a> 的文章 <a href="https://weibo.com/ttarticle/p/show?id=2309404374749806494586#_0" target="_blank" rel="noopener">海贼王终极探秘古代兵器D的意志空白的一百年</a></p><p>也有人在B站做了一个视频：<a href="https://b23.tv/RwR8hI" target="_blank" rel="noopener">BV1LW411J7Tt</a></p><hr><p>消失的一百年历史：</p><p>​很久很久以前，地球上有海王天王两件古代兵器。</p><p>​900年前，月球移民来到地球，落脚在阳树夏娃附近的土地上建立了一个国家（棉津见在鱼人岛附近发现古代遗迹，证明巨大王国原来所在位置在圣地玛丽乔亚附近）。他们有着强大的科技，高度的文明，人民的思想自由生活富裕，很快发展成一个强大的国家。</p><p>​当时的地球居民经常发生战乱，不同种族之间的矛盾非常尖锐。很快，这群移民者因为他们的理念和先进科技吸引了一大批仰慕者，很多国家愿意与之结盟，并接受他们的思想文化熏陶，其中包括香多拉人、鱼人族人等（拥有刻着古代文字石碑的国家）。</p><p>​该国人民在发展了一百年之后，提出了要创建一个大一统的国家的想法，希望没有国界，世界成为一家，这个国家就叫<strong>One Piece</strong>。因此，红土大陆的存在变成了这种构想的阻碍。</p><p>​为了实现这个目标，乔伊波伊决定研究天王原理发明一种能够在红土大陆打开一个缺口的具有巨大威力的战舰——冥王。然后他告知了鱼人岛的领袖海王波塞冬One Piece的计划，并把研究天王动力来源的成果——玉手箱给了鱼人岛，来证明自己计划的可行性。他们约定让海王类拉着诺亚实现移民，让鱼人与人类在阳光下一起生活。</p><p>​为此，许多国家自愿加入这一计划中，这些参与该计划的人被称为**“Destroy”族**，这些人被接受基因改造，只有他们能够使用冥王且同时他们还能和巨大海王类交流。</p><p>​因为冥王的发动需要吸收一个人的生命，故<strong>不老手术</strong>的作用也因此出现。后来这个被做手术的志愿者（可能是<strong>伊姆</strong>），听过被做了不老手术不仅可以控制冥王，还可以控制天王，便起了贪念。但是天王被该巨大王国所保护，于是贪婪的他决定纠集二十国的国王一起以巨大王国在制造毁灭世界的武器为由，一起将这个国家消灭了，并协商一起拥有天王，建立了一个新的组织，这个组织就是<strong>世界政府</strong>。</p><p>​<strong>阿拉巴斯坦</strong>也在这二十国之中，他们因被蒙蔽而加入征讨，后来在听到了有关如何处理天王的讨论后得知，之前的征讨完全是一种侵略的恶行。然而此时的联合军势力庞大，甚至利用天王杀死了人鱼公主。对天王的占有欲让联合军主张一致，此时的阿拉巴斯坦孤掌难鸣，只能带着忏悔<strong>拒绝入住圣地玛丽乔亚</strong>，回到故国。他们帮助乔伊波伊逃脱，并制造了刻有古代文字的石碑，引向伟大航路的终点。希望后世能够有“D族”人背负起这段历史实现One Piece。</p><p>​而联合军则成为了后来的天龙人，他们自称造物主（神），称能够驾驭冥王毁掉天王的D族人是恶魔（Devil）。他们利用天王制造天地巨变，镇压不服从的人，将巨大王国沉入海底，同时捕杀名字中含有D的人，将他们送往桥上之国于是名字中含有D的人隐藏了自己的D。这就是我猜想的空白一百年发生的故事。</p><hr><p>D族人：Destroy，将红土大陆打开一个缺口，四海归一（One piece，All blue）</p><p>三大古代兵器：</p><ul><li>天王是一条龙：控制天灾</li><li>海王是人鱼公主（白星）：控制海王类</li><li>冥王是一艘船：破坏力极强</li></ul><p>冥王是月球移民仿照天王建造的，都要消耗寿命来发动。</p><p>天龙人应该是有一个通过手术果实获取永生的人控制天王（可能是伊姆），所以才能统治这么久。</p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> One Piece </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-MySQLi</title>
      <link href="/2020/07/21/%E5%AD%A6%E4%B9%A0/Web/PHP/PHP-MySql/"/>
      <url>/2020/07/21/%E5%AD%A6%E4%B9%A0/Web/PHP/PHP-MySql/</url>
      
        <content type="html"><![CDATA[<p>PHP 5 及以上版本建议使用以下方式连接 MySQL :</p><ul><li><strong>MySQLi extension</strong> (“i” 意为 improved)<ul><li>通常是自带的</li></ul></li><li><strong>PDO (PHP Data Objects)</strong><ul><li>PDO可以应用在12种不同的数据库</li></ul></li></ul><p>以下内容全是关于MySQLi（面向对象）的学习。</p><h1 id="mysql-连接"><a class="markdownIt-Anchor" href="#mysql-连接"></a> MySql 连接</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"username"</span>;</span><br><span class="line">$password = <span class="string">"password"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line">$conn = <span class="keyword">new</span> mysqli($servername, $username, $password);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> ($conn-&gt;connect_error) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"连接失败: "</span> . $conn-&gt;connect_error);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">echo</span> <span class="string">"连接成功"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>mysqli() 函数用于创建连接</p><ul><li>除了三个必要参数，还可以添加 dbname、port、​socket 三个参数</li><li>后续可以使用 <strong>select_db()</strong> 函数切换数据库</li></ul></li><li><p>die() 函数用于终结php脚本的进行并显示</p></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 面向对象</span></span><br><span class="line">$conn-&gt;close();</span><br></pre></td></tr></table></figure><h1 id="mysql-操作"><a class="markdownIt-Anchor" href="#mysql-操作"></a> MySql 操作</h1><h2 id="创建-删除数据库"><a class="markdownIt-Anchor" href="#创建-删除数据库"></a> 创建、删除数据库</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在创建连接后，创建一个新的数据库</span></span><br><span class="line">$sql = <span class="string">"CREATE DATABASE myDB"</span>;</span><br><span class="line"><span class="keyword">if</span> ($conn-&gt;query($sql) === <span class="keyword">TRUE</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"数据库创建成功"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"数据库创建失败："</span> . $conn-&gt;error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所创建的数据库</span></span><br><span class="line">$sql = <span class="string">"DROP DATABASE myDB"</span>;</span><br><span class="line"><span class="keyword">if</span> ($conn-&gt;query($sql) === <span class="keyword">TRUE</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"数据库删除成功"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"数据库删除失败："</span> . $conn-&gt;error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建数据表"><a class="markdownIt-Anchor" href="#创建数据表"></a> 创建数据表</h2><p><a href="https://www.runoob.com/sql/sql-datatypes.html" target="_blank" rel="noopener">SQL数据类型</a></p><p>列属性：</p><ul><li><strong>NOT NULL</strong> - 每一行都必须含有值（不能为空），null 值是不允许的。</li><li><strong>DEFAULT value</strong> - 设置默认值</li><li><strong>UNSIGNED</strong> - 使用无符号数值类型，0 及正数</li><li><strong>AUTO INCREMENT</strong> - 设置 MySQL 字段的值在新增记录时每次自动增长 1</li><li><strong>PRIMARY KEY</strong> - 设置数据表中每条记录的唯一标识。 通常列的 PRIMARY KEY 设置为 ID 数值，与 AUTO_INCREMENT 一起使用。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$sql = <span class="string">"CREATE TABLE MyGuests (</span></span><br><span class="line"><span class="string">id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span></span><br><span class="line"><span class="string">pwd CHAR(50) NOT NULL,</span></span><br><span class="line"><span class="string">nickname varchar(50) NOT NULL,</span></span><br><span class="line"><span class="string">reg_date TIMESTAMP</span></span><br><span class="line"><span class="string">)"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($conn-&gt;query($sql) === <span class="keyword">TRUE</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Table MyGuests created successfully"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"创建数据表错误: "</span> . $conn-&gt;error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据表操纵"><a class="markdownIt-Anchor" href="#数据表操纵"></a> 数据表操纵</h2><h3 id="插入数据"><a class="markdownIt-Anchor" href="#插入数据"></a> 插入数据</h3><p>由于 id 是自动增长的，reg_date 是时间戳，因此不需要指定值，MySQL会自动添加的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$sql = <span class="string">"INSERT INTO MyGuests (pwd, nickname) VALUES ('123', 'Eason')"</span>;</span><br><span class="line"><span class="keyword">if</span> ($conn-&gt;query($sql) === <span class="keyword">TRUE</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"新记录插入成功"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Error: "</span> . $sql . <span class="string">"&lt;br&gt;"</span> . $conn-&gt;error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用**分号(😉**将插入语句隔开，可以插入多条数据。</li></ul><h3 id="预处理语句"><a class="markdownIt-Anchor" href="#预处理语句"></a> 预处理语句</h3><p>mysqli 扩展提供了第二种方式用于插入语句，我们可以预处理语句及绑定参数。工作原理如下：</p><ol><li><p>预处理：创建 SQL 语句模板并发送到数据库。预留的值使用参数 “?” 标记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO MyGuests (pwd, nickname) VALUES (?, ?)</span><br></pre></td></tr></table></figure></li><li><p>数据库解析，编译，对 SQL 语句模板执行查询优化，并存储结果不输出</p></li><li><p>执行：最后，将应用绑定的值传递给参数（&quot;?&quot; 标记），数据库执行语句。应用可以多次执行语句，如果参数的值不一样。</p></li></ol><p>预处理语句的优点：</p><ul><li>预处理语句大大减少了分析时间，只做了一次查询（虽然语句多次执行）。</li><li>绑定参数减少了服务器带宽，你只需要发送查询的参数，而不是整个语句。</li><li>预处理语句针对SQL注入是非常有用的，因为参数值发送后使用不同的协议，保证了数据的合法性。</li></ul><p>面向对象的实例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理及绑定</span></span><br><span class="line">$stmt = $conn-&gt;prepare(<span class="string">"INSERT INTO MyGuests (pwd, nickname) VALUES (?, ?)"</span>);</span><br><span class="line">$stmt-&gt;bind_param(<span class="string">"ss"</span>,$pwd,$nickname);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置参数并执行</span></span><br><span class="line">$pwd = <span class="string">"123"</span>;</span><br><span class="line">$nickname = <span class="string">"Eason"</span>;</span><br><span class="line">$stmt-&gt;execute();</span><br><span class="line"></span><br><span class="line">$stmt-&gt;close();</span><br></pre></td></tr></table></figure><ul><li>“?” 可以替换为整型、字符串、双精度浮点型和布尔值</li><li><code>$stmt-&gt;bind_param(&quot;ss&quot;,$pwd,$nickname)</code> 的第一个参数就是各个 “?” 对应的数据类型<ul><li>i - integer（整型）</li><li>d - double（双精度浮点型）</li><li>s - string（字符串）</li><li>b - BLOB（binary large object:二进制大对象）</li></ul></li></ul><h3 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h3><p>使用 select 语句来从数据表中读取数据。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$sql = <span class="string">"select * from MyGuests"</span>;</span><br><span class="line">$result = $conn-&gt;query($sql);</span><br><span class="line"><span class="keyword">if</span> ($result-&gt;num_rows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> ($row = $result-&gt;fetch_assoc())&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"id: "</span> . $row[<span class="string">"id"</span>] . <span class="string">"- Nickname: "</span> . $row[<span class="string">"nickname"</span>] . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"0 结果"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>num_rows() 返回查询结果的行数</li><li>fetch_assoc() 将当前行的数据作为数组返回，并跳到下一行</li></ul><p>对查询语句预处理：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理并绑定参数</span></span><br><span class="line">$stmt = $conn-&gt;prepare(<span class="string">"select * from MyGuests where nickname=?"</span>);</span><br><span class="line">$stmt-&gt;bind_param(<span class="string">"s"</span>,$nickname);</span><br><span class="line"></span><br><span class="line">$nickname = <span class="string">"Eason"</span>;</span><br><span class="line">$stmt-&gt;execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面有两种方式</span></span><br><span class="line"><span class="comment">// 直接对 $stmt 操作，使用 bind_result() 来绑定全部参数，然后 fetch() 切换至下一行</span></span><br><span class="line">$stmt-&gt;bind_result($id,$pwd,$nickname,$reg_date);</span><br><span class="line"><span class="keyword">while</span> ($stmt-&gt;fetch())&#123;</span><br><span class="line">    <span class="keyword">echo</span> $id . <span class="string">" "</span> . $nickname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 get_result() 来获取 mysqli_result</span></span><br><span class="line">$result = $stmt-&gt; get_result();</span><br><span class="line"><span class="keyword">if</span> ($result-&gt;num_rows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> ($row = $result-&gt;fetch_assoc())&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"id: "</span> . $row[<span class="string">"id"</span>] . <span class="string">"- Nickname: "</span> . $row[<span class="string">"nickname"</span>] . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"0 结果"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放查询结果并关闭预处理语句</span></span><br><span class="line">$stmt-&gt;free_result();</span><br><span class="line">$stmt-&gt;close();</span><br></pre></td></tr></table></figure><h3 id="更新"><a class="markdownIt-Anchor" href="#更新"></a> 更新</h3><p>使用 update 语句来更新</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更改Eason的密码</span></span><br><span class="line">$sql = <span class="string">"update MyGuests set pwd = '321' where nickname = 'Eason'"</span>;</span><br><span class="line">$conn-&gt;query($sql);</span><br></pre></td></tr></table></figure><h3 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h3><p>DELETE FROM 语句用于从数据库表中删除行。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> MySQLi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP表单</title>
      <link href="/2020/07/20/%E5%AD%A6%E4%B9%A0/Web/PHP/PHP%E8%A1%A8%E5%8D%95/"/>
      <url>/2020/07/20/%E5%AD%A6%E4%B9%A0/Web/PHP/PHP%E8%A1%A8%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<p><strong>PHP 超级全局变量 $_GET 和 $_POST 用于收集表单数据（form-data）。$_REQUEST 同时支持 post 和 get 但是速度较慢。</strong></p><p>当处理 HTML 表单时，PHP 能把来自 HTML 页面中的表单元素自动变成可供 PHP 脚本使用。</p><p>对于HTML的表单，参照本博客的另一篇文章：HTML标签。</p><ul><li>使用 <strong>isset()</strong> 函数来判断 $_GET 和 $_POST 中的项是否被设置，使用 <strong>empty()</strong> 函数来判断是否有输入<ul><li>前者有定义就为true，后者值不为空才为true</li></ul></li><li><strong>htmlspecialchars()</strong> 函数把预定义的字符转换为 HTML 实体。</li></ul><p>在 PHP 的表单中的 action，使用 <code>action=&quot;&lt;?php echo htmlspecialchars($_SERVER[&quot;PHP_SELF&quot;]);?&gt;&quot;</code> 来防止 <code>$_SERVER[&quot;PHP_SELF&quot;]</code>  被利用</p><hr><p>当用户提交表单时，做一下两件事情：</p><ol><li>使用 PHP trim() 函数去除用户输入数据中不必要的字符 (如：空格，tab，换行)。</li><li>使用PHP stripslashes()函数去除用户输入数据中的反斜杠 ()</li></ol><p>通常将这些过滤的函数写在一个自己定义的函数，提高代码复用性：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test_input</span><span class="params">($data)</span></span>&#123;</span><br><span class="line">$data = trim($data);</span><br><span class="line">    $data = stripslashes($data);</span><br><span class="line">    $data = htmlspecialchars($data);</span><br><span class="line">    <span class="keyword">return</span> $data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em><strong>$_GET</strong></em></p><p>预定义的 $_GET 变量用于收集来自 <strong>method=“get”</strong> 的表单中的值。</p><p>从带有 GET 方法的表单发送的信息，<strong>对任何人都是可见的（会显示在浏览器的地址栏）</strong>，并且对发送信息的量也有限制。</p><p>HTTP GET 方法不适合大型的变量值。它的值是<strong>不能超过 2000 个字符</strong>的。</p><hr><p><em><strong>$_POST</strong></em></p><p>预定义的 $_POST 变量用于收集来自 <strong>method=“post”</strong> 的表单中的值。</p><p>从带有 POST 方法的表单发送的信息，<strong>对任何人都是不可见的</strong>（不会显示在浏览器的地址栏），并且对发送信息的量也<strong>没有限制</strong>。</p><ul><li>默认情况下，POST 方法的发送信息的量<strong>最大值为 8 MB</strong>（可通过设置 php.ini 文件中的 <strong>post_max_size</strong> 进行更改）。</li></ul><hr><p><em><strong>$_REQUEST</strong></em></p><p>预定义的 $_REQUEST 变量包含了 ​$_GET、​$_POST 和 $_COOKIE 的内容。</p><p>$_REQUEST 变量可用来收集通过 GET 和 POST 方法发送的表单数据。</p><ul><li>但是，速度较慢</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP语法</title>
      <link href="/2020/07/18/%E5%AD%A6%E4%B9%A0/Web/PHP/PHP%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/07/18/%E5%AD%A6%E4%B9%A0/Web/PHP/PHP%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>PHP的全称是<strong>PHP: Hypertext Preprocessor</strong>，递归定义。</p><p>PHP 是服务器端脚本语言，是一门<strong>弱类型</strong>语言。</p><p>PHP 脚本在服务器上执行，然后将纯 HTML 结果发送回浏览器。</p><h1 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h1><p>PHP 脚本可以放在文档中的任何位置。</p><p>PHP 脚本以 <strong><?php** 开始，以 **?></strong> 结束：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// PHP 代码</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>echo</strong> 和 <strong>print</strong> 都可以在浏览器输出文本。</p><h1 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h1><p>// 、 /* */、#</p><h1 id="变量规则"><a class="markdownIt-Anchor" href="#变量规则"></a> 变量规则</h1><ul><li><p>变量以 <strong>$</strong> 符号开始，后面跟着变量的名称</p></li><li><p>变量名必须以<strong>字母或者下划线字符开始</strong></p></li><li><p>变量名只能包含字母数字字符以及下划线（<strong>A-z、0-9 和 _</strong> ）</p></li><li><p>变量名<strong>不能包含空格</strong></p></li><li><p>变量名是<strong>区分大小写</strong>的（$y 和 $Y 是两个不同的变量）</p></li></ul><p>PHP 没有声明变量的命令，和Python一样。</p><p>作用域：local、global、static、parameter</p><ul><li>函数外部定义的变量拥有全局作用域，要在一个函数中访问一个全局变量，需要使用 <strong>global</strong> 关键字。</li><li>PHP 将所有全局变量存储在一个名为 $GLOBALS[<em>index</em>] 的数组中</li><li>在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问。</li></ul><h1 id="echo-和-print"><a class="markdownIt-Anchor" href="#echo-和-print"></a> echo 和 print</h1><ul><li>echo - 可以输出一个或多个字符串</li><li>print - 只允许输出一个字符串，返回值总为 1</li><li>echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。</li></ul><h1 id="eofheredoc"><a class="markdownIt-Anchor" href="#eofheredoc"></a> EOF(heredoc)</h1><ol><li><p>必须后接分号，否则编译通不过。</p></li><li><p><strong>EOF</strong> 可以用任意其它字符代替，只需保证结束标识与开始标识一致。</p></li><li><p><strong>结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)</strong></p></li><li><p>开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。</p></li><li><p>当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法。</p></li></ol><h1 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h1><p>String、Integer、Float、Boolean、Array、Object、NULL</p><ul><li><p><strong>var_dump()</strong> 函数返回变量的<strong>数据类型和值</strong>，自带输出功能</p></li><li><p><strong>array()</strong> 函数创建数组</p></li><li><p><strong>class</strong> 关键字声明类对象</p></li></ul><h1 id="类型比较"><a class="markdownIt-Anchor" href="#类型比较"></a> 类型比较</h1><ul><li><p>松散比较：使用两个等号 <strong>==</strong> 比较，只比较值，不比较类型。</p></li><li><p>严格比较：用三个等号 <strong>===</strong> 比较，除了比较值，也比较类型。</p></li><li><p>0、false、null松散比较相等，但是严格比较不相等</p></li></ul><h1 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h1><p>常量是一个简单值的标识符。该值在脚本中不能改变。</p><ul><li><p>常量名<strong>不需要加 $ 修饰符</strong>，如果使用时加了就是一个新的变量了</p></li><li><p>常量在整个脚本中都可以使用，即常量是全局的</p></li></ul><p>使用 <strong>define()</strong> 函数设置常量，不能在函数中定义</p><p><code>bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )</code></p><ul><li>**name：**必选参数，常量名称，即标志符。</li><li>**value：**必选参数，常量的值。</li><li><strong>case_insensitive</strong> ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。</li></ul><p>const也可以定义常量，但是只能是静态常量</p><h1 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h1><p><strong>单引号</strong>或者<strong>双引号</strong>都可以用于定义字符串。</p><ul><li><p><strong>并置运算符 (.)</strong> 用于把两个字符串值<strong>连接</strong>起来。</p></li><li><p><strong>strlen() 函数</strong>返回字符串的<strong>长度（字节数）</strong>。</p></li><li><p><strong>strpos() 函数</strong>用于在字符串内<strong>查找</strong>一个字符或一段指定的文本。</p></li></ul><h1 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h1><ul><li><p>算符运算符：+、-、*、/、%、-、.</p></li><li><p>赋值运算符：=、+=、-=、*=、/=、%=、.=</p></li><li><p>自增自减：++、–</p></li><li><p>比较运算符：==、===、!=、&lt;&gt;、!==、&gt;、&lt;、&gt;=、&lt;=</p></li><li><p>逻辑运算符：and、or、xor、&amp;&amp;、||、!</p></li><li><p>数组运算符：+、==、===、!=、&lt;&gt;、!==</p></li><li><p>三元运算符：?:</p></li><li><p>组合运算符：&lt;=&gt;</p></li></ul><h1 id="条件与循环"><a class="markdownIt-Anchor" href="#条件与循环"></a> 条件与循环</h1><p><em><strong>条件语句</strong></em></p><ul><li>if、if-else、if-else if-else</li><li>switch</li></ul><p><em><strong>循环语句</strong></em></p><ul><li>while、do-while</li><li>for、foreach</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始值; 条件; 增量)&#123;&#125;</span><br><span class="line"><span class="keyword">foreach</span> ($array <span class="keyword">as</span> $value)&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h1><p>数组是一个能在单个变量中存储多个值的特殊变量。</p><p>PHP中有三种类型的数组：</p><ul><li><strong>数值数组</strong>：带有数值ID键的数组，类似于Python的元组</li><li><strong>关联数组</strong>：带有指定的键的数组，类似于Python中的字典<ul><li>使用=&gt;来关联键值对，如&quot;Eason&quot; =&gt; “Kailey”</li></ul></li><li><strong>多维数组</strong>：包含一个或多个数组的数组</li></ul><p><strong>count() 函数</strong>用于返回数组的长度（元素的数量）</p><p><strong>print_r() 函数</strong>可以打印出数组</p><p>用 <strong>for、foreach</strong> 遍历数组</p><ul><li>在关联数组中，foreach应该这样写 <code>foreach($arr as $x=&gt;$x_value){}</code></li></ul><h2 id="数组排序"><a class="markdownIt-Anchor" href="#数组排序"></a> 数组排序</h2><ul><li><strong>sort()</strong> - 对数组进行升序排列</li><li><strong>rsort()</strong> - 对数组进行降序排列</li><li><strong>asort()</strong> - 根据关联数组的值，对数组进行升序排列</li><li><strong>ksort()</strong> - 根据关联数组的键，对数组进行升序排列</li><li><strong>arsort()</strong> - 根据关联数组的值，对数组进行降序排列</li><li><strong>krsort()</strong> - 根据关联数组的键，对数组进行降序排列</li></ul><h1 id="超级全局变量"><a class="markdownIt-Anchor" href="#超级全局变量"></a> 超级全局变量</h1><p>PHP中预定了几个<strong>超级全局变量(superglobals)</strong>，这意味着它们在一个脚本的全部作用域中都可用。</p><p>PHP中的所有的超级全局变量：<strong>$GLOBALS、$_SERVER、$_REQUEST、$_POST、$_GET、$_FILES、$_ENV、$_COOKIE、$_SESSION</strong></p><ol><li><p><strong>$GLOBALS</strong></p><p>$GLOBALS 是PHP的一个超级全局<strong>变量组</strong>，包含了<strong>全部变量</strong>，变量的名字就是数组的键。</p></li><li><p><strong>$_SERVER</strong></p><p>$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。</p></li><li><p><strong>$_REQUEST</strong></p><p>$_REQUEST 用于收集HTML表单提交的数据，包含了$_POST、$_GET、$_COOKIE，速度较慢</p></li><li><p><strong>$_POST</strong></p><p>$_POST 被广泛应用于收集表单数据，在HTML form标签的指定该属性：&quot;method=“post”。</p></li><li><p><strong>$_GET</strong></p><p>$_GET 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：&quot;method=“get”。</p></li></ol><h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1><p>PHP 提供了超过 1000 个内建的函数。</p><p><em><strong>创建PHP函数</strong></em></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span><span class="params">($arg)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 要执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>PHP函数准则：</p><ul><li>函数的名称应该提示出它的功能</li><li>函数名称以字母或下划线开头（不能以数字开头）</li></ul><p>参数名依旧以**$**开头</p><p>使用<strong>return</strong>来返回</p><p>函数的名称和关键词大小写都不敏感。</p><h1 id="魔术常量"><a class="markdownIt-Anchor" href="#魔术常量"></a> 魔术常量</h1><p>PHP有八个魔术变量，它们的值随着它们在代码中的位置改变而改变。</p><ol><li><p><strong>__LINE__</strong></p><p>文件中的<strong>当前行号</strong>。</p></li><li><p><strong>__FILE__</strong></p><p>文件的完整路径和文件名（<strong>绝对路径</strong>）。如果用在被包含文件中，则返回被包含的文件名。</p></li><li><p><strong>__DIR__</strong></p><p><strong>文件所在的目录</strong>。如果用在被包括文件中，则返回被包括的文件所在的目录。</p></li><li><p><strong>__FUNCTION</strong></p><p><strong>函数名称</strong>。PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。</p></li><li><p><strong>__CLASS__</strong></p><p><strong>类的名称</strong>。PHP 5 起本常量返回该类被定义时的名字（区分大小写）。对 trait 也起作用。</p></li><li><p><strong>__TRAIT__</strong></p><p><strong>Trait 的名字</strong>。自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。</p></li><li><p><strong>__METHOD__</strong></p><p><strong>类的方法名</strong>（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。</p></li><li><p><strong>__NAMESPACE__</strong></p><p><strong>当前命名空间的名称</strong>（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。</p></li></ol><h1 id="命名空间"><a class="markdownIt-Anchor" href="#命名空间"></a> 命名空间</h1><p>PHP 命名空间可以解决以下两类问题：</p><ol><li>用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。</li><li>为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。</li></ol><h2 id="定义命名空间"><a class="markdownIt-Anchor" href="#定义命名空间"></a> 定义命名空间</h2><p>默认情况下，所有常量、类和函数名都放在全局空间下，就和PHP支持命名空间之前一样。</p><p>命名空间通过关键字 <strong>namespace</strong> 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间。语法格式如下；</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="comment">// 定义代码在 'MyProject' 命名空间中  </span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span>;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// ... 代码 ...  </span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>将全局的非命名空间中的代码与命名空间中的代码组合在一起，只能使用<strong>大括号</strong>形式的语法。<strong>全局代码</strong>必须用一个<strong>不带名称的 namespace</strong> 语句加上大括号括起来.</p><p>命名空间必须是<strong>程序脚本的第一条语句</strong>.</p><h2 id="子命名空间"><a class="markdownIt-Anchor" href="#子命名空间"></a> 子命名空间</h2><p>与目录和文件的关系很像，PHP 命名空间也允许指定层次化的命名空间的名称。因此，命名空间的名字可以使用分层次的方式定义：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span>\<span class="title">Sub</span>\<span class="title">Level</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="命名空间使用"><a class="markdownIt-Anchor" href="#命名空间使用"></a> 命名空间使用</h2><p>PHP 命名空间中的类名可以通过三种方式引用：</p><ol><li><strong>非限定名称，或不包含前缀的类名称</strong></li><li><strong>限定名称,或包含前缀的名称</strong></li><li><strong>完全限定名称，或包含了全局前缀操作符的名称</strong></li></ol><h2 id="使用命名空间别名导入"><a class="markdownIt-Anchor" href="#使用命名空间别名导入"></a> 使用命名空间：别名/导入</h2><ol><li>使用use操作符导入/使用别名</li><li>use语句导入多个命名空间</li><li>导入和动态名称</li><li>导入和完全限定名称</li></ol><h1 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h1><h2 id="类定义"><a class="markdownIt-Anchor" href="#类定义"></a> 类定义</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">phpClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> $var1;</span><br><span class="line"><span class="keyword">var</span> $var2 = <span class="string">"constant string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myfunc</span><span class="params">($arg1, $arg2)</span></span>&#123;</span><br><span class="line">[..]</span><br><span class="line">&#125;</span><br><span class="line">[..]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li>类使用 <strong>class</strong> 关键字后加上类名定义。</li><li>类名后的一对大括号({})内可以定义变量和方法。</li><li>类的变量使用 <strong>var</strong> 来声明, 变量也可以初始化值。</li><li>函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问。</li></ul><p>类中有一个变量 <strong>$this</strong> 代表自身的对象。</p><p>此外还有 <strong>self</strong>、<strong>parent</strong>、<strong>static</strong> 关键字</p><ul><li><strong>self::</strong> 访问本类中的静态成员</li><li><strong>static::</strong> 访问调用类中的静态成员</li><li><strong>parent::</strong> 访问父类中的静态成员和调用父类的函数</li></ul><p><strong>PHP_EOL</strong> 为换行符，但是在浏览器中并不能显示，只对文本文件有效。</p><h2 id="创建对象"><a class="markdownIt-Anchor" href="#创建对象"></a> 创建对象</h2><p>使用 <strong>new</strong> 运算符来实例化该类的对象。</p><p>使用 <strong>-&gt;</strong> 运算符来访问成员方法与成员变量。</p><ul><li>访问成员变量时，变量名无需加 <strong>$</strong></li></ul><h2 id="构造-析构"><a class="markdownIt-Anchor" href="#构造-析构"></a> 构造、析构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数定义</span><br><span class="line">void __construct ([ mixed $args [, $... ]] ) &#123;&#125;</span><br><span class="line">// 析构函数</span><br><span class="line">void __destruct ( void ) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h2><p>使用关键字 <strong>extends</strong> 来继承一个类，PHP 不支持多继承</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line"><span class="comment">// 代码部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>方法重写</strong></em></p><p>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的<strong>覆盖（override）</strong>，也称为方法的重写。</p><h2 id="访问权控制"><a class="markdownIt-Anchor" href="#访问权控制"></a> 访问权控制</h2><p>PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。</p><ul><li>**public（公有）：**公有的类成员可以在任何地方被访问。</li><li>**protected（受保护）：**受保护的类成员则可以被其自身以及其子类和父类访问。</li><li>**private（私有）：**私有的类成员则只能被其定义所在的类访问。</li></ul><p>如果用 <strong>var</strong> 定义，则被视为 public</p><p><em><strong>方法的访问控制</strong></em></p><p>类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。</p><h2 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h2><p>接口是通过 <strong>interface</strong> 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是<strong>空的且public</strong>。</p><p>要实现一个接口，使用 <strong>implements</strong> 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。</p><h2 id="常量-2"><a class="markdownIt-Anchor" href="#常量-2"></a> 常量</h2><p>使用 <strong>const</strong> 关键词在类中定义常量，无需使用 <strong>$</strong> 符号。</p><p>常量的值<strong>必须是一个定值</strong>，不能是变量，类属性，数学运算的结果或函数调用。</p><ul><li>在类中使用 <strong>self::变量名</strong> 来访问常量</li></ul><h2 id="抽象类"><a class="markdownIt-Anchor" href="#抽象类"></a> 抽象类</h2><p>任何一个类，如果它里面<strong>至少有一个方法是被声明为抽象</strong>的，那么这个类就<strong>必须被声明为抽象类</strong>。</p><p><strong>抽象类不能实例化</strong>。</p><p>继承一个抽象类的时候，子类必须<strong>定义父类中的所有抽象方法</strong>；另外，这些方法的<strong>访问控制必须和父类中一样（或者更为宽松）</strong></p><p>此外，子类方法可以<strong>包含父类抽象方法中不存在的<em>可选参数</em></strong>。</p><h2 id="static-关键字"><a class="markdownIt-Anchor" href="#static-关键字"></a> Static 关键字</h2><p>声明类属性或方法为 static(静态)，就可以不实例化类而直接访问。</p><p>静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。</p><p>由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。</p><p>静态属性不可以由对象通过 -&gt; 操作符来访问。</p><p>使用 self:: 或者 static:: 都可以访问。</p><h2 id="final-关键字"><a class="markdownIt-Anchor" href="#final-关键字"></a> Final 关键字</h2><p>如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。</p><h2 id="调用父类构造函数"><a class="markdownIt-Anchor" href="#调用父类构造函数"></a> 调用父类构造函数</h2><p>PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 <strong>parent::__construct()</strong> 。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML标签</title>
      <link href="/2020/07/15/%E5%AD%A6%E4%B9%A0/Web/%E5%89%8D%E7%AB%AF/HTML%E6%A0%87%E7%AD%BE/"/>
      <url>/2020/07/15/%E5%AD%A6%E4%B9%A0/Web/%E5%89%8D%E7%AB%AF/HTML%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<p><code>&lt;!DOCTYPE html&gt;</code> 是一个<strong>声明</strong>，表示该文档是由 <strong>HTML5</strong> 进行编写的。</p><hr><p><code>&lt;meta&gt;</code>：描述页面内容，关键词，作者，最新修订时间以及其它<strong>元信息</strong>。</p><p>永远位于head元素内部，元数据总是以名称/值的形式被成对传递。</p><ul><li>解决编码问题，将编码设置为UTF-8</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>实现网页尺寸“自适应”</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewpoint"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>搜索引擎优化：描述网页内容，定义网页关键词、网页作者</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"网页关键词"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"描述网页的内容"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"网页作者"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>网页自动刷新，可以用于重定向</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"3;http://39.107.228.148/"</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p><code>&lt;sytle&gt;</code>：为HTML文档定义<strong>样式信息</strong>。</p><p>style元素可以出现在HTML文档的各个部分，一个文档可以包含多个style元素。</p><p>style的属性有：</p><ul><li>media：指定样式适用的媒体<ul><li>可以使用逻辑运算符</li></ul></li><li>scoped：指定样式的作用范围，只有Firefox支持</li><li>type：指定样式的类型，目前的值只总是text/css</li></ul><hr><p><code>&lt;link&gt;</code> ：指定<strong>外部资源</strong>，最常用的是链接样式表、链接网站图标</p><p>link元素定义了6个属性：</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>href</td><td>URL</td><td>指定被链接资源的URL。</td></tr><tr><td>hreflang</td><td>language_code</td><td>指定被链接资源使用的语言。</td></tr><tr><td>sizes</td><td>Height x Width</td><td>指定图标的大小（比如<code>sizes=&quot;16x16&quot;</code>）</td></tr><tr><td>media</td><td>media_query</td><td>指定被链接的资源将被显示到什么设备上。</td></tr><tr><td>rel</td><td>alternate、author、help、icon、licence、<br>next、pingback、prefetch、prev、search、sidebar、<br>stylesheet、tag</td><td>指定当前文档与被链接资源之间的关系。</td></tr><tr><td>type</td><td>MIME_type</td><td>规定被链接文档的 MIME 类型。</td></tr></tbody></table><ul><li>其中rel属性必选，它说明了当前文档与被链接资源之间的关系</li></ul><hr><p><code>&lt;base&gt;</code> ：设置相对 URL 的<strong>解析基准</strong>。</p><p>必须位于<code>&lt;head&gt;</code>标签内部，并尽量靠前，以便随后的元素中的相对URL可以用上其设置的基准URL</p><p>定义了两个属性：</p><ul><li>href：指定该 HTML 文档中所有相对链接的基准 URL</li><li>target：指定在何处打开超链接<ul><li>_blank：在新窗口中打开</li><li>_parent：在当前的父窗口中打开，如果不存在父窗口，此选项的行为方式与 _self 等同</li><li>_self：当前窗口打开（默认）</li><li>_top：在整个窗口中打开</li><li>framename：在指定的框架中打开</li></ul></li></ul><hr><p><code>&lt;script&gt;</code> ：在 HTML 文档中加入<strong>脚本</strong>（例如 JavaScript）。</p><p>script 元素既可以直接定义内嵌脚本语句，也可以通过 src 属性引用外部脚本文件。</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>type</td><td>media_type</td><td>指定所定义或引用的脚本类型（如果使用 JavaScript 脚本，这个属性可以忽略）。</td></tr><tr><td>async</td><td>async</td><td>告诉浏览器异步执行脚本。<br>注意：该属性只能用于引用外部脚本文件，对内嵌脚本不起作用。</td></tr><tr><td>charset</td><td>charset</td><td>指定外部脚本文件中使用的字符编码。<br>注意：该属性只能与 src 属性一起使用。</td></tr><tr><td>defer</td><td>defer</td><td>告诉浏览器延迟执行脚本（直到<strong>页面载入并解析完毕</strong>后再执行脚本）。<br>注意：该属性只能用于引用外部脚本文件，对内嵌脚本不起作用。</td></tr><tr><td>src</td><td>URL</td><td>指定外部脚本文件的 URL。</td></tr></tbody></table><p><code>&lt;noscript&gt;</code> 标签：向不支持 JavaScript 的浏览器显示一些替代内容。</p><hr><p><code>&lt;!--...--&gt;</code> ：在源文档中插入<strong>注释</strong>。注释不会在浏览器中显示。</p><ul><li><p>CSS的注释：/* */，在Style标签中也用这种注释方法</p></li><li><p>JavaScript的注释：与C语言一致，//和/* */</p></li></ul><hr><p><code>&lt;span&gt;</code> ：组合文档中的<strong>行内元素</strong>。</p><hr><p><code>&lt;pre&gt;</code> ：定义<strong>预格式化的文本</strong>。</p><ul><li>保留空格和换行符，文本自身也会呈现为等宽实体</li><li>HTML中有预留字符，须替换成字符实体才能正常显示</li></ul><p><code>&lt;code&gt;</code> ：定义计算机<strong>代码</strong>片段。</p><ul><li>要显示多行代码时，使用<code>&lt;pre&gt;</code>中嵌套<code>&lt;code&gt;</code></li></ul><p><code>&lt;var&gt;</code> ：定义程序的<strong>变量</strong>。</p><p><code>&lt;kbd&gt;</code> ：定义键盘<strong>输入文本</strong>。</p><p><code>&lt;samp&gt;</code> ：定义计算机程序的<strong>输出</strong>。</p><hr><p><em><strong>引用大作战：</strong></em></p><p><code>&lt;q&gt;</code> ：定义<strong>较短的引用</strong>。</p><ul><li>浏览器通常会在引用内容的两侧添加引号。</li></ul><p><code>&lt;blockquote&gt;</code> 标签：定义<strong>块引用</strong>。</p><ul><li>使用缩进表示引用</li></ul><p><code>&lt;cite&gt;</code> ：定义作品（比如书籍、歌曲、电影、电视节目、绘画、雕塑等）的<strong>标题</strong>。</p><p><code>&lt;abbr&gt;</code> ：定义<strong>简称或缩写</strong>，比如 “WWW” 或 “NATO”。</p><ul><li>通过对缩写进行标记，能够为浏览器、拼写检查和搜索引擎提供有用的信息。</li></ul><p><code>&lt;dfn&gt;</code> ：表现定义中的<strong>术语</strong>。</p><p><code>&lt;address&gt;</code> ：定义文档或文章的作者/拥有者的<strong>联系信息</strong>。</p><ul><li>在<code>&lt;body&gt;</code>标签内则表示文档的联系信息；在<code>&lt;article&gt;</code>标签内则表示文章的联系信息</li></ul><p><code>&lt;ruby&gt;</code> ：定义<strong>注音符号</strong>。与rt、rp元素配合</p><ul><li>rt 元素用来标记注音符号</li><li>rp 元素则用来标记当浏览器不支持 ruby 元素时所显示的内容。</li></ul><p><code>bdo</code> ：修改默认的<strong>文本方向</strong>。</p><ul><li>属性dir：ltr（left to right）；rtl（right to left）</li></ul><hr><p><em><strong>格式化大比拼：</strong></em></p><p><code>&lt;strong&gt;</code> ：定义表示<strong>重要</strong>的文本。</p><ul><li>一般是粗体，语义表示重要</li></ul><p><code>&lt;b&gt;</code> ：定义表示<strong>粗体</strong>的文本。</p><ul><li>只表示粗体，没有语义</li></ul><p><code>&lt;em&gt;</code> ：定义表示<strong>强调</strong>的文本。</p><p><code>&lt;i&gt;</code> ：定义表示<strong>斜体</strong>的文本。</p><p>HTML5规范推荐使用 css 样式来实现粗体、斜体</p><p><code>&lt;del&gt;</code>：定义文<strong>已被删除</strong>的文本。</p><p><code>&lt;ins&gt;</code> ：定义<strong>新插入</strong>的文本。</p><p><code>&lt;s&gt;</code>：定义那些<strong>不正确</strong>的文本</p><p><code>&lt;u&gt;</code>：定义与常规文本<strong>风格不同</strong>的文本。</p><p><code>&lt;mark&gt;</code> ：定义<strong>带有标记</strong>的文本。</p><p><code>&lt;sub&gt;</code> ：定义<strong>下标</strong>文本。</p><p><code>&lt;sup&gt;</code> ：定义<strong>上标</strong>文本。</p><p><code>&lt;small&gt;</code> ：定义<strong>更小字体</strong>的文本（比如旁注）。</p><hr><p><em><strong>列表</strong></em></p><p><code>&lt;li&gt;</code> 标签用于定义<strong>列表中的项目</strong>。</p><p><code>&lt;ol&gt;</code> 标签用于定义<strong>有序</strong>列表。</p><ul><li>属性：reversed（降序）、start（起始值）、type（编号类型：1、A、a、I、i）</li></ul><p><code>&lt;ul&gt;</code> 标签用于定义<strong>无序</strong>列表。</p><p>两个常用的CSS属性：list-style-type，list-style-image</p><hr><p><em><strong>定义列表</strong></em></p><p><code>&lt;dl&gt;</code> 标签定义了一个包含<strong>术语定义以及描述</strong>的列表。</p><p><code>&lt;dt&gt;</code> 标签用于定义列表中的项目（即<strong>术语部分</strong>）。</p><p><code>&lt;dd&gt;</code> 标签用于定义列表中项目的<strong>描述部分</strong>。</p><hr><p><em><strong>表格</strong></em></p><p><code>&lt;table&gt;</code> 标签用于定义 HTML <strong>表格</strong>。</p><ul><li>简单的表格由table元素以及一个或多个<code>&lt;tr&gt;</code>、<code>&lt;th&gt;</code> 或 <code>&lt;td&gt;</code></li><li>tr(row) 元素定义表格中的行，th(header) 元素定义表格中的表头，td(data) 元素定义表格中的单元格。</li><li><code>&lt;th&gt;</code>、<code>&lt;td&gt;</code> 都有 colspan、rowspan来设置跨列、跨行</li><li>使用css来设置表格的样式：border、border-collapse、padding……</li></ul><p><code>&lt;caption&gt;</code> 元素定义<strong>表格标题</strong>。</p><ul><li>必须紧随<code>&lt;table&gt;</code> 标签之后，一个表格只有一个标题</li></ul><p><code>&lt;thead&gt;</code> 标签定义表格的<strong>表头</strong>。</p><ul><li>应该与<code>&lt;tfoot&gt;</code>和 <code>&lt;tbody&gt;</code> 元素结合起来使用</li></ul><p><code>&lt;colgroup&gt;</code> ：对表格中的<strong>列进行组合</strong>，以便对其进行格式化。</p><ul><li>只能在<code>&lt;table&gt;</code> 元素中使用</li></ul><hr><p><em><strong>表单</strong></em></p><p><code>&lt;form&gt;</code> ：为用户输入创建 HTML <strong>表单</strong>。用于<strong>向服务器传输数据</strong>。</p><ul><li>设置 enctype=“<strong>multipart/form-data</strong>” 来上传文件</li></ul><p><code>&lt;input&gt;</code> ：<strong>搜集用户信息</strong>。</p><ul><li>可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等等</li><li>autocomplete 属性来设置自动填充</li><li>method 属性设置发送 form-data 的 HTTP 方法：get或post</li><li>disabled 和 readonly，两者都使用户不能输入，但是后者会提交</li><li>可以利用 hidden 类型，name=“MAX_FILE_SIZE” 来限制上传文件的大小</li></ul><p><code>&lt;button&gt;</code>：定义一个<strong>按钮</strong>。</p><ul><li>始终要设置 type(button、reset、submit) 属性，因为不同的浏览器可能有不同的默认值</li><li>input 元素也可以设置成按钮的样式</li></ul><p><code>&lt;label&gt;</code>：为 input 元素定义<strong>标注</strong>（标记）。</p><ul><li>为鼠标用户改进了可用性</li><li><code>&lt;label&gt;</code> 标签的 <strong>for 属性</strong>应当与相关元素的 <strong>id 属性</strong>相同</li></ul><p><code>&lt;fieldset&gt;</code> ：将表单内容的一部分<strong>打包</strong>，生成一组相关表单的字段。</p><p><code>&lt;legend&gt;</code> ：标签用于<strong>为 fieldset 元素定义说明文字</strong>。</p><ul><li>必须是 fieldset 元素的<strong>第一个子元素</strong></li></ul><p><code>&lt;select&gt;</code> ：创建<strong>单选或多选菜单</strong>。</p><p><code>&lt;option&gt;</code> ：定义<strong>下拉列表</strong>中的一个<strong>选项</strong>。</p><ul><li><code>&lt;option&gt;</code> 标签中的内容作为 <code>&lt;select&gt;</code> 标签的菜单或是滚动列表中的一个元素显示</li></ul><p><code>&lt;optgroup&gt;</code> ：为下拉列表的选项进行<strong>分组</strong>。</p><p><code>&lt;datalist&gt;</code> ：规定了 <code>&lt;input&gt;</code> 标签<strong>可能的选项</strong>列表。</p><ul><li>使用 <code>&lt;input&gt;</code> 标签的 list 属性来绑定 <code>&lt;datalist&gt;</code> 标签的ID值</li><li>使用<code>&lt;option&gt;</code> 来定义选项</li></ul><p><code>&lt;output&gt;</code> ：将计算结果输出显示（比如执行脚本的输出）。</p><ul><li>需要设置 <code>&lt;form&gt;</code> 的 oninput 属性</li></ul><p><code>&lt;textarea&gt;</code> ：定义多行的文本输入控件。</p><ul><li>wrap属性设置hard、soft，设置为hard时要设置cols属性</li></ul><hr><p><em><strong>语义化结构</strong></em></p><p>语义化的优点：HTML结构清晰、代码可读性好、无障碍阅读、便于维护开发……</p><p>每个HTML元素其实都是一个方框的形式呈现的。</p><p><code>&lt;div&gt;</code> ： HTML 文档中的一个分隔区块或者一个区域部分。</p><ul><li>div 是一个块级的<strong>无语义</strong>元素，经常与 CSS 一起使用</li></ul><p>HTML5 新添加了许多语义化元素：article、aside、data、details……</p><hr><p><em><strong>图片</strong></em></p><p><code>&lt;img&gt;</code> ：用于向网页中嵌入一幅图像。</p><ul><li><code>&lt;img&gt;</code> 标签有两个必需的属性：src 属性（图片的URL） 和 alt 属性（图片的替代文本）。</li></ul><p><code>&lt;map&gt;</code> ：一个客户端图像映射。图像映射（image-map）指带有可点击区域的一幅图像。</p><p><code>&lt;area&gt;</code> ：图像映射中的区域（注：图像映射指得是带有可点击区域的图像）。</p><ul><li>area 元素总是嵌套在 <code>&lt;map&gt;</code> 标签中。</li></ul><p><code>&lt;picture&gt;</code> ：为其内部特定的 img 元素提供多样的 source 元素。</p><p><code>&lt;figure&gt;</code> ：规定独立的流内容（图像、图表、照片、代码等等）。</p><p><code>&lt;figcaption&gt;</code> ：为 figure 元素定义标题。</p><hr><p><em><strong>多媒体</strong></em></p><p><code>&lt;video&gt;</code> ：视频，比如电影片段或其他视频流。</p><ul><li><p>属性：src（URL）、width（宽度）、height（高度）、autoplay（自动播放）、controls（显示控制控件）、loop（循环播放）、muted（静音）、poster（视频加载时显示的图像）、preload（是否预加载）</p></li><li><p>目前支持三种视频格式：MP4、WebM、Ogg</p></li></ul><p><code>&lt;audio&gt;</code> ：声音，比如音乐或其他音频流。</p><ul><li>比<code>&lt;video&gt;</code>标签少了三个属性：width、height、poster</li><li>目前支持三种音频格式：MP3、Wav、Ogg</li></ul><p><code>&lt;track&gt;</code> ：为 HTML5 的媒体文件添加字幕。</p><ul><li>字幕格式WebVTT，后缀为 .vtt</li></ul><p><code>&lt;source&gt;</code> ：为 picture , audio 或者 video 元素指定多个媒体资源。</p><ul><li>就是为不同的设备提供不同的媒体资源</li></ul><hr><p><code>&lt;iframe&gt;</code> ：创建包含另外一个文档的内联框架（即行内框架）。</p><ul><li>src 属性指定URL</li><li>sandbox 属性：启用一系列对 <code>&lt;iframe&gt;</code>中内容的额外限制</li></ul><p><code>&lt;meter&gt;</code> ：一个范围内的测量值/分数值。</p><p><code>&lt;progress&gt;</code> ：运行中的任务进度（进程）。</p><hr><p>参考资料：</p><ul><li><p><a href="https://man.ilovefishc.com/" target="_blank" rel="noopener">鱼C-速查宝典</a></p></li><li><p><a href="https://fishc.com.cn/thread-128744-1-2.html" target="_blank" rel="noopener">input元素总结</a></p></li><li><p><a href="https://fishc.com.cn/thread-128224-1-2.html" target="_blank" rel="noopener">正则表达式大全</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础</title>
      <link href="/2020/07/11/%E5%AD%A6%E4%B9%A0/Web/%E5%89%8D%E7%AB%AF/HTML%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/07/11/%E5%AD%A6%E4%B9%A0/Web/%E5%89%8D%E7%AB%AF/HTML%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>基本的<strong>HTML标签</strong></p><ul><li><strong>HTML标题</strong>：通过 &lt;h1&gt; - &lt;h6&gt; 等标签进行定义的。</li><li><strong>HTML段落</strong>：通过 &lt;p&gt; 标签进行定义的。</li><li><strong>HTML链接</strong>：通过 &lt;a&gt; 标签进行定义的。<ul><li>href属性中指定链接的地址</li></ul></li><li><strong>HTML图像</strong>：&lt;img&gt;标签<ul><li>自闭元素，不需要结束标记</li></ul></li><li><strong>HTML空格</strong>：包括换行，HTML解释器会将连续出现的空格字符减少为一个单独的空格符</li><li><strong>HTML强调</strong>：&lt;em&gt;（默认斜体）或&lt;strong&gt;（默认粗体）</li></ul><hr><p><strong>HTML元素</strong>：指的是从开始标签（start tag）到结束标签（end tag）的所有代码。</p><ul><li>HTML 元素以<strong>开始标签</strong>起始</li><li>HTML 元素以<strong>结束标签</strong>终止</li><li><strong>元素的内容</strong>是开始标签与结束标签之间的内容</li><li>某些 HTML 元素具有<strong>空内容（empty content）</strong></li><li>空元素<strong>在开始标签中进行关闭</strong>（以开始标签的结束而结束）</li><li>大多数 HTML 元素可拥有<strong>属性</strong></li></ul><p><strong>空的HTML元素</strong>：没有内容的 HTML 元素被称为空元素</p><ul><li>空元素是在开始标签中关闭的</li><li>&lt;br&gt;就是空元素，但是推荐使用&lt;br /&gt;来让元素关闭</li></ul><p>HTML是<strong>大小写不敏感</strong>的，但是XHTML中<strong>强制</strong>使用小写</p><p><strong>行内元素</strong>、<strong>块级元素</strong></p><ul><li>行内元素只能包含数据、其他行内元素</li><li>块级元素可以包含行内元素、其他块级元素</li></ul><hr><p><strong>HTML属性</strong>：HTML标签可以拥有<strong>属性</strong>，提供了有关 HTML 元素的<strong>更多的信息</strong></p><ul><li>属性总是以<strong>名称/值对</strong>的形式出现</li><li>属性总是在 HTML 元素的<strong>开始标签</strong>中规定</li><li><strong>始终为属性值加引号</strong><ul><li>双引号最常用，但是用单引号也没问题</li><li>属性值中有双引号时，必须采用单引号</li></ul></li></ul><hr><p><a href="https://www.w3school.com.cn/tags/index.asp" target="_blank" rel="noopener">完整的 HTML 参考手册</a></p><p>大多数的HTML元素的属性：</p><table><thead><tr><th style="text-align:left">属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">class</td><td><em>classname</em></td><td>规定元素的<strong>类名</strong>（classname），不唯一</td></tr><tr><td style="text-align:left">id</td><td><em>id</em></td><td>规定元素的<strong>唯一</strong> id</td></tr><tr><td style="text-align:left">style</td><td><em>style_definition</em></td><td>规定元素的行内样式（inline style）</td></tr><tr><td style="text-align:left">title</td><td><em>text</em></td><td>规定元素的额外信息（可在工具提示中显示）</td></tr></tbody></table><hr><p><strong>HTML</strong>负责<strong>语义</strong>，为结构层</p><p><strong>CSS</strong>负责<strong>呈现</strong>，为表示层</p><p><strong>JavaScript</strong>负责<strong>协调前两者</strong>，为行为层</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2020/02/16/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/02/16/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><strong>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配</strong>，但是正则表达式不容易，“如果你有一个问题需要用正则表达式解决,那就是两个问题了”</p><h1 id="re-模块"><a class="markdownIt-Anchor" href="#re-模块"></a> re 模块</h1><p>Python 通过 re 模块来使用正则表达式。下面通过举例来学习吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">r'Eason'</span>, <span class="string">'Kailey likes Eason'</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">13</span>, <span class="number">18</span>), match=<span class="string">'Eason'</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>search()</strong> 方法用于字符串中 <strong>搜索正则表达式模式第一次出现的位置</strong>，要注意两点：</p><ul><li>第一个参数是正则表达式模式，也就是要描述的搜索规则，最好使用原始字符串，可以避免麻烦</li><li>找到后返回的范围是以下标为 0 开始的，找不到就返回 None</li></ul><h1 id="通配符"><a class="markdownIt-Anchor" href="#通配符"></a> 通配符</h1><p>上面 search() 实现的功能用字符串的 find() 同样能实现。但是正则表达式有所谓的通配符：<strong>点号(.)</strong>，它可以 <strong>匹配除换行符之外的任何字符，且只匹配一个字符</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">r'like.'</span>, <span class="string">'Kailey likes Eason'</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">7</span>, <span class="number">12</span>), match=<span class="string">'likes'</span>&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>通常的通配符有 *（匹配 0/多 个字符） 和 ?（匹配 0/1 个字符）</strong></li></ul><h1 id="反斜杠"><a class="markdownIt-Anchor" href="#反斜杠"></a> 反斜杠</h1><p>如果我想搜索 <strong>通配符.</strong> 怎么办？与字符串相同，正则表达式只要在 <strong>元字符（有特殊能力的字符）</strong> 前面加上 <strong>反斜杠\</strong>，就能消除它的特殊功能。<br>同时，<strong>反斜杠\</strong> 也可以赋予普通字符超能力。比如，\d 代表者数字，因此我们可以这样匹配 IP 地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">r'\d\d\d\.\d\d\d\.\d\d\d\.\d\d\d'</span>, <span class="string">'qweqww4280192.168.123.1231hgw99y13yha'</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">10</span>, <span class="number">25</span>), match=<span class="string">'192.168.123.123'</span>&gt;</span><br></pre></td></tr></table></figure><p>当然上面这样写是有问题的：</p><ul><li>\d 匹配 0-9 的数字，\d\d\d 匹配 000-999 的数字，而 IP 地址的范围是 0-255</li><li>这里要求 IP 地址每个部分都是 3 位数字，现实生活中并不都是，如 192.168.0.1</li></ul><h1 id="字符类"><a class="markdownIt-Anchor" href="#字符类"></a> 字符类</h1><p>为了表示一个字符的范围，可以创建一个 <strong>字符类</strong>。使用 <strong>中括号[]</strong> 将任何内容包起来就是一个字符类，它的含义是 <strong>只要是这个字符类中的任何字符，结果就算匹配</strong><br>举个例子，比如想要匹配元音字母，可以这样做：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">r'[aeiou]'</span>, <span class="string">'qweqww4280192.168.123.4561hgw99y13yha'</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">2</span>, <span class="number">3</span>), match=<span class="string">'e'</span>&gt;</span><br></pre></td></tr></table></figure><p>但是这样子并不会识别大写的元音字母，我们有两种解决方法：</p><ol><li>关闭大小写敏感模式</li><li>修改字符类</li></ol><p>这里先说修改字符类，我们只需把 [aeiou] 改成 [aeiouAEIOU] 即可匹配大小写的元音字母。<br>在字符串中，还可以使用 <strong>小横杠(-)</strong> 来 <strong>表示范围</strong>：[a-z]（所有小写字母）<br>同样也可以表示 <strong>数字范围</strong>：[0-2][0-5][0-5]（000-255）</p><h1 id="重复匹配"><a class="markdownIt-Anchor" href="#重复匹配"></a> 重复匹配</h1><p>范围问题解决了，我们开始解决另一个问题——匹配个数。<br>使用 <strong>大括号{}</strong> 来实现重复匹配的功能：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">r'ab&#123;3&#125;c'</span>, <span class="string">'abc abbbc'</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">4</span>, <span class="number">9</span>), match=<span class="string">'abbbc'</span>&gt;</span><br></pre></td></tr></table></figure><p>重复次数也可以取一个范围：{3,5} 表示重复次数 3-5 次。<br>现在会了重复匹配，但是数字范围还没解决呢。</p><blockquote><p>[0-255] 其实是 [0-2 5 5]，表示 0-2 和 5，匹配 0,1,2,5，只匹配一位数字<br>[0-2][0-5][0-5] 也不是表示 0-255，比如 188 就表示不了</p></blockquote><p>现在我们要怎么表示 0-255呢？要用上 <strong>或|</strong> 了。</p><blockquote><p>[0-1]\d\d|2[0-4]\d|25[0-5]<br>0或1开头；2开头；25开头</p></blockquote><ul><li>注意：或| 左右不能有空格，否则会被当作空格符去匹配</li></ul><p>我们现在可以试试匹配每部分都是三位数的 IP 地址了：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">r'(([0-1]\d\d|2[0-4]\d|25[0-5])\.)&#123;3&#125;([0-1]\d\d|2[0-4]\d|25[0-5])'</span>, <span class="string">'192.168.255.255'</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">15</span>), match=<span class="string">'192.168.255.255'</span>&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>小括号() 表示分组</strong>，表示这个小组是一个整体。后面再加上 {3} 表示这个小组重复匹配 3 次。</li><li>注意不要忘记 IP 地址间的 <strong>点号.</strong></li></ul><p>现在开始考虑位数了，因为有些部分不是三位数，那要怎么办呢？重复次数为 0 ！现在，我们可以真正匹配一个合格的 IP 地址了：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">r'(([0-1]&#123;0,1&#125;\d&#123;0,1&#125;\d|2[0-4]\d|25[0-5])\.)&#123;3&#125;([0-1]&#123;0,1&#125;\d&#123;0,1&#125;\d|2[0-4]\d|25[0-5])'</span>, <span class="string">'other192.168.0.1other'</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">5</span>, <span class="number">16</span>), match=<span class="string">'192.168.0.1'</span>&gt;</span><br></pre></td></tr></table></figure><h1 id="特殊符号及用法"><a class="markdownIt-Anchor" href="#特殊符号及用法"></a> 特殊符号及用法</h1><p>Python 中的正则表达式也是以字符串的形式描述的。<br>正则表达式的强大之处在于 <strong>特殊符号的应用</strong>，特殊符号定义了 <strong>字符集合、子组匹配、模式重复次数</strong>。正是这些特殊符号，使得一个正则表达式可以匹配一个复杂的规则。</p><hr><p>下表列举了 Python3 正则表达式特殊符号及用法</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><strong>.</strong></td><td>1. 表示匹配除了换行符以外的任何字符。 <br> 2. 通过设置 <strong>re.DOTALL</strong> 标志可以使 <strong>点.</strong> 匹配所有字符（包括换行符）。</td></tr><tr><td>|</td><td>A|B，表示匹配正则表达式 A 或者 B。</td></tr><tr><td><strong>^</strong></td><td>1. 匹配输入字符串的开始位置。 <br> 2.如果设置了 <strong>re.MULTILINE</strong> 标志，^ 也可以匹配换行符之后的位置。</td></tr><tr><td><strong>$</strong></td><td>1. 匹配输入字符串的结束位置。 <br> 2. 如果设置了 <strong>re.MULTILINE</strong> 标志，$ 也可以匹配换行符之前的位置。</td></tr><tr><td><strong>\</strong></td><td>1. 将一个普通字符变成特殊字符。 <br> 2. 解除元字符的特殊功能 <br> 引用序号对应的子组所匹配的字符串。</td></tr><tr><td><strong>[…]</strong></td><td>1. 字符类，匹配所包含的任意一字符。 <br> 2. 连字符(-) 如果出现在字符串中间表示字符范围描述；如果出现在首位则仅作为普通字符。 <br> 3. 特殊字符仅有反斜线()保持特殊含义，用于转义字符；其他特殊字符，如 *、+、? 等均作为普通字符处理。 <br> 4. 脱字符(^) 如果出现在首位则表示匹配不包含其中的任意字符；如果出现在中间就仅作普通字符匹配</td></tr><tr><td><strong>{M,N}</strong></td><td>M 和 N 均为非负整数，其中 M&lt;=N，表示前面的 RE 匹配 M~N 次。 <br> 注：{M,} 表示至少匹配 M 次；{,N} 等价于 {0,N} 表示至多匹配 N 次</td></tr><tr><td><strong>*</strong></td><td>匹配前面的子表达式零次或多次，等价于 {0,}</td></tr><tr><td><strong>+</strong></td><td>匹配前面的子表达式一次或多次，等价于 {1,}</td></tr><tr><td><strong>?</strong></td><td>匹配前面的子表达式零次或一次，等价于 {0,1}</td></tr><tr><td><strong>*?,+?,??</strong></td><td>默认境况下，*、+、? 的匹配模式是贪婪模式（会尽可能多地匹配符合规则的字符串）；*?,+?,?? 分别对应启用对应的非贪婪模式 。<br> 例如：“Easonzzzz”，‘Easonz+’ 会匹配整个字符串，而 ‘Easonz+?’ 则只匹配 ‘Easonz’</td></tr><tr><td><strong>{M,N}?</strong></td><td>启动非贪婪模式，既只匹配 M 次</td></tr><tr><td><strong>(…)</strong></td><td>匹配小括号中的正则表达式，或者指定一个子组的开始和结束位置。<br> 注：子组的内容可以在匹配之后被 “\数字” 再次引用。<br> 例如：(\w+) \1 会匹配 “Eason Easonzzzz” 中的 ‘Eason Eason’</td></tr><tr><td><strong>(?..)</strong></td><td><strong>(?</strong> 开头的表示为正则表达式的扩展语法</td></tr></tbody></table><hr><p>下表列举了 ‘\’ 和另一个字符组成的特殊含义</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><strong>\序号</strong></td><td>1. 引用对应的子组所匹配的字符串，子组的序号从 1 开始计算。 <br> 2. 如果序号是以 0 开头，或者 3 个数字的长度，那么不会被用于引用对应的子组，而是用于匹配八进制数字所表示的 ASCII 码对应的字符。</td></tr><tr><td><strong>\A</strong></td><td>匹配输入字符串的开始位置</td></tr><tr><td><strong>\Z</strong></td><td>匹配输入字符串的结束位置</td></tr><tr><td><strong>\b</strong></td><td>匹配一个单词边界，单词被定义为 Unicode 的字母数字或下划线字符</td></tr><tr><td><strong>\B</strong></td><td>匹配非单词边界，与 \b 相反</td></tr><tr><td><strong>\d</strong></td><td>1. 对于 Unicode（str类型）模式：匹配任何一个数字，包括 [0-9] 和其他数字字符；如果开启了 <strong>re.ASCII</strong> 标志，就匹配 [0-9]。<br> 2. 对于 8 位（bytes类型）模式：匹配 [0-9] 中任何一个数字</td></tr><tr><td><strong>\D</strong></td><td>匹配任何非 Unicode 的数字，与 \d 相反；如果开启了 <strong>re.ASCII</strong> 标志，就匹配 [^0-9]。</td></tr><tr><td><strong>\s</strong></td><td>1. 对于 Unicode（str类型）模式：匹配 Unicode 中的空白字符（包括 [\t\n\r\f\v] 以及其他空白字符）；如果开启了 <strong>re.ASCII</strong> 标志，就匹配 [\t\n\r\f\v]。<br> 2. 对于 8 位（bytes类型）模式：只匹配 [\t\n\r\f\v]</td></tr><tr><td><strong>\S</strong></td><td>匹配任何非 Unicode 中的空白字符，其实就是与 \s 相反；如果开启了 <strong>re.ASCII</strong> 标志，就相当于匹配 [^\t\n\r\f\v]</td></tr><tr><td><strong>\w</strong></td><td>对于 Unicode（str类型）模式：匹配 Unicode 中的单词字符，基本所有的语言的字符都可以匹配，当然包括数字和下划线；如果开启了 <strong>re.ASCII</strong> 标志，只匹配 [a-zA-Z0-9]。</td></tr><tr><td><strong>\W</strong></td><td>匹配任何非 Unicode 的单词字符，与 \w 相反；如果开启了 <strong>re.ASCII</strong> 标志，匹配 [^a-zA-Z0-9]。</td></tr></tbody></table><p>正则表达式还支持大部分 Python 字符串的转义符号：\a,\b,\f,\n,\r,\t,\u,\U,\v,\x,\\。注意：</p><ul><li>\b 通常用于匹配一个单词边界，只有在字符类中才表示“退格”</li><li>\u 和 \U 只有在 Unicode 模式下才被识别</li><li>八进制转义（\数字）是有限制的，如果第一个数字是 0 或者有 3 个八进制数字，那么就被认为是八进制数；其他情况被认为是子组引用；至于字符串，八进制转义总是最多只能是 3 个数字的长度</li></ul><hr><p>下表列举了 Python 支持的所有扩展语法</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><strong>(?aiLmsux)</strong></td><td>1. (? 后可以紧跟着 ‘a’，‘i’，‘L’，‘m’，‘s’，‘u’，‘x’ 中的一个或多个字符，只能在正则表达式的开头使用。 <br> 2. 每一个字符对应一种匹配标志：re-A（只匹配 ASCII 字符），re-I（忽略大小写），re-L（区域设置），re-M（多行模式）, re-S（. 匹配任何符号），re-X（详细表达式），包含这些字符将会影响整个正则表达式的规则<br>3. 当你不想通过 re.compile() 设置正则表达式标志，这种方法就非常有用啦。<br> 注意，由于 (?x) 决定正则表达式如何被解析，所以它应该总是被放在最前边（最多允许前边有空白符）。如果 (?x) 的前边是非空白字符，那么 (?x) 就发挥不了作用了。</td></tr><tr><td><strong>(?..)</strong></td><td>非捕获组，即该子组匹配的字符串无法从后边获取</td></tr><tr><td><strong>(?P&lt;name&gt;…)</strong></td><td>命名组，通过组的名字（name）即可访问到子组匹配的字符串</td></tr><tr><td><strong>(?P=name)</strong></td><td>反向引用一个命名组，它匹配指定命名组匹配的任何内容</td></tr><tr><td><strong>(?#…)</strong></td><td>注释，括号中的内容将被忽略</td></tr><tr><td><strong>(?=…)</strong></td><td>前向肯定断言。如果当前包含的正则表达式（这里以 … 表示）在当前位置成功匹配，则代表成功，否则失败。一旦该部分正则表达式被匹配引擎尝试过，就不会继续进行匹配了；剩下的模式在此断言开始的地方继续尝试。<br>举个栗子：Eason(?=zz) 只匹配后边紧跟着 “zz” 的字符串 “Eason”</td></tr><tr><td><strong>(?!..)</strong></td><td>前向否定断言。这跟前向肯定断言相反（不匹配则表示成功，匹配表示失败）。<br> 举个栗子：Eason(?!zz) 只匹配后边不是 “zz” 的字符串 “Eason”</td></tr><tr><td><strong>(?&lt;=…)</strong></td><td>后向肯定断言。跟前向肯定断言一样，只是方向相反。<br> 举个栗子：(?&lt;=Eason)zz 只匹配前边紧跟着 “Eason” 的字符串 “zz”</td></tr><tr><td><strong>(?&lt;!..)</strong></td><td>后向否定断言。跟前向肯定断言一样，只是方向相反。<br>举个栗子：(?&lt;!Eason)zz 只匹配前边不是 “Eason” 的字符串 “zz”</td></tr><tr><td><strong>(?(id/name)yes-pattern|no-pattern)</strong></td><td>1. 如果子组的序号或名字存在的话，则尝试 yes-pattern 匹配模式；否则尝试 no-pattern 匹配模式。<br> 2. no-pattern 是可选的。</td></tr></tbody></table><hr><h1 id="元字符"><a class="markdownIt-Anchor" href="#元字符"></a> 元字符</h1><p>以下是正则表达式所有的元字符，它们各自有特殊的含义：</p><blockquote><p><strong>. ^ $ * + ? {} [] \ | ()</strong></p></blockquote><ul><li><strong>点号(.)</strong>：表示匹配除换行符外的任何字符</li><li><strong>管道符(|)</strong>：有点类似于 <strong>逻辑或</strong> 操作</li><li><strong>脱字符(^)</strong>：表示匹配字符串的 <strong>开始位置</strong>（从开始位置开始匹配）</li><li><strong>美元字符($)</strong>：表示匹配字符串的 <strong>结束位置</strong>，也就是只有目标字符出现在末尾才匹配</li><li><strong>反斜杠(\)</strong>：既能让一个普通字符特殊化，也能接触元字符的特殊功能<ul><li>如果反斜杠后面跟着数字，它还有两种用法：<ul><li>如果跟着 1~99，那么它表示引用序号对应的子组所匹配的字符串</li><li>如果跟着 以 0 开头或者是三位数字，那么它是一个八进制数，代表对应的 ASCII 字符</li></ul></li></ul></li><li><strong>小括号()</strong>：本身是一对元字符，被它们括起来的称为一个 <strong>子组</strong><ul><li>子组是一个整体，可以在后面对它引用，<strong>以 1 开始，不是零基</strong></li></ul></li><li><strong>中括号[]</strong>：可以说生成一个字符类，其实就是一个字符集合，被它包围的元字符都失去了特殊功能，除了反斜杠(\)。<ul><li>常和 <strong>连字符(-)</strong> 使用，<strong>表示范围</strong>。如果放在开头会，被当作普通字符处理</li><li><strong>脱字符(^) 放在首位表示取反</strong></li></ul></li><li><strong>大括号{}</strong>：用于表示重复。<ul><li>重复次数可以是一个<strong>数字</strong>，也可以是一个<strong>范围</strong></li></ul></li><li><strong>星号*，加号(+)，问号(?)</strong>：也表示重复，分别是 <strong>*: {0,}</strong>；<strong>+: {1,}</strong>；<strong>?: {0,1}</strong><ul><li>推荐使用这三个，因为进行了内部优化，效率更高</li></ul></li></ul><h1 id="贪婪和非贪婪"><a class="markdownIt-Anchor" href="#贪婪和非贪婪"></a> 贪婪和非贪婪</h1><p>正则表达式<strong>默认是启用贪婪的匹配模式</strong>，也就是说：只要是条件符合的情况下，会尽量多地匹配。举个栗子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"&lt;html&gt;&lt;title&gt;Easonzzzz&lt;/title&gt;&lt;/html&gt;"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">'&lt;.+&gt;'</span>, s)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">37</span>), match=<span class="string">'&lt;html&gt;&lt;title&gt;Easonzzzz&lt;/title&gt;&lt;/html&gt;'</span>&gt;</span><br></pre></td></tr></table></figure><p>这段代码原本只想匹配 &lt;html&gt;，但是由于贪婪模式，直接匹配了整个字符串，那怎么关闭贪婪模式，或者说启用非贪婪模式。<br><strong>只需在表示重复的元字符后面加上 <em>一个问号(?)</em></strong>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">'&lt;.+?&gt;'</span>, s)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">6</span>), match=<span class="string">'&lt;html&gt;'</span>&gt;</span><br></pre></td></tr></table></figure><h1 id="编译正则表达式"><a class="markdownIt-Anchor" href="#编译正则表达式"></a> 编译正则表达式</h1><p>如果需要重复使用某个正则表达式，那么可以先将正则表达式编译成模式对象。<br>使用 <strong>re.compile()</strong> 方法来进行编译：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = re.compile(<span class="string">"[A-Z]"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.search(<span class="string">"EasonZzZzZz"</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">1</span>), match=<span class="string">'E'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.findall(<span class="string">"EasonZzZzZz"</span>)</span><br><span class="line">[<span class="string">'E'</span>, <span class="string">'Z'</span>, <span class="string">'Z'</span>, <span class="string">'Z'</span>]</span><br></pre></td></tr></table></figure><p>其中的 p 就是模式对象 <strong>&lt;class ‘re.Pattern’&gt;</strong>。之前使用的 search() 和 findall() 都是它的内建函数。</p><p>此外，我们还可以正则表达式的工作方式。</p><hr><p>下表列举了可以使用的编译标志</p><table><thead><tr><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>ASSCII, A</td><td>使得转义符号只能匹配 ASCII 字符</td></tr><tr><td>DOTALL, S</td><td>使得(.)匹配任何符号，包括换行符</td></tr><tr><td>IGNORECASE, I</td><td>匹配时不区分大小写</td></tr><tr><td>LOCALE, L</td><td>支持当前的语言（区域）设置</td></tr><tr><td>MULTILINE, M</td><td>多行匹配，影响 ^ 和 $</td></tr><tr><td>VERBOX, X<br>(for ‘entended’)</td><td>启用详细的正则表达式</td></tr></tbody></table><ul><li><strong>A(ASCII)</strong><ul><li>使得 \w,\W,\b,\B,\s,\S 只匹配 ASCII 字符，而不匹配完整的 Unicode 字符。这个标志仅对 Unicode 模式有意义，并忽略字节模式</li></ul></li><li><strong>S(DOTALL)</strong><ul><li>使得 点号(.) 匹配任何字符，包括换行符。不启用的话，点号(.) 匹配除了换行符的所有字符</li></ul></li><li><strong>I(IGNORECASE)</strong><ul><li>字符类和文本字符串在匹配时不区分大小写。</li><li>不设置 LOCALE 的话，不考虑语言（区域）设置这方面的大小写问题</li></ul></li><li><strong>L(LOCALE)</strong><ul><li>使得 \w,\W,\b,\B 依赖当前的语言（区域）环境，而不是 Unicode 数据库</li></ul></li><li>M(MULTILINE)<ul><li>通常 <strong>^</strong> 和 <strong>$</strong> 只匹配字符串的开头和结尾。如果这个标志被设置的话，它们还匹配每一行的行首和行尾</li></ul></li><li>X(VERBOSE)<ul><li>可以使正则表达式更加好看、有条理，因为这个标志可以使空格被忽略（除了出现在字符类中和使用反斜杠转义的空格）</li><li>这个表示还允许使用注释，井号(#)后面的内容是注释（当然，也除了字符类中和转义的 \#）<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">char_ref = re.compile(<span class="string">r"""</span></span><br><span class="line"><span class="string">&amp;[#]              # 开始数字引用</span></span><br><span class="line"><span class="string">(</span></span><br><span class="line"><span class="string">    0[0-7]+       # 八进制</span></span><br><span class="line"><span class="string">  | [0-9]+        # 十进制</span></span><br><span class="line"><span class="string">  | x[0-9a-fA-F]  # 十六进制</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">;                 # 结尾分号</span></span><br><span class="line"><span class="string">"""</span>, re.VERBOSE)</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h1 id="实用的方法"><a class="markdownIt-Anchor" href="#实用的方法"></a> 实用的方法</h1><h2 id="search"><a class="markdownIt-Anchor" href="#search"></a> search()</h2><p>模块级别的 search() 方法就是直接调用 re.search()，编译后的正则表达式模式对象也同样拥有 search() 方法。</p><blockquote><p>re.search(pattern, string, flags=0)<br>regex.search(string[, pos[, endpos]])</p></blockquote><p>由于 flags 在编译的时候就同时编译进去了，所以 regex.search 不需要 flags。另外 regex.search 还支持设置搜索的开始和结束位置。</p><h2 id="匹配对象"><a class="markdownIt-Anchor" href="#匹配对象"></a> 匹配对象</h2><p>search() 并不会立刻返回可以使用的字符串，而是返回一个匹配对象。我们需要使用匹配对象的一些方法才能获得需要的内容。</p><ul><li>使用 group() 方法可以获取匹配的字符串。还可以设置序号来访问对应的子组捕获的内容</li><li>start()、end() 和 span() 分别返回匹配的开始位置、结束位置和匹配的范围。</li></ul><h2 id="findall"><a class="markdownIt-Anchor" href="#findall"></a> findall()</h2><p>如果正则表达式没有包含子组的话，findall() 方法只是找出所有匹配的内容，然后组织成列表返回。<br>但是如果正则表达式<strong>包含一个或者多个子组</strong>，就会<strong>返回子组中匹配的内容</strong>；如果存在多个子组，那么就会将<strong>匹配的内容组成元组的形式</strong>返回。</p><h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2><p>另外还有一些实用的方法，例如：finditer() 将结果返回一个迭代器；sub() 实现字符串的替换。</p>]]></content>
      
      
      <categories>
          
          <category> Python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论一只爬虫的自我修养</title>
      <link href="/2020/02/14/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E4%B8%80%E5%8F%AA%E7%88%AC%E8%99%AB%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
      <url>/2020/02/14/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E4%B8%80%E5%8F%AA%E7%88%AC%E8%99%AB%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="入门"><a class="markdownIt-Anchor" href="#入门"></a> 入门</h1><p>网络爬虫，又称网页蜘蛛(WebSpider)，非常形象的一个名字。互联网是蛛网，而蜘蛛在网上爬，以获取资源。<br>百度或谷歌这样的搜索引擎检索到需要的网页，就是靠它们的爬虫在互联网上，对每个关键词进行索引，建立索引数据库。经过复杂的算法排序后，这些结果将按照与搜索关键词相关度的高低依次排。<br>编写一个搜索引擎，十分困难。但是我们可以从最简单的网络爬虫开始，不断改进。<br>Python 中提供了 <strong>urllib(url+lib)</strong> 模块，可以让 Python 接入互联网。</p><ul><li>URL 的一般格式（带 方括号[] 为可选项）</li></ul><blockquote><p><strong>protocol</strong>: // <strong>hostname[: port]</strong> / <strong>path</strong> / [;parameters] [?query] # fragemnt</p></blockquote><ul><li><p>URL 由三部分组成：</p><ul><li><strong>协议(protocol)</strong>，常见有 http、https、ftp、file、ed2k</li><li>存放资源的服务器的 <strong>域名系统(DNS)</strong> 主机名或 IP 地址（有时候要包括端口号，各种协议都有默认端口号）</li><li><strong>主机资源的具体地址</strong></li></ul></li><li><p>在 Python3 中，urllib 其实是一个包，它包括了 urllib 和urllib2，统一命名为 urllib。这个包中有四个模块：</p><ul><li><strong>urllib.request</strong> for opening and reading URLs，这是做重要的模块</li><li><strong>urllib.error</strong> containing the exceptions raised by <strong>urllib.request</strong></li><li><strong>urllib.parse</strong> for parsing URLs</li><li><strong>urllib.robotparse</strong>r for parsing robots.txt files</li></ul></li><li><p>Python 爬取内容是以 utf-8 编码的 bytes 对象（打印字符串前有个 b，表示这是一个 bytes 对象），要还原成 html 代码，需要对其进行解码。</p></li></ul><h1 id="编码"><a class="markdownIt-Anchor" href="#编码"></a> 编码</h1><p>为了解决不同国家不同标准的编码方法，<strong>Unicode</strong> 编码应运而生。它的做法十分简单：创建一个足够大的编码，将所有国家的编码都加进来，统一标准。<br>而且，为了能节省空间，Unicode 还创造了很多种实现方式。</p><ul><li>UTF-8 就是 Unicode 的常见实现方式，是一种可变长编码</li><li>简单来说，就是当文本时 ASCII 编码的字符时，用 1 字节存放；而文本是其他 Unicode 字符时，按一定算法转换，每个字符使用 1-3 个字节存放。</li></ul><h1 id="下载一只猫"><a class="markdownIt-Anchor" href="#下载一只猫"></a> 下载一只猫</h1><p>我们可以在 <a href="http://placekitten.com" target="_blank" rel="noopener">http://placekitten.com</a> 尝试下载一张猫的图片。在这个网址后面附上宽度和高度，就可以得到一只随机的猫。</p><ul><li><a href="http://placekitten.com/200/300" target="_blank" rel="noopener">http://placekitten.com/200/300</a> 得到一张宽度为 200 像素，高度为 300 像素的图片</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(<span class="string">'http://placekitten.com/200/300'</span>)</span><br><span class="line">cat_img = response.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'cat_200_300.jpg'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(cat_img)</span><br></pre></td></tr></table></figure><p>执行上面代码，就能在文件夹中看到猫的照片了<br>其实，urlopen() 的参数可是一个字符串也可以是 Request 对象。如果是一个字符串，会默认被转为 Request 对象再传入。<br>因此，代码也可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">req = urllib.request.Request(<span class="string">'http://placekitten.com/200/300'</span>)</span><br><span class="line">response = urllib.request.urlopen(req)</span><br></pre></td></tr></table></figure><p>urlopen() 实际上返回一个类文件对象，因此用 read() 方法来读取内容，除此之外，文档还告诉我们这个类文件对象还能使用以下三个函数：</p><ul><li>geturl()：返回请求的 url，通常用于判断是否重定向</li><li>info()：返回一个 httplib.HTTPMessage 对象，包含远程服务器返回的头信息</li><li>getcode()：返回 HTTP 状态码</li></ul><h1 id="更好的选择"><a class="markdownIt-Anchor" href="#更好的选择"></a> 更好的选择</h1><p>通常情况下，Python 官方提供的“电池”都是最可靠和实用的，除了 urllib。因为，还有一个比 urllib 更好的 HTTP 库——Requests</p><h2 id="安装-requests"><a class="markdownIt-Anchor" href="#安装-requests"></a> 安装 Requests</h2><p>与之前安装 EasyGui 一样，使用 pip 命令安装即可</p><h2 id="安装-beautifulsoup4"><a class="markdownIt-Anchor" href="#安装-beautifulsoup4"></a> 安装 BeautifulSoup4</h2><p>有了 Requests 模块，就可以用它的 get() 方法从服务器上下载网页。但是下载的是网页源代码，不利于检索数据，因而我们需要一个解析器。<br>推荐使用 <strong>BeautifulSoup4(BS4)</strong>，这是一个网页解析利器。安装方法也是用 pip 命令安装</p><h1 id="爬取豆瓣-top250-电影排行榜"><a class="markdownIt-Anchor" href="#爬取豆瓣-top250-电影排行榜"></a> 爬取豆瓣 Top250 电影排行榜</h1><p>这是我初中就开始看的排行榜，看的电影基本都在上面找的。虽然有些电影已经很老了，但是经典不会随着时间消去的，建议观看。<br>使用 Requests 下载这个榜单非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:64.0) Gecko/20100101 Firefox/64.0'</span>,</span><br><span class="line">&#125;</span><br><span class="line">res = requests.get(<span class="string">'https://movie.douban.com/top250'</span>, headers=headers)</span><br><span class="line">soup = bs4.BeautifulSoup(res.text, <span class="string">'html.parser'</span>)</span><br><span class="line">targets = soup.find_all(<span class="string">'div'</span>, class_=<span class="string">'hd'</span>)</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> targets:</span><br><span class="line">    print(each.a.span.text)</span><br></pre></td></tr></table></figure><ul><li>由于豆瓣有反爬虫机制，我刚开始没加 headers，然后 status_code 一直返回 418，于是百度了一番，加上了 headers，居然就可以了。至于 headers 是什么？我也不知道，计网应该会学的</li></ul><p>这些数据是什么来的？看一下 HTML 源代码。<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20200215115412.png" class="lazyload"><br>每部电影的标题都位于 <strong>&lt;div class=‘hd’&gt;…&lt;/div&gt;</strong> 的标签中，它的从属关系是 div-&gt;a-&gt;span<br>所以先调用 <strong>find_all()</strong> 方法，找到所有 <strong>class=‘hd’</strong> 的 div 标签，然后按从属关系直接取出电影名。<br>现在我们把所有的数据爬出来吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:64.0) Gecko/20100101 Firefox/64.0'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    res = requests.get(url, headers=headers)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_movies</span><span class="params">(res)</span>:</span></span><br><span class="line">    soup = bs4.BeautifulSoup(res.text, <span class="string">'html.parser'</span>)</span><br><span class="line">    <span class="comment"># 电影名</span></span><br><span class="line">    movies = []</span><br><span class="line">    targets = soup.find_all(<span class="string">'div'</span>, class_=<span class="string">'hd'</span>)</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> targets:</span><br><span class="line">        movies.append(each.a.span.text)</span><br><span class="line">    <span class="comment"># 评分</span></span><br><span class="line">    ranks = []</span><br><span class="line">    targets = soup.find_all(<span class="string">'span'</span>, class_=<span class="string">'rating_num'</span>)</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> targets:</span><br><span class="line">        ranks.append(<span class="string">' 评分：%s '</span> % each.text)</span><br><span class="line">    <span class="comment"># 资料</span></span><br><span class="line">    messages = []</span><br><span class="line">    targets = soup.find_all(<span class="string">'div'</span>, class_=<span class="string">'bd'</span>)</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> targets:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            messages.append(each.p.text.split(<span class="string">'\n'</span>)[<span class="number">1</span>].strip() + each.p.text.split(<span class="string">'\n'</span>)[<span class="number">2</span>].strip())</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    result = []</span><br><span class="line">    length = len(movies)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        result.append(movies[i] + ranks[i] + messages[i] + <span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出一共几个页面</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_depth</span><span class="params">(res)</span>:</span></span><br><span class="line">    soup = bs4.BeautifulSoup(res.text, <span class="string">'html.parser'</span>)</span><br><span class="line">    depth = soup.find(<span class="string">'span'</span>, class_=<span class="string">'next'</span>).previous_sibling.previous_sibling.text</span><br><span class="line">    <span class="keyword">return</span> int(depth)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    host = <span class="string">"https://movie.douban.com/top250"</span></span><br><span class="line">    res = open_url(host)</span><br><span class="line">    depth = find_depth(res)</span><br><span class="line"></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(depth):</span><br><span class="line">        url = host + <span class="string">'/?start='</span> + str(<span class="number">25</span>*i)</span><br><span class="line">        res = open_url(url)</span><br><span class="line">        result.append(find_movies(res))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'豆瓣Top250电影.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> result:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> each:</span><br><span class="line">                f.write(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python模块</title>
      <link href="/2020/02/14/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E6%A8%A1%E5%9D%97/"/>
      <url>/2020/02/14/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="模块就是程序"><a class="markdownIt-Anchor" href="#模块就是程序"></a> 模块就是程序</h1><p>模块是更高级的封装。说到封装，我们学了什么类型的封装：</p><ul><li>容器（列表、元组、字符串、字典等），是对数据的封装</li><li>函数，是对语句的封装</li><li>类，是对方法和属性的封装，也就是对函数和数据的封装</li></ul><p>现在我们要学的模块，就是程序的封装，保存的每一个 <strong>.py</strong> 结尾的文件，都是一个独立的模块。</p><h1 id="命名空间"><a class="markdownIt-Anchor" href="#命名空间"></a> 命名空间</h1><p><strong>命名空间(namespace)</strong> 表示 <strong>标识符(identifier)</strong> 的可见范围。一个标识符可在多个命名空间中定义，它 <strong>在不同命名空间中的含义是互不相干的。</strong><br>在 Python 中，每个模块都会维护一个独立的命名空间，如果你只是通过 <strong>import 模块名</strong> 来导入的话，要用 <strong>模块名.函数名</strong> 才能正常使用模块中的函数。</p><h1 id="导入模块"><a class="markdownIt-Anchor" href="#导入模块"></a> 导入模块</h1><p>导入模块有三种方法。</p><ol><li><p><strong>import 模块名</strong></p><ul><li>直接使用 import，但是在调用模块中的函数时，要加上模块的命名空间</li><li>这种方法如果模块名太长的话，不是很方便</li></ul></li><li><p><strong>from 模块名 import 函数名</strong></p><ul><li>这种导入方法会直接将模块的命名空间覆盖过来，调用时不用加上命名空间</li><li>函数名用通配符 <strong>星号*</strong> 代替可以导入模块的所有命名空间，这样可能会陷入名字混乱的局面，不建议</li></ul></li><li><p><em><strong>import 模块名 as 新名字</strong></em></p><ul><li>这种方法可以给命名空间取个较简单的新名字，又不会污染命名空间，建议使用</li></ul></li></ol><h1 id="__name____main__"><a class="markdownIt-Anchor" href="#__name____main__"></a> __name__=’__main__’</h1><p>模块是用来 <strong>组织 Python 的代码</strong>，还能 <strong>实现代码的重用</strong>。<br>但是模块可以导入模块，在运行模块的时候可能会执行导入模块的测试语句。<br>所以，要使用模块的 <strong>__name__属性</strong>。如果模块是主模块，<strong>__name__ = ‘__main__’</strong>。<br>因而模块中经常见到：<strong>if __name__==’__main__’</strong> 这句代码，这个 if 语句下再写测试语句，这样在别人调用自己的模块时，就不会执行测试语句了。</p><h1 id="搜索路径"><a class="markdownIt-Anchor" href="#搜索路径"></a> 搜索路径</h1><p>Python 模块的导入需要一个路径搜索的过程。在 Python <strong>预定义好的搜索路径</strong> 中寻找对应的模块文件：如果有，则导入；如果没有，则导入失败。<br>而这个搜索路径，就是一组目录，<strong>可以通过 sys 模块中的 path 变量显示出来</strong>（不同的机器上显示的路径信息可能不同）</p><ul><li>列出的这些路径都是 Python 在导入模块操作时回去搜索的。但是 site-package 目录是最佳选择，因为它生来就是做这些事情的。</li><li>搜索路径也是可以扩展的，使用 sys.path.append() 就可以扩展搜索路径了。</li></ul><h1 id="包"><a class="markdownIt-Anchor" href="#包"></a> 包</h1><p>实际上，一个大型的系统有成千上万的模块也是很正常的事。单单用模块来定义 Python 的功能显然还不够，如果都放在一起显然不好管理，而且还有命名冲突的可能。因此，Python 也出现了包的概念。<br>Python 中的包的实现要比 Java 中更为简洁。如何创建一个包：</p><ol><li><strong>创建一个文件夹用于存放相关模块，文件夹的名字就是包的名字</strong></li><li><strong>在文件夹中创建一个 <em>__init__.py</em> 的模块文件，内容可以为空</strong><ul><li>这一步是必要的，内容可以为空，也可以写一些初始化代码。这一条是 Python 的规定，这样子可以告诉 Python 这个文件夹是包</li></ul></li><li><strong>将相关模块放入文件夹中</strong></li></ol><h1 id="像个极客一样去思考"><a class="markdownIt-Anchor" href="#像个极客一样去思考"></a> 像个极客一样去思考</h1><p>“Python 自己带着电池”，Python 附带安装了 Python 标准库。标准库中的模块极其有用，现在我们要学习：如何自主学习这些模块？<br>利用 Python 的官方文档，与 Java Document 一样。Python 的官方文档由几部分组成：</p><ol><li><p><strong>What’s new in Python 3.7? or all “What’s new” documents since 2.0</strong></p><ul><li>Python3.7 的新内容，或者是列举 2.0 document 的新内容</li></ul></li><li><p><strong>Tutorial</strong></p><ul><li>Python 的基本语法</li></ul></li><li><p><em><strong>Library Reference</strong></em></p><ul><li>Python 官方枕边书，详细列举了 Python 所有内置函数和标准库的各个模块</li></ul></li><li><p><strong>Installing Python Modules</strong></p><ul><li>安装第三方模块</li></ul></li><li><p><strong>Disturbing Python Modules</strong></p><ul><li>发布第三方模块</li></ul></li><li><p><strong>Language Reference</strong></p><ul><li>讨论 Python 的语法与设计哲学</li></ul></li><li><p><strong>Python Setup and Usage</strong></p><ul><li>各个平台上 Python 的安装和使用</li></ul></li><li><p><strong>Python HOWTOs</strong></p><ul><li>深入探讨一些特定主题</li></ul></li><li><p><strong>Extending and Embedding</strong></p><ul><li>介绍如何用 C 和 C++ 开发 Python 的扩展模块</li></ul></li><li><p><strong>FAQs</strong></p><ul><li>常见问题的解决</li></ul></li></ol><ul><li><p>另外值得一提的是 <strong>PEP(Python Enhancement Proposal)</strong>，Python 的增强建议书，用来规范与定义 Python 的各种增强与延伸功能的技术规格，让 Python 统一</p><ul><li>PEP1 是 PEP 本身的规范定义</li><li>PEP3000 是 Python3 的相关技术规格</li><li>PEP8 定义了 Python 代码的风格指南</li></ul></li><li><p><strong>对一个模块查看 __all__ 属性，可以直接获取可供调用接口的信息</strong></p><ul><li>不是所有的模块都有，建议编写这个属性</li><li>from 模块名 import * ：只导入 __all__ 属性这个列表里的名字（如果没有，则导入所有不以下划线开头的名字）</li></ul></li><li><p><strong>模块的 __all__ 属性可以查看源代码位置</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python魔法方法</title>
      <link href="/2020/02/12/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
      <url>/2020/02/12/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在此之前，已经接触过了 Python 最常用的魔法方法（__init__()），什么是魔法方法：</p><ul><li>魔法方法总是被左右两个下划线(__)包围</li><li>魔法方法是面向对象的 Python 的一切</li><li>能在适当的时候助你一臂之力</li></ul><h1 id="构造和析构"><a class="markdownIt-Anchor" href="#构造和析构"></a> 构造和析构</h1><h2 id="__init__self"><a class="markdownIt-Anchor" href="#__init__self"></a> __init__(self[, …])</h2><p>__init__() 方法是构造方法，也就是类在实例化成对象时候要调用的初始化方法</p><ul><li><strong>返回值一定是 None</strong></li></ul><h2 id="__new__cls"><a class="markdownIt-Anchor" href="#__new__cls"></a> __new__(cls[, …])</h2><p>事实上，__new__() 才是在一个对象实例化的时候调用的第一个方法。它与其他魔法方法不同，它的 <strong>第一个参数不是 self 而是这个类(cls)，而其他参数会直接传给 __init__() 方法</strong></p><ul><li><p><strong>__new__() 方法需要返回一个实例对象</strong>，通常是 cls 的实例对象，当然也可以返回其他对象</p></li><li><p>__new__() 很少重写，只有一种情况需要重写这个魔法方法，就是当继承一个不可变类型的时候</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CapStr</span><span class="params">(str)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, string)</span>:</span></span><br><span class="line">        string = string.upper()</span><br><span class="line">        <span class="keyword">return</span> str.__new__(cls, string)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = CapStr(<span class="string">'I love you'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'I LOVE YOU'</span></span><br></pre></td></tr></table></figure><ul><li>这里的 <strong>return str.<strong>new</strong>(cls, string)</strong> 值得提倡，建议使用 Python 默认机制，而不是完全重写</li></ul></li></ul><h2 id="__del__self"><a class="markdownIt-Anchor" href="#__del__self"></a> __del__(self)</h2><p>__del__() 是 Python 的析构方法。当一个对象要被销毁时，这个方法就会被调用</p><ul><li>注意：<strong>del x</strong> 并非相当于自动调用 <strong>x.__del__()</strong>，<strong>__del__() 是当垃圾回收机制回收这个对象时候调用的</strong></li></ul><h1 id="算术运算"><a class="markdownIt-Anchor" href="#算术运算"></a> 算术运算</h1><p>工厂函数，其实就是一个类对象，当调用它们时候，事实上就是创建了一个相应的实例对象，就像工厂生产货物一样</p><ul><li>其实 Python 中无处不对象，计算时使用的数字也是对象，因此对象是可以计算的</li><li>Python 的魔法方法还提供了自定义对象的数值处理，通过对下面魔法方法的重写，可以自定义任何对象间的算术运算</li></ul><h2 id="常见的算术运算"><a class="markdownIt-Anchor" href="#常见的算术运算"></a> 常见的算术运算</h2><p>下表列举了算术运算相关的魔法方法。</p><table><thead><tr><th>魔法方法</th><th>含义</th></tr></thead><tbody><tr><td>__add__(self, other)</td><td>加法：+</td></tr><tr><td>__sub__(self, other)</td><td>减法：-</td></tr><tr><td>__mul__(self, other)</td><td>乘法：*</td></tr><tr><td>__truediv__(self, other)</td><td>真除法：/</td></tr><tr><td>__floordiv__(self, other)</td><td>整数除法：//</td></tr><tr><td>__mod__(self, other)</td><td>取模算法：%</td></tr><tr><td>__divmod__(self, other)</td><td>当被 divmod() 调用</td></tr><tr><td>__pow__(self, other[, modulo])</td><td>当被 power() 调用或 ** 运算的行为</td></tr><tr><td>__lshift__(self, other)</td><td>按位左移：&lt;&lt;</td></tr><tr><td>__rshift__(self, other)</td><td>按位右移：&gt;&gt;</td></tr><tr><td>__and__(self, other)</td><td>按位与操作：&amp;</td></tr><tr><td>__xor__(self, other)</td><td>按位异或操作：^</td></tr><tr><td>__or__(self, other)</td><td>按位或操作：|</td></tr></tbody></table><ul><li>重写以上方法时，依然建议采取上面重写 __new__() 的方法，尽量使用 Python 默认机制，而不是自己完全重写</li><li>例如：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self + other</span><br><span class="line"><span class="comment"># 这里就触发无限递归了</span></span><br><span class="line"><span class="comment"># 因为 self + other 依然调用 __add__ 魔法方法</span></span><br><span class="line"><span class="comment"># 这不就是递归了？</span></span><br><span class="line"><span class="comment"># 建议使用 int.__add__(self, other)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="反运算"><a class="markdownIt-Anchor" href="#反运算"></a> 反运算</h2><p>下表列举了反运算相关的魔法方法。</p><table><thead><tr><th>魔法方法</th><th>含义</th></tr></thead><tbody><tr><td>__radd__(self, other)</td><td>加法：+</td></tr><tr><td>__rsub__(self, other)</td><td>减法：-</td></tr><tr><td>__rmul__(self, other)</td><td>乘法：*</td></tr><tr><td>__rtruediv__(self, other)</td><td>真除法：/</td></tr><tr><td>__rfloordiv__(self, other)</td><td>整数除法：//</td></tr><tr><td>__rmod__(self, other)</td><td>取模算法：%</td></tr><tr><td>__rdivmod__(self, other)</td><td>当被 divmod() 调用</td></tr><tr><td>__rpow__(self, other[, modulo])</td><td>当被 power() 调用或 ** 运算的行为</td></tr><tr><td>__rlshift__(self, other)</td><td>按位左移：&lt;&lt;</td></tr><tr><td>__rrshift__(self, other)</td><td>按位右移：&gt;&gt;</td></tr><tr><td>__rand__(self, other)</td><td>按位与操作：&amp;</td></tr><tr><td>__rxor__(self, other)</td><td>按位异或操作：^</td></tr><tr><td>__ror__(self, other)</td><td>按位或操作：|</td></tr></tbody></table><ul><li>以上反运算与上一节的算术运算只多了一个 <strong>‘r’</strong>，这些函数是在左操作数不支持相应的操作时被调用的</li><li>例如：a + b，a 没有定义 __add__() 或者不支持相应操作，此时  Python 就会自动调用 b 的 __radd__() 方法</li></ul><h2 id="一元操作符"><a class="markdownIt-Anchor" href="#一元操作符"></a> 一元操作符</h2><p>Python 支持的一元操作符：</p><ul><li>__neg__() 表示正号行为；</li><li>__pos__() 表示负号行为；</li><li>__abs__() 表示定义 abs() 函数被调用时的行为；</li><li>__invert__() 表示定义按位取反的行为</li></ul><h1 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h1><p><strong><em>__str__()</em> 和 <em>__repr___()</em> 是两个 <em>返回字符串</em> 的魔法方法。</strong></p><ul><li>__str__() 是定义对实例对象调用 str() 时的行为，面向人，转化为适于人阅读的形式</li><li>__repr___() 是定义对实例对象调用 repr() 时的行为，面向机器，转化为供解释器读取的形式</li><li>定义类的输出的时候经常会使用这两个其中的魔法</li></ul><h1 id="属性访问"><a class="markdownIt-Anchor" href="#属性访问"></a> 属性访问</h1><p>通常使用 <strong>点(.)</strong> 操作符的形式访问对象的属性，在 <strong>类与对象</strong> 中也提到几个访问属性的 BIF，还提到了 property() 来更好的管理属性。<br>下表列举了与属性相关的魔法方法。</p><table><thead><tr><th>魔法方法</th><th>含义</th></tr></thead><tbody><tr><td>__getattr__(self, name)</td><td>当用户试图获取一个不存在的属性时的行为</td></tr><tr><td>__getattribute__(self, name)</td><td>当该类的属性被访问时的行为</td></tr><tr><td>__setattr__(self, name, value)</td><td>当一个属性被设置时的行为</td></tr><tr><td>__delattr__(self, name)</td><td>当一个属性被删除时的行为</td></tr></tbody></table><ul><li><p>注意：重写这些方法时，容易陷入无限递归，建议在自定义后，建议使用 super() 来调用基类相应的魔法方法</p></li><li><p>例如：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">    self.name = value</span><br><span class="line">    <span class="comment"># 此时陷入无限递归</span></span><br><span class="line">    <span class="comment"># 因为这里发生对属性的赋值操作</span></span><br><span class="line">    <span class="comment"># 会再自动调用 __setattr__ ()</span></span><br><span class="line">    <span class="comment"># 因而陷入无限递归</span></span><br><span class="line">    <span class="comment"># 在__setattr__() 中赋值，建议使用</span></span><br><span class="line">    <span class="comment"># super().__setattr__(name, value)</span></span><br></pre></td></tr></table></figure><ul><li>还有一种给特殊属性 __dict__ 赋值的方法。<strong>对象有一个特殊的属性：__dict__，它的作用是 <em>以字典的形式显示出当前所有属性名以及相应的值</em></strong></li></ul></li></ul><h1 id="描述符property-的原理"><a class="markdownIt-Anchor" href="#描述符property-的原理"></a> 描述符（property 的原理）</h1><p><strong>描述符(descriptor)</strong> 是什么：描述符 <strong>本质就是一个新式类</strong>,在这个新式类中,至少定义了 __get__()，__set__()，__delete__() 三个特殊魔法方法中的任意一个。它的作用是 <strong>用来代理另一个类的属性</strong>，</p><p>下表是与描述符相关的魔法方法</p><table><thead><tr><th>魔法方法</th><th>含义</th></tr></thead><tbody><tr><td>__get__(self, instance, owner)</td><td>用于属性访问，它返回属性的值</td></tr><tr><td>__set__(self, instance, value)</td><td>将在属性分配操作中调用，不返回任何内容</td></tr><tr><td>__delete__(self, instance)</td><td>控制删除操作，不返回任何内容</td></tr></tbody></table><ul><li>property 事实上就是一个描述符类</li></ul><h1 id="定制容器"><a class="markdownIt-Anchor" href="#定制容器"></a> 定制容器</h1><p>要想实现容器的定制，首先要谈一谈协议。</p><ul><li>协议(protocol) 与其他编程语言中的接口相似，它规定哪些方法必须定义。然而，Python 中的协议没那么正式，更像是一种指南，不会严格的要求定义</li></ul><p>在 Python 中，像序列类型，映射类型都属于容器类型。与定制容器有关的一些协议：</p><ul><li>容器不可变，只需要定义 __len__() 和 __getitem__() 方法</li><li>容器可变得话，除了定义 __len__() 和 __getitem__() 方法，还要定义 __setitem__() 和 __delitem__() 两个方法</li></ul><p>下表列举了与容器类型相关的魔法方法。</p><table><thead><tr><th>魔法方法</th><th>含义</th></tr></thead><tbody><tr><td>__len__(self)</td><td>当被 len() 函数调用时（返回元素个数）</td></tr><tr><td>__getitem__(self, key)</td><td>获取容器中指定元素，相当于 self[key]</td></tr><tr><td>__setitem__(self, key, value)</td><td>设置容器中指定元素，相当于 self[key]=value</td></tr><tr><td>__delitem__(self, key)</td><td>删除容器中指定元素，相当于 del self[key]</td></tr><tr><td>__iter__(self)</td><td>当迭代容器中的元素</td></tr><tr><td>__reversed__(self)</td><td>当被 reversed() 函数调用时</td></tr><tr><td>__contains__(self, item)</td><td>当使用成员测试操作符（in 或 not in）时</td></tr></tbody></table><h1 id="迭代器"><a class="markdownIt-Anchor" href="#迭代器"></a> 迭代器</h1><p>迭代是 Python 最强大的功能之一，是<strong>访问集合元素的一种方式</strong>。<br>迭代的意思类似于循环，每一次重复的过程称为一次迭代的过程，而每一次迭代得到的结果会被用来作为下一次迭代的初始值。<br><strong>迭代器是提供迭代方法的容器</strong>，通常接触的迭代器有序列、字典等，它们都支持迭代的操作</p><ul><li><strong>迭代器是一个可以记住遍历的位置的对象</strong>，从集合的第一个元素开始访问，直到所有的元素被访问完结束。<strong>迭代器只能往前不会后退。</strong></li></ul><p>关于迭代，Python 提供了两个 BIF：<strong>iter()</strong> 和 <strong>next()</strong></p><ul><li>对一个容器对象调用 iter() 就得到它的迭代器</li><li>调用 next() 迭代器就会返回下一个值<ul><li>如果迭代器没有值可以返回了，Python 会抛出一个名为 StopIteration 的异常</li></ul></li><li>利用这两个 BIF 就可以分析出 for 语句其实是这样工作的  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it = iter(container)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        each = next(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li></ul><p>关于实现迭代器的魔法方法有：__iter__() 和 __next__()</p><ul><li>如果一个容器是迭代器，就必须实现 __iter__()，这个方法实际上就是返回迭代器本身(self)</li><li>重点是 __next__()，它决定了迭代的规则</li><li>以下举例个斐波那契数列的迭代器  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibs</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n=<span class="number">20</span>)</span>:</span></span><br><span class="line">        self.pre = <span class="number">0</span></span><br><span class="line">        self.cur = <span class="number">1</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pre, self.cur = self.cur, self.pre+self.cur</span><br><span class="line">        <span class="keyword">if</span> self.pre &gt; self.n:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">return</span> self.pre</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fibs = Fibs(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> fibs:</span><br><span class="line">    print(each)</span><br></pre></td></tr></table></figure></li></ul><h1 id="生成器"><a class="markdownIt-Anchor" href="#生成器"></a> 生成器</h1><p>与迭代器一样，生成器也是 Python 最强大的功能之一。<br>生成器的学习并不涉及魔法方法，也没有类和对象，它仅用普通的函数就能实现了。</p><p><strong>生成器其实是一种迭代器的实现</strong>，但是更为简单。迭代器需要定义一个类和实现相关方法，而<strong>生成器只需要在普通函数中加上 <em>yield</em> 语句即可</strong></p><p>生成器的发明使得 Python 模仿协同程序的概念得以实现</p><ul><li>协同程序：可以运行的独立函数调用，函数可以暂停或挂起，并在需要的时候从程序离开的地方继续或重新开始</li><li>对于调用一个普通的 Python 函数，一般是从函数的第一行代码执行开始，结束于 return、异常或者函数所有语句执行完。<strong>一旦函数将控制权交还给调用者，函数所有工作以及局部变量中的数据全部丢失。</strong></li><li><strong>Python 的生成器可以暂时挂起函数，并保留函数的局部变量等数据，然后再次调用它时，从上次暂停的位置继续执行下去</strong></li><li>在调用生成器运行的过程中，每次 <strong>遇到 yield 时函数会暂停</strong> 并保存当前所有的运行信息，<strong>返回 yield 的值</strong>, 并 <strong>在下一次执行 next() 方法时从当前位置继续运行</strong></li><li><strong>调用一个生成器函数，返回的是一个迭代器对象</strong></li></ul><p>下面我们再次使用斐波那契数列举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibsGen</span><span class="params">()</span>:</span></span><br><span class="line">    pre = <span class="number">0</span></span><br><span class="line">    cur = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        pre, cur = cur, pre+cur</span><br><span class="line">        <span class="keyword">yield</span> pre</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> fibsGen():</span><br><span class="line">    <span class="keyword">if</span> each &gt; <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(each)</span><br></pre></td></tr></table></figure><h1 id="生成器表达式"><a class="markdownIt-Anchor" href="#生成器表达式"></a> 生成器表达式</h1><p><strong>列表推导式(list comprehensions)</strong> 也叫做列表解析，灵感取自函数式编程 Hashell，它是一个非常有用和灵活的工具，可以动态地创建列表。</p><ul><li>下面举个栗子吧：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表推导式</span></span><br><span class="line">list1 = [i*i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上式相当于</span></span><br><span class="line">list2 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    list2.append(i*i)</span><br></pre></td></tr></table></figure></li></ul><p>除了列表推导式，还有<strong>字典推导式（dictionary comprehension）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;i : i%<span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)&#125;</span><br><span class="line">&#123;<span class="number">0</span>: <span class="literal">True</span>, <span class="number">1</span>: <span class="literal">False</span>, <span class="number">2</span>: <span class="literal">True</span>, <span class="number">3</span>: <span class="literal">False</span>, <span class="number">4</span>: <span class="literal">True</span>, <span class="number">5</span>: <span class="literal">False</span>, <span class="number">6</span>: <span class="literal">True</span>, <span class="number">7</span>: <span class="literal">False</span>, <span class="number">8</span>: <span class="literal">True</span>, <span class="number">9</span>: <span class="literal">False</span>&#125;</span><br></pre></td></tr></table></figure><p>除了上面两个，还有元组推导式吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x000001E43227B348</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>似乎没有元组推导式哦？其实它就是个 generator ，小括号的内容就是 <strong>生成器表达式（generator expressions）</strong>，可以利用 next() 生成 0-9 的序列  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(e)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(e)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><p>还有一个特性更“牛”，<strong>生成器表达式也能作为函数的参数使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>) <span class="keyword">if</span> i % <span class="number">2</span>)</span><br><span class="line"><span class="number">2500</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python类和对象</title>
      <link href="/2020/02/11/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/02/11/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="对象属性方法"><a class="markdownIt-Anchor" href="#对象属性方法"></a> 对象=属性+方法</h1><p>Python 中的对象由两部分组成：<strong>“属性”（对象的特征）</strong> 和 <strong>“方法”（对象的行为）</strong></p><h1 id="面向对象编程"><a class="markdownIt-Anchor" href="#面向对象编程"></a> 面向对象编程</h1><h2 id="self"><a class="markdownIt-Anchor" href="#self"></a> self</h2><p><strong>对象的每一个方法都有一个 self 参数</strong>，这里的 self 就相当于 C++ 中的 this 指针</p><ul><li>当一个对象的方法被调用时，<strong>对象会将自身的引用作为第一个参数传给该方法</strong>，这样子 Python 就知道该操作哪一个对象了</li><li>Python 中也有 this，但是建议使用 self</li></ul><h2 id="python-的魔法方法"><a class="markdownIt-Anchor" href="#python-的魔法方法"></a> Python 的魔法方法</h2><p>Python 的对象天生拥有一些神奇的方法，它们是可以给类增加魔力的特殊方法，如果对象实现了这些方法的某一个，那么 <strong>这个方法就会在特殊的情况下被自动调用</strong></p><ul><li><strong>魔法方法总会被左右各两个下划线所包围</strong></li><li>这里只介绍一个最基本的特殊方法：__init__()<ul><li>构造方法，只要实例化对象就会被调用，可以传入参数</li><li>可以通过重写这个方法来 <strong>自定义对象的初始化操作</strong></li></ul></li></ul><h2 id="公有和私有"><a class="markdownIt-Anchor" href="#公有和私有"></a> 公有和私有</h2><p>Python 中并没有像 C++ 和 Java 中的访问修饰符用于声明数据的访问权限。为了实现类似私有变量的特征，Python 采用了一种叫做 <strong>Name Mangling（名字改编技术）</strong>，只需要在变量名或函数名前加上 <strong>&quot;__&quot;两个下划线</strong>，那么这个函数或变量就会变成私有的了</p><ul><li><strong>在外部这个变量是不可见的（隐藏），访问时不会提示它是私有变量</strong></li><li>但是Python只是在名字上动了手脚，<strong>实际上可以通过“_类名__变量名”访问私有变量</strong>。因而 Python 目前的私有机制其实是 <strong>伪私有</strong>，所有的变量在外部都可以访问</li></ul><h1 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h1><p>Python 中类继承的语法很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名<span class="params">(被继承的类)</span>:</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><ul><li>被继承的类称为基类、父类或超类；继承者称为子类，<strong>一个子类可以继承它的父类任何属性和方法</strong></li><li><strong>子类中定义与父类同名属性或方法，会自动覆盖父类对应的成员</strong></li><li><strong>子类的 __init__() 并不会自动调用父类的构造函数</strong>，可以采用两种方法调用：<ul><li><strong>调用未绑定的父类方法</strong></li><li><strong>使用 super 函数</strong></li></ul></li></ul><h2 id="调用未绑定的父类方法"><a class="markdownIt-Anchor" href="#调用未绑定的父类方法"></a> 调用未绑定的父类方法</h2><p>使用 Python GUI入门 中的 <strong>easygui.EgStore</strong> 演示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> easygui <span class="keyword">as</span> eg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Settings</span><span class="params">(eg.EgStore)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里的未绑定是指：不需要绑定父类的实例对象</span></span><br><span class="line">        <span class="comment"># 使用子类的实例对象代替即可</span></span><br><span class="line">        eg.EgStore.__init__(filename)</span><br></pre></td></tr></table></figure><h2 id="使用-super-函数"><a class="markdownIt-Anchor" href="#使用-super-函数"></a> 使用 super 函数</h2><p>对上例改进</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> easygui <span class="keyword">as</span> eg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Settings</span><span class="params">(eg.EgStore)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line"></span><br><span class="line">        super().__init__(filename)</span><br></pre></td></tr></table></figure><ul><li>super 函数：<strong>不需要明确给出任何基类的名字，它会自动找出所有基类以及对应的方法</strong>。</li><li>如果改变继承关系，使用 super 的话就基本无须改变代码，而第一个方法要改较多代码</li></ul><h1 id="多重继承"><a class="markdownIt-Anchor" href="#多重继承"></a> 多重继承</h1><p>Python 与 C++ 相同，与 Java 不同，它支持多重继承。语法十分简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名<span class="params">(父类<span class="number">1</span>, 父类<span class="number">2</span>, ...)</span>:</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><ul><li>多重继承容易导致代码混乱，所以 Java 中禁止这种做法，虽然 Python 允许，但是要尽量避免使用它，因为会出现不可预见的 BUG。<ul><li>例如：钻石（菱形）继承问题</li></ul></li></ul><h1 id="组合"><a class="markdownIt-Anchor" href="#组合"></a> 组合</h1><p>组合是一种将几个类组合成一个类，进行管理</p><ul><li>例如：鱼，乌龟两个类，组合成了一个水池类  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Turtle</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.num = x</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, y)</span>:</span></span><br><span class="line">        self.num = y</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.turtle = Turtle(x)</span><br><span class="line">        self.fish = Fish(y)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_num</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'水池中有：%d 只乌龟，%d 条鱼'</span> % (self.turtle.num, self.fish.num))</span><br></pre></td></tr></table></figure></li></ul><h1 id="类-类对象和实例对象"><a class="markdownIt-Anchor" href="#类-类对象和实例对象"></a> 类、类对象和实例对象</h1><p>在 Python 中，类中定义的属性是静态变量，也就是 Java 中的 static 变量，<strong>类的属性是与类对象绑定的</strong>，不依赖任何它的实例对象</p><ul><li>类属性被所有类对象的实例对象(实例方法)所共有，<strong>在内存中只存在一个副本</strong>。对于公有的类属性，在类外可以通过类对象和实例对象访问。</li><li><strong>所有的实例对象在初始化时都引用类对象的属性，为同一内存区域</strong>，如果实例对象没有对其赋值覆盖，那么类对象一改属性，实例对象也会跟着改变<ul><li>指针：内容是一块内存的地址</li><li>引用：一块内存的别名</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = C()</span><br><span class="line">b = C()</span><br><span class="line">print(a.count, b.count)</span><br><span class="line">b.count += <span class="number">10</span></span><br><span class="line">print(a.count, b.count)</span><br><span class="line">C.count += <span class="number">100</span></span><br><span class="line">print(a.count, b.count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0 0</span></span><br><span class="line"><span class="comment"># 0 10</span></span><br><span class="line"><span class="comment"># 100 10</span></span><br></pre></td></tr></table></figure><ul><li>属性和方法名相同的话，属性会覆盖方法</li></ul><h1 id="什么是绑定"><a class="markdownIt-Anchor" href="#什么是绑定"></a> 什么是绑定</h1><p>Python 严格要求方法必须要有实例才能被调用，这种限制其实就是 Python 所谓的绑定概念</p><ul><li>类可以定义不传入 self 的函数，但是只有类对象能使用，实例对象不能调用，因为<strong>实例对象调用方法时会自动传入实例对象（self）作为第一个参数</strong></li><li>使用 __dict__ 可以查看对象拥有的属性，<strong>仅显示实例对象的属性，不显示类属性和特殊属性</strong>，键表示属性名，值表示属性相应的数据值<ul><li><strong>函数(function)</strong> 也是一种属性，但是 <strong>绑定方法(bound method)</strong> 不是属性</li></ul></li><li>函数(function) 和 方法(method) 的区别：<ul><li>函数是可以直接写文件中，方法是只能写在class中</li><li><strong>方法必须带一个默认参数(self)</strong>。如果不带就是非绑定方法(unbound method)，在 Python3 中为普通函数，因为 Python3 取消了 unbound method 的说法</li></ul></li></ul><h1 id="一些相关的-bif"><a class="markdownIt-Anchor" href="#一些相关的-bif"></a> 一些相关的 BIF</h1><p>介绍一些类和对象相关的一些 BIF（内置函数）</p><h2 id="issubclassclass-classinfo"><a class="markdownIt-Anchor" href="#issubclassclass-classinfo"></a> issubclass(class, classinfo)</h2><p><strong>如果第一个参数（class）是第二个参数（classinfo）的一个子类，则返回True，反之返回False</strong></p><ul><li><strong>一个类被认为是其自身的子类</strong></li><li>classinfo 可以是类对象组成的元组，只要是 class 是其中任一类的子类就返回 True</li><li>可能抛出 TypeError 的异常</li></ul><h2 id="isintanceobject-classinfo"><a class="markdownIt-Anchor" href="#isintanceobject-classinfo"></a> isintance(object, classinfo)</h2><p><strong>如果第一个参数（object）是第二个参数（classinfo）的实例对象，则返回True，反之返回False</strong></p><ul><li>如果 object 是 classinfo 的子类的一个实例，也返回 True</li><li>如果第一个不是对象，永远返回 False</li><li>和 issubclass() 相同，classinfo 也可以是类对象组成的元组</li><li>如果第二个不是类或者类对象组成的元组，会抛出 TypeError 的异常</li></ul><h2 id="hasattrobject-name"><a class="markdownIt-Anchor" href="#hasattrobject-name"></a> hasattr(object, name)</h2><p>attr 即 attribute 的缩写，属性的意思，这个 BIF <strong>判断一个对象是否有指定的属性</strong></p><ul><li>第一个参数是对象，第二个是属性名（属性的字符串名字）</li></ul><h2 id="getattrobject-name-default"><a class="markdownIt-Anchor" href="#getattrobject-name-default"></a> getattr(object, name[, default])</h2><p>返回对象指定的属性值，如果指定属性不存在，则返回 default（可选参数）的值，若没有设置 default 参数，则抛出 AttributeError异常</p><h2 id="setattrobject-name-value"><a class="markdownIt-Anchor" href="#setattrobject-name-value"></a> setattr(object, name, value)</h2><p>设置对象中指定属性的值，如果指定属性不存在，那么会新建属性并赋值</p><h2 id="delattrobject-name"><a class="markdownIt-Anchor" href="#delattrobject-name"></a> delattr(object, name)</h2><p>删除对象中指定的属性，如果属性不存在，则抛出 AttributeError异常</p><h2 id="propertyfgetnone-fsetnone-fdelnone-docnone"><a class="markdownIt-Anchor" href="#propertyfgetnone-fsetnone-fdelnone-docnone"></a> property(fget=None, fset=None, fdel=None, doc=None)</h2><p>property() 返回一个可以设置属性的属性，用于管理、封装属性，文档中描述为：<strong>Typical use is to define a managed attribute x</strong></p><ul><li><p>fget：获得属性的方法</p></li><li><p>fset：设置属性的方法</p></li><li><p>fdel：删除属性的方法</p></li><li><p>doc：描述属性的文档</p></li><li><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._x = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setx</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._x = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self._x</span><br><span class="line"></span><br><span class="line">    x = property(getx, setx, delx, <span class="string">"I'm the 'x' property."</span>)</span><br></pre></td></tr></table></figure><ul><li>如果 c 是 C 的实例化, c.x 将触发 getter，c.x = value 将触发 setter，del c.x 触发 deleter。</li><li>如果给定 doc 参数，其将成为这个属性值的 docstring，否则 property 函数就会复制 fget 函数的 docstring（如果有的话）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python GUI入门</title>
      <link href="/2020/02/10/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%20GUI%E5%85%A5%E9%97%A8/"/>
      <url>/2020/02/10/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%20GUI%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="安装-easygui"><a class="markdownIt-Anchor" href="#安装-easygui"></a> 安装 EasyGui</h1><p>EasyGui 可以直接使用 pip 工具安装，打开 CMD 命令行窗口，输入 <strong>pip install easygui</strong> 即可。</p><ul><li><strong>pip(the package installer for Python)</strong> 是 Python 的包管理工具，提供了对 Python 包的查找、下载、安装、卸载功能</li></ul><h2 id="导入-easygui"><a class="markdownIt-Anchor" href="#导入-easygui"></a> 导入 EasyGui</h2><p>为了使用 EasyGui 这个模块，首先应当导入它，有三种方法：</p><ol><li><strong>import easygui</strong><ul><li>这种方法最为简单，但是使用 EasyGui 的函数时，必须加上前缀easygui</li></ul></li><li><strong>from easygui import *</strong><ul><li>导入整个 EasyGui 包，能直接调用 EasyGui 的函数</li><li>会污染命名空间</li></ul></li><li><strong>import easygui as eg</strong><ul><li>建议这样操作，因为既可以保持 EasyGui 的命名空间，也可以减少前缀，直接使用 eg 前缀就可以了</li></ul></li></ol><h2 id="各种功能演示"><a class="markdownIt-Anchor" href="#各种功能演示"></a> 各种功能演示</h2><p>调用 easygui.egdemo() 函数，就可以尝试 EasyGui 拥有的各种功能、</p><h1 id="使用-easygui"><a class="markdownIt-Anchor" href="#使用-easygui"></a> 使用 EasyGui</h1><h2 id="使用按钮组件"><a class="markdownIt-Anchor" href="#使用按钮组件"></a> 使用按钮组件</h2><p>根据需求，EasyGui 在 buttonbox() 上建立了一系列的函数供调用</p><ol><li><p><strong>msgbox()</strong></p><blockquote><p>msgbox(msg=’(Your message goes here)’, title=’ ', ok_button=‘OK’, image=None, root=None)</p></blockquote><ul><li>msg：要显示的信息</li><li>title：标题</li><li>ok_button：可以重写确认按钮</li></ul></li><li><p><strong>ccbox()</strong></p><blockquote><p>ccbox(msg=‘Shall I continue?’, title=’ ', choices=(‘C[o]ntinue’, ‘C[a]ncel’), image=None, default_choice=‘Continue’, cancel_choice=‘Cancel’)</p></blockquote><ul><li>继续选择框，提供两个选择：C[o]ntinue 或者 C[a]ncel，并相应的返回 True 或者 False</li><li>C[o]tinue 中的 [o] 表示快捷键，按一下键盘的 o 相当于单机了 C[o]tinue 按钮</li></ul></li><li><p><strong>ynbox()</strong></p><blockquote><p>ynbox(msg=‘Shall I continue?’, title=’ ‘, choices=(’[<f1>]Yes’, ‘[<f2>]No’), image=None, default_choice=’[<f1>]Yes’, cancel_choice=’[<f2>]No’)</f2></f1></f2></f1></p></blockquote><ul><li>与 ccbox() 一样，但是默认的 choices 参数不同</li><li>这里的[<f1>]也是快捷键</f1></li></ul></li><li><p><strong>buttonbox()</strong></p><blockquote><p>buttonbox(msg=’’, title=’ ', choices=(‘Button[1]’, ‘Button[2]’, ‘Button[3]’), image=None, images=None, default_choice=None, cancel_choice=None, callback=None, run=True)</p></blockquote><ul><li>使用 buttonbox() 可以自定义一组按钮，单机按钮返回按钮的值</li><li>这里文档只有三个按钮，但是实测可以多个</li><li>默认返回 None</li></ul></li><li><p><strong>indexbox()</strong></p><blockquote><p>indexbox(msg=‘Shall I continue?’, title=’ ', choices=(‘Yes’, ‘No’), image=None, default_choice=‘Yes’, cancel_choice=‘No’)</p></blockquote><ul><li>基本与之前的相同，但是这里返回的索引值，而不是按钮的值</li><li>第一个按钮返回索引值0，第二个返回1</li></ul></li><li><p><strong>boolbox()</strong></p><blockquote><p>boolbox(msg=‘Shall I continue?’, title=’ ‘, choices=(’[Y]es’, ‘[N]o’), image=None, default_choice=‘Yes’, cancel_choice=‘No’)</p></blockquote><ul><li>如果第一个按钮被选中返回 True，否则返回 False</li></ul></li></ol><ul><li>以上按钮组件都有一个 image 参数，可以传入图片的路径以显示图片</li></ul><h2 id="为用户提供一系列的选择"><a class="markdownIt-Anchor" href="#为用户提供一系列的选择"></a> 为用户提供一系列的选择</h2><p>buttonbox() 为用于提供了一个简单的按钮选项，如果选项过多，就要采用可选择列表了</p><ol><li><p><strong>choicebox()</strong></p><blockquote><p>choicebox(msg=‘Pick an item’, title=’’, choices=[], preselect=0, callback=None, run=True)</p></blockquote><ul><li>向 choices 传入序列，这些选项会按字母（不区分大小写）进行排序</li></ul></li><li><p><strong>multchoicebox()</strong></p><blockquote><p>multchoicebox(msg=‘Pick an item’, title=’’, choices=[], preselect=0, callback=None, run=True)</p></blockquote><ul><li>基本与 choicebox() 一致，但是 multchoicebox() 支持多选</li></ul></li></ol><h2 id="让用户输入消息"><a class="markdownIt-Anchor" href="#让用户输入消息"></a> 让用户输入消息</h2><ol><li><p><strong>enterbox()</strong></p><blockquote><p>enterbox(msg=‘Enter something.’, title=’ ‘, default=’’, strip=True, image=None, root=None)</p></blockquote><ul><li>提供一个最为简单的输入框，返回值为用户输入的字符串</li><li>默认返回的值会去掉首位空格，若要保留空格的话，设置参数 strip=False</li></ul></li><li><p><strong>integerbox()</strong></p><blockquote><p>integerbox(msg=’’, title=’ ', default=None, lowerbound=0, upperbound=99, image=None, root=None)</p></blockquote><ul><li>用于只能输入范围内的整数，否则会要求用户重新输入</li><li>范围：lowerbound ~ upperbound</li></ul></li><li><p><strong>multenterbox()</strong></p><blockquote><p>multenterbox(msg=‘Fill in values for the fields.’, title=’ ', fields=[], values=[], callback=None, run=True)</p></blockquote><ul><li>提供多个简单的输入框</li><li>如果用户输入值比选项少，则返回列表中的值用空字符串填充为用户输入的项</li><li>如果用户输入的值比选项多，则截断为选项的数量</li><li>取消操作的话，返回域中列表的值或者 None 值</li></ul></li></ol><h2 id="让用户输入密码"><a class="markdownIt-Anchor" href="#让用户输入密码"></a> 让用户输入密码</h2><ol><li><p><strong>passwordbox()</strong></p><blockquote><p>passwordbox(msg=‘Enter your password.’, title=’ ‘, default=’’, image=None, root=None)</p></blockquote><ul><li>passwordbox() 与 enterbox() 样式一样，但是输入的内容是用星号(*)显示出来</li></ul></li><li><p><strong>multpasswordbox()</strong></p><blockquote><p>multpasswordbox(msg=‘Fill in values for the fields.’, title=’ ', fields=(), values=(), callback=None, run=True)</p></blockquote><ul><li>multpasswordbox() 与 multenterbox() 采用相同的接口，但是它的最后一个输入框显示为密码的形式(*)</li></ul></li></ol><h2 id="显示文本"><a class="markdownIt-Anchor" href="#显示文本"></a> 显示文本</h2><ol><li><p><strong>textbox()</strong></p><blockquote><p>textbox(msg=’’, title=’ ‘, text=’’, codebox=False, callback=None, run=True)</p></blockquote><ul><li>默认会以比例字体（codebox=True 设置等宽字体）来显示文本，自动换行，适合于显示一般的书面文字</li><li>有一个 textArea 组件，按 OK 的话会返回 None 或者 输入 textArea 的内容</li></ul></li><li><p><strong>codebox()</strong></p><blockquote><p>codebox(msg=’’, title=’ ‘, text=’’)</p></blockquote><ul><li>以等宽字体显示文本内容，不自动换行，等宽字体适合于代码显示</li><li>相当于 textbox(codebox = True)，与 textbox() 一样有一片 textArea</li></ul></li></ol><h2 id="目录与文件"><a class="markdownIt-Anchor" href="#目录与文件"></a> 目录与文件</h2><p>GUI 编程中一个常见情景：要求用户输入目录及文件名。</p><ol><li><p><strong>diropenbox()</strong></p><blockquote><p>diropenbox(msg=None, title=None, default=None)</p></blockquote><ul><li>提供一个对话框，返回用户选择的目录名（带完整路径），如选择 Cancel，则返回 None</li><li>default 设置默认打开目录（确保目录已存在）</li></ul></li><li><p><strong>fileopenbox()</strong></p><blockquote><p>fileopenbox(msg=None, title=None, default=’*’, filetypes=None, multiple=False)</p></blockquote><ul><li>提供一个对话框，返回用户选择的文件名（带完整路径），如选择 Cancel，则返回 None</li><li>关于 default 参数的设置方法：<ol><li>指定一个默认路径，通常包含<strong>一个或多个通配符</strong>（通配符是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件）</li><li>如果设置了 default 参数，fileopenbox() 会<strong>显示默认的文件路径和格式</strong></li><li>default 默认参数是 ‘*’，即匹配所有格式的文件。</li></ol><ul><li>例如<ul><li>default=‘c:/eason/*.py’ 即显示 c:/eason 文件夹下所有的 Python 源文件</li><li>default=‘c:/eason/test*.py’ 即显示 c:/eason 文件夹下所有的以test开头的 Python 源文件（同样也可以设置xx结尾的）</li></ul></li></ul></li><li>关于 filetypes 参数的设置方法：<ol><li>可以是包含文件掩码的字符串列表，如：filetypes = [’*.txt’]</li><li>可以是字符串列表，列表的最后一项字符串是文件类型的描述，如：[&quot;*.css&quot;, [&quot;*.htm&quot;, “*.html”, “HTML files”]]（HTML files就是对前面两种文件类型的描述）</li></ol></li><li>multiple 参数设置是否可以多选</li></ul></li><li><p><strong>filesavebox()</strong></p><blockquote><p>filesavebox(msg=None, title=None, default=’’, filetypes=None)</p></blockquote><ul><li>提供一个对话框，用于选择文件需要保存的路径</li><li>default 参数应该包含一个文件名（如当前需要保存的文件名），当然也可以为空，或者是一个文件格式掩码的通配符</li><li>filetypes 参数的设置参照 fileopenbox()</li></ul></li></ol><h2 id="捕获异常"><a class="markdownIt-Anchor" href="#捕获异常"></a> 捕获异常</h2><p>使用 EasyGui 编写 GUI 时难免会产生异常，当程序崩溃时，堆栈追踪可能会被抛出，或者被写入 stdout 标准输出函数中。<br>EasyGui 通过 exceptionbox() 将堆栈追踪显示在一个 codebox() 中，并且允许做进一步的处理</p><blockquote><p>exceptionbox(msg=None, title=None)<br>Display a box that gives information about<br>an exception that has just been raised.</p></blockquote><h2 id="记住用户的设置"><a class="markdownIt-Anchor" href="#记住用户的设置"></a> 记住用户的设置</h2><p>GUI 编程中一个常见情景：要求用户设置参数，然后保存下来，以便下次用户使用<br>EasyGui 提供了一个名为 <strong>EgStore</strong> 的类。应用程序必须定义一个类<strong>继承 EgStore 类</strong>，并创建一个该类的<strong>实例化对象</strong><br>设置类的 <strong>构造函数（__init__ 方法）</strong> 必须初始化所有想要记住的那些值。这样这可以在对象中设定值去实例化变量，之后使用 <strong>store()</strong> 方法在硬盘中持久化存储。</p><ul><li><p>保存设置</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> easygui <span class="keyword">as</span> eg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Settings</span><span class="params">(eg.EgStore)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 实例化变量</span></span><br><span class="line">        self.author = <span class="string">''</span></span><br><span class="line">        self.book = <span class="string">''</span></span><br><span class="line">        self.filename = filename</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取保存的文件，第一次打开时为空</span></span><br><span class="line">        <span class="comment"># 第二次以后恢复filename中的内容</span></span><br><span class="line">        self.restore()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">settingsFilename = <span class="string">'setting.txt'</span></span><br><span class="line">settings = Settings(settingsFilename)</span><br><span class="line">settings.author = <span class="string">'Eason'</span></span><br><span class="line">settings.book = <span class="string">'《凯莉生气的十万个原因》'</span></span><br><span class="line">settings.store()</span><br></pre></td></tr></table></figure></li><li><p>恢复设置</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">settingsFilename = <span class="string">'setting.txt'</span></span><br><span class="line">settings = Settings(settingsFilename)</span><br><span class="line">print(settings.author)</span><br><span class="line">print(settings.book)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python异常处理</title>
      <link href="/2020/02/08/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2020/02/08/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="你不能总是对的"><a class="markdownIt-Anchor" href="#你不能总是对的"></a> 你不能总是对的</h1><p>程序总会出现问题，就应该学会用适当的方法去解决问题。<br>可以利用Python提供的异常处理机制，在异常出现的时候及时捕获，并从内部自我处理掉。</p><h2 id="常见异常"><a class="markdownIt-Anchor" href="#常见异常"></a> 常见异常</h2><ol><li>AssertionError：断言语句(assert)失败</li><li>AttributeError：尝试访问未知的对象属性</li><li>IndexError：索引超出序列范围</li><li>KeyError：字典中查找一个不存在的关键字</li><li>NameError：尝试访问一个不存在的变量</li><li>OSError：操作系统产生的异常<ul><li>就是操作系统产生的异常，像打开一个不存在的文件会引发 FileNotFoundError，而这个异常是 OSError 的子类</li></ul></li><li>SyntaxError：Python 的语法错误</li><li>TypeError：不同类型间的无效操作</li><li>ZeroDivisionError：除数为零</li></ol><h1 id="try-except-语句"><a class="markdownIt-Anchor" href="#try-except-语句"></a> try-except 语句</h1><p>用法与java中的try-catch相同，一旦出错，try剩下的语句不再执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    检测范围</span><br><span class="line"><span class="keyword">except</span> Exception [<span class="keyword">as</span> reason]:</span><br><span class="line">    出现异常(Exception)后的处理代码</span><br></pre></td></tr></table></figure><ul><li>BaseException为所有异常的父类</li><li>[as reason] 可以省略，但是如果要对Exception进行操作的话，reason 就代表了抛出的异常，不能省略</li></ul><p>try-except 语句有多种结构：</p><ol><li><p>针对不同异常设置多个except</p><ul><li>类似于 Java 中多个 catch，要从小到大 except 异常</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    检测范围</span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> reason:</span><br><span class="line">    处理OSError</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> reason:</span><br><span class="line">    处理ZeroDivisionError</span><br></pre></td></tr></table></figure></li><li><p>对多个异常统一处理</p><ul><li>except 可以跟着多个异常，直接使用小括号()括起</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    检测范围</span><br><span class="line"><span class="keyword">except</span> (OSError, ZeroDivisionError) <span class="keyword">as</span> reason:</span><br><span class="line">    print(<span class="string">"抛出："</span> + str(reason))</span><br></pre></td></tr></table></figure></li><li><p>捕获所有异常</p><ul><li>直接使用except，或者捕获BaseException</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> [BaseException]:</span><br><span class="line">    处理</span><br></pre></td></tr></table></figure></li></ol><h1 id="raise-语句"><a class="markdownIt-Anchor" href="#raise-语句"></a> raise 语句</h1><p>raise 语句可以直接抛出异常，抛出的异常还能带参数，表示异常的解释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> ZeroDivisionError(<span class="string">"除数为0"</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#0&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">raise</span> ZeroDivisionError(<span class="string">"除数为0"</span>)</span><br><span class="line">ZeroDivisionError: 除数为<span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="丰富的-else-语句"><a class="markdownIt-Anchor" href="#丰富的-else-语句"></a> 丰富的 else 语句</h1><p>Python3 中 else 语句有各种丰富的功能：</p><ol><li><strong>要么怎样，要么不怎样</strong><ul><li>即 if-else 语句</li></ul></li><li><strong>干完了能怎样，干不完就别想怎样</strong><ul><li>else 语句与 for 和 while 循环语句配合使用，else 语句块只有循环完成后才执行</li></ul></li><li><strong>没有问题？那就干吧</strong><ul><li>else 语句与 try-except 语句配合，如果 try 的执行没有异常，就执行 else 语句块的内容；若抛出异常，则不执行</li></ul></li></ol><h1 id="finally-语句"><a class="markdownIt-Anchor" href="#finally-语句"></a> finally 语句</h1><p>finally 语句和 Java 中的 finally 相同，都是无论是否发生异常都将执行 finally 语句块</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20200208155028.png" class="lazyload"></p><h1 id="简洁的-with-语句"><a class="markdownIt-Anchor" href="#简洁的-with-语句"></a> 简洁的 with 语句</h1><p>Python 中提供了一个 with 语句，可以抽象出文件操作中频繁使用的 try-except-else-finally。</p><ul><li>with 语句会自动完成文件的关闭操作</li></ul><p>以下举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'data.txt'</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> each_line <span class="keyword">in</span> f:</span><br><span class="line">            print(each_line)</span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> reason:</span><br><span class="line">    print(str(reason))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python永久存储</title>
      <link href="/2020/02/06/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E6%B0%B8%E4%B9%85%E5%AD%98%E5%82%A8/"/>
      <url>/2020/02/06/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E6%B0%B8%E4%B9%85%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="文件"><a class="markdownIt-Anchor" href="#文件"></a> 文件</h1><h2 id="打开文件"><a class="markdownIt-Anchor" href="#打开文件"></a> 打开文件</h2><p>在Python中，使用 <strong>open()</strong> 内置函数来 <strong>打开文件并返回文件对象</strong></p><blockquote><p>open(file, mode=‘r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)<br>Open file and return a stream.  Raise OSError upon failure.</p></blockquote><p><strong>open()</strong> 有很多参数，值得注重的有：</p><ul><li>file：传入的文件名<ul><li>如果只有文件名，那么会在当前文件夹中寻找文件</li></ul></li><li>mode：指定文件打开模式<table><thead><tr><th>打开模式</th><th>执行操作</th></tr></thead><tbody><tr><td>‘r’</td><td>open for reading (default)</td></tr><tr><td>‘w’</td><td>open for writing, truncating the file first</td></tr><tr><td>‘x’</td><td>create a new file and open it for writing</td></tr><tr><td>‘a’</td><td>open for writing, appending to the end of the file if it exists</td></tr><tr><td>‘b’</td><td>binary mode</td></tr><tr><td>‘t’</td><td>text mode (default)</td></tr><tr><td>‘+’</td><td>open a disk file for updating (reading and writing)</td></tr><tr><td>‘U’</td><td>universal newline mode (deprecated)</td></tr></tbody></table></li></ul><h2 id="文件对象的方法"><a class="markdownIt-Anchor" href="#文件对象的方法"></a> 文件对象的方法</h2><p>下表列举了一些常用的文件对象方法。</p><table><thead><tr><th>文件对象的方法</th><th>执行操作</th></tr></thead><tbody><tr><td>close()</td><td>关闭文件</td></tr><tr><td>read(size = -1)</td><td>从文件读取 size 个字符，当 size 为负值时，读取所有字符，然后返回字符串</td></tr><tr><td>readline()</td><td>从文件中读取一整行字符串</td></tr><tr><td>write(str)</td><td>将字符串str写入文件</td></tr><tr><td>writelines(seq)</td><td>写入字符串序列seq</td></tr><tr><td>seek(offset, from)</td><td>在文件中移动文件指针，从 from（0表示文件起始位置，1表示当前位置，2表示文件末尾）偏移 offset 个字节</td></tr><tr><td>tell()</td><td>返回当前文件中的位置</td></tr></tbody></table><h2 id="文件的关闭"><a class="markdownIt-Anchor" href="#文件的关闭"></a> 文件的关闭</h2><p>close() 用于文件的关闭。但是Python具有垃圾收集机制，会自动关闭文件。但是，这不代表可以不要关闭文件，因为Python可能会缓存写入的数据，一旦程序出现意外，缓存的数据不会写入。为了安全起见，最好要使用完立刻关闭文件</p><h2 id="文件的读取和定位"><a class="markdownIt-Anchor" href="#文件的读取和定位"></a> 文件的读取和定位</h2><p>文件的读取有很多方法：</p><ul><li><strong>read()</strong> 和 <strong>readline()</strong><ul><li>read() 按字节读取<ul><li>但是在读取中文时，会按两个字节取出一个完整的中文</li></ul></li><li>readline() 按行读取（读取到&quot;\n&quot;）</li></ul></li><li>直接 list(file) 或者使用迭代来读取<ul><li>list(file) 会将文件按行分成列表</li><li>迭代读取的话可以直接使用file，因为<strong>文件对象本身是一个可迭代对象</strong></li></ul></li></ul><p>文件指针：可以认为是个“书签”，起到定位的作用，<strong>按字节计数</strong>（中文为两个字节）</p><ul><li><strong>seek()</strong> 移动文件指针，seek(0, 0) 设置指针回到文件起始位置</li><li><strong>tell()</strong> 告诉当前文件指针的位置</li></ul><h2 id="文件的写入"><a class="markdownIt-Anchor" href="#文件的写入"></a> 文件的写入</h2><p>打开模式要有 <strong>‘w’(覆盖写入)</strong> 和 <strong>‘a’(写在末尾)</strong></p><ul><li><strong>血的教训：‘w’ 模式会直接删除原有内容，无论你是否有写入</strong></li></ul><h1 id="文件系统"><a class="markdownIt-Anchor" href="#文件系统"></a> 文件系统</h1><p>介绍一些与Python文件相关的模块。</p><ul><li>模块(Module)：是一个Python文件，以 <strong>.py</strong> 结尾，能更好的组织Python代码段</li></ul><h2 id="os-模块"><a class="markdownIt-Anchor" href="#os-模块"></a> OS 模块</h2><p>OS(Operating System)：操作系统模块</p><p>以下是OS模块中关于文件/目录的常用函数</p><table><thead><tr><th>函数名</th><th>使用方法</th></tr></thead><tbody><tr><td>getcwd()</td><td>返回当前工作目录</td></tr><tr><td>chdir(path)</td><td>改变工作目录</td></tr><tr><td>listdir(path=’.’)</td><td>列举指定目录中的文件名（’.‘表示当前目录，’…'表示上一级目录）</td></tr><tr><td>mkdir(path)</td><td>创建单层目录，如已存在则抛出异常</td></tr><tr><td>makedirs(path)</td><td>递归创建多层目录</td></tr><tr><td>remove(path)</td><td>删除文件</td></tr><tr><td>rmdir(path)</td><td>删除单层目录，如该目录非空则抛出异常</td></tr><tr><td>removedirs(path)</td><td>递归删除目录，从子目录逐层尝试删除，遇到目录非空则抛出异常</td></tr><tr><td>rename(old, new)</td><td>将文件old重命名为new</td></tr><tr><td>system(commond)</td><td>运行系统的shell指令</td></tr><tr><td>walk(top)</td><td>遍历top参数指定目录的所有子目录，返回一个(路径, [包含目录], [包含文件])的三元组生成器</td></tr></tbody></table><p>以下是支持路径操作中常用的一些定义，支持所有平台</p><table><thead><tr><th>定义</th><th>含义</th></tr></thead><tbody><tr><td>os.curdir</td><td>指代当前目录(’.’)</td></tr><tr><td>os.pardir</td><td>指代上一级目录(’…’)</td></tr><tr><td>os.seq</td><td>输出操作系统特定的路径分隔符（Win下为’\\’，Linux下为’/’）</td></tr><tr><td>os.lineseq</td><td>当前平台使用的终止符（Win下为’\r\n’，Linux下为’\n’）</td></tr><tr><td><a href="http://os.name" target="_blank" rel="noopener">os.name</a></td><td>指代当前使用的操作系统（包括’posix’,‘nt’,‘mac’,‘os2’,‘ce’,‘java’）</td></tr></tbody></table><h2 id="ospath-模块"><a class="markdownIt-Anchor" href="#ospath-模块"></a> OS.path 模块</h2><p>OS.path 模块可以完成一些针对路径的操作。</p><p>以下列举了 OS.path 常用函数</p><table><thead><tr><th>函数名</th><th>使用方法</th></tr></thead><tbody><tr><td>basename()</td><td>去掉目录路径，单独返回文件名</td></tr><tr><td>dirname()</td><td>去掉文件名，单独返回目录</td></tr><tr><td>join(path1[,path2[,…]])</td><td>将path1，path2各部分组合成一个路径名</td></tr><tr><td>split(path)</td><td>分割文件名和路径，返回(f_path,f_name)元组</td></tr><tr><td>splitext(path)</td><td>分离文件名和扩展名，返回(f_name,f_extension)元组</td></tr><tr><td>getsize(file)</td><td>返回指定文件的尺寸，单位是字节</td></tr><tr><td>getatime(file)</td><td>返回指定文件的最近访问时间</td></tr><tr><td>getctime(file)</td><td>返回指定文件的创建时间</td></tr><tr><td>getmtime(file)</td><td>返回指定文件最新的修改时间</td></tr></tbody></table><ul><li>join(path1[,path2[,…]])：用于将路径名和文件名组合成一个完整的路径</li><li>split(path)：如果只传入一个目录，它也会将最后一层目录当作文件名分离，<strong>不会去判断文件或者目录是否存在</strong></li><li>getatime(file)，getctime(file)，getmtime(file)：返回值都是浮点型秒数，可用 <strong>time模块</strong> 的 <strong>gmtime()</strong> 或 <strong>localtime()</strong> 函数换算</li></ul><p>以下函数返回True or False</p><table><thead><tr><th>函数名</th><th>使用方法</th></tr></thead><tbody><tr><td>exists(path)</td><td>（目录或文件）是否存在</td></tr><tr><td>isabs(path)</td><td>是否为绝对路径</td></tr><tr><td>isdir(path)</td><td>是否存在且是一个目录</td></tr><tr><td>isfile(path)</td><td>是否存在且是一个文件</td></tr><tr><td>islink(path)</td><td>是否存在且是一个符号链接</td></tr><tr><td>ismount(path)</td><td>是否存在且是一个挂载点</td></tr><tr><td>samefile(path1,path2)</td><td>两个路径是否指向同一文件</td></tr></tbody></table><h2 id="pickle-模块"><a class="markdownIt-Anchor" href="#pickle-模块"></a> pickle 模块</h2><p>pickle 模块几乎可以把所有 Python 的对象都转化成二进制的形式存在，这个过程称为 pickling，把二进制形式转化成对象的过程称为 unpickling。</p><ul><li>也可以称为 <strong>序列化(serializing)</strong> 和 <strong>反序列化(de-serializing)</strong>，与java中类似，将对象转换成二进制形式</li></ul><h3 id="常用函数"><a class="markdownIt-Anchor" href="#常用函数"></a> 常用函数</h3><ol><li>pickle.dump(obj, file, protocol=None, *, fix_imports=True, buffer_callback=None)¶<ul><li>obj 表示将要封装的对象</li><li>file 表示 obj 要写入的文件对象，必须以 ‘wb’ 模式打开，即二进制可写模式</li><li>protocol 表示 pickle 使用的协议，有0，1，2，3，默认是 Python3 中使用的3</li></ul></li><li>pickle.load(file, *, fix_imports=True, encoding=“ASCII”, errors=“strict”, buffers=None)<ul><li>file 必须以 'rb’模式打开，即二进制可读模式</li><li>其他均为可选参数</li></ul></li><li>pickle.dumps(obj, protocol=None, *, fix_imports=True, buffer_callback=None)<ul><li>以字节对象形式返回封装的对象，而不是将其写入文件</li></ul></li><li>pickle.loads(bytes_object, *, fix_imports=True, encoding=“ASCII”, errors=“strict”, buffers=None)<ul><li>从字节对象中读取并返回被封装的对象</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python字典和集合</title>
      <link href="/2020/02/05/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"/>
      <url>/2020/02/05/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="字典当索引不好用时"><a class="markdownIt-Anchor" href="#字典当索引不好用时"></a> 字典：当索引不好用时</h1><p>字典类似于Java中的Map，就是建立两个列表间的映射（key-value）。<br>使用 <strong>大括号{}</strong> 定义，由 <strong>“键”</strong> 和 <strong>“值”</strong> 共同构成，每一对键值组合称为 <strong>“项”</strong></p><ul><li>字典中的键独一无二，且必须不可变类型</li><li>值可重复，可以取任意值</li><li>字典不支持拼接和重复操作的，因为键独一无二</li></ul><h2 id="创建方法"><a class="markdownIt-Anchor" href="#创建方法"></a> 创建方法</h2><ol><li>直接使用 <strong>大括号{}</strong> ，如dict1</li><li>使用 <strong>dict()</strong> 内置函数创建<ul><li><strong>键值对要打包成元组送入</strong>，因为 <strong>dict()只接受一个序列</strong>，如dict2</li><li>通过提供具有映射关系的参数建立，<strong>键的位置不能加上引号</strong>，如dict3</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">'L'</span>: <span class="number">1</span>, <span class="string">'O'</span>: <span class="number">2</span>, <span class="string">'V'</span>: <span class="number">3</span>, <span class="string">'E'</span>: <span class="number">4</span>&#125;</span><br><span class="line">dict2 = dict(((<span class="string">'L'</span>, <span class="number">1</span>), (<span class="string">'O'</span>, <span class="number">2</span>), (<span class="string">'V'</span>, <span class="number">3</span>), (<span class="string">'E'</span>,<span class="number">4</span>)))</span><br><span class="line">dict3 = dict(L = <span class="number">1</span>, O = <span class="number">2</span>, V = <span class="number">3</span>, E = <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="访问方法"><a class="markdownIt-Anchor" href="#访问方法"></a> 访问方法</h2><p>访问字典里的值与访问序列雷子，只需要把相应的键放入 <strong>方括号[]</strong> 即可</p><ul><li>如果键不存在，则抛出KeyError</li><li>如果是一个赋值语句，则覆盖或者新建键值对</li></ul><h2 id="内置方法"><a class="markdownIt-Anchor" href="#内置方法"></a> 内置方法</h2><h3 id="fromkeysseq-value"><a class="markdownIt-Anchor" href="#fromkeysseq-value"></a> fromkeys(seq[, value])</h3><p>fromkeys()方法用于新建并返回一个新的字典，它有两个参数：</p><ul><li><strong>第一个参数是字典的键；</strong></li><li><strong>第二个是可选的，传入所有键对应的值</strong>，如果没有传入，则默认None<ul><li>如果第二参数传入的是序列，也会被当成一个Value赋给所有的key</li></ul></li></ul><h3 id="keysvaluesitems"><a class="markdownIt-Anchor" href="#keysvaluesitems"></a> <em>keys()，values()，items()</em></h3><ul><li><strong>keys()返回字典中所有的键 &lt;class ‘dict_keys’&gt;</strong></li><li><strong>values()返回字典中所有的值 &lt;class ‘dict_values’&gt;</strong></li><li><strong>items()返回字典中所有的键值对 &lt;class ‘dict_items’&gt;</strong></li></ul><h3 id="getkey-default"><a class="markdownIt-Anchor" href="#getkey-default"></a> get(key[, default])</h3><p>get() 提供了更宽松的方法访问字典，当键不存在时，不会报错，而是返回None</p><ul><li>第二个参数用于设置键不存在时返回的值，默认None，因此默认返回None</li><li>可以用成员资格操作符 <strong>in</strong> 和 <strong>not in</strong> 来判断键是否存在</li></ul><h3 id="clear"><a class="markdownIt-Anchor" href="#clear"></a> clear()</h3><p>clear() 用于清空词典</p><h3 id="copy"><a class="markdownIt-Anchor" href="#copy"></a> copy()</h3><p>copy() 方法用于拷贝（浅拷贝）整个字典</p><ul><li><p>在这里，浅拷贝的含义是，字典是不同字典，但是里面的键，值为同一内存区域</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1 = &#123;<span class="number">1</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2 = dict1.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典已经不同</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(dict1) == id(dict2)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是子对象相同</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(dict1[<span class="number">1</span>]) == id(dict2[<span class="number">1</span>])</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></li><li><p>扩展学习：</p><ul><li>直接赋值：对象的引用（别名）</li><li>浅拷贝：copy，拷贝父对象，子对象还是引用</li><li>深拷贝：deepcopy，完全拷贝，父子对象都拷贝</li></ul></li></ul><h3 id="popket-default-和-popitem"><a class="markdownIt-Anchor" href="#popket-default-和-popitem"></a> pop(ket[, default]) 和 popitem()</h3><ul><li>pop()是给定键弹出对应的值</li><li>popitem()弹出最后一个项</li><li>这里的弹出是返回并删除</li></ul><h3 id="setdefaultkey-default"><a class="markdownIt-Anchor" href="#setdefaultkey-default"></a> setdefault(key[, default])</h3><p>setdefault() 与 get() 类似，但是，<strong>setdefault() 在字典中找不到键时会自动添加</strong></p><ul><li><strong>第二个参数是不仅是返回值，还是新建键值对的值</strong></li></ul><h3 id="updateother"><a class="markdownIt-Anchor" href="#updateother"></a> update([other])</h3><p>update() 方法用于更新字典，<strong>将键对应的值更新</strong></p><ul><li>此功能与新建键值对的覆盖类似</li></ul><h1 id="集合你就是我的唯一"><a class="markdownIt-Anchor" href="#集合你就是我的唯一"></a> 集合：你就是我的唯一</h1><p>与Java中的Set相同，Python中的集合(set)的特点是：<strong>唯一，无序</strong>，与字典相同使用 <strong>大括号{}</strong>，但是没有映射关系</p><h2 id="创建集合"><a class="markdownIt-Anchor" href="#创建集合"></a> 创建集合</h2><ol><li>直接把一大堆元素用 <strong>大括号{}</strong> 括起来<ul><li>但是如果要建立空集合，这样子做会被Python认为是字典</li></ul></li><li>用 <strong>set()</strong> 内置函数，传入可迭代对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set2 = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set1 == set2</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>如果创建中的元素有重复，会只留下一个</li></ul><h2 id="访问集合"><a class="markdownIt-Anchor" href="#访问集合"></a> 访问集合</h2><p>因为集合是无序的，因此<strong>不能使用下标访问</strong>，只能用迭代把集合中的数据一个个读取出来</p><ul><li>可以用 <strong>in</strong> 和 <strong>not in</strong>，判断一个元素是否存在</li><li>可以使用add()，remove()内置方法增删元素</li></ul><h2 id="不可变集合"><a class="markdownIt-Anchor" href="#不可变集合"></a> 不可变集合</h2><p>不可变集合(frozenset)中的元素只能访问，不能修改</p><ul><li>使用 <strong>frozenset()</strong> 函数创建不可变集合，传入可迭代对象，返回为&lt;class ‘frozenset’&gt;</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python函数</title>
      <link href="/2020/02/03/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E5%87%BD%E6%95%B0/"/>
      <url>/2020/02/03/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数定义"><a class="markdownIt-Anchor" href="#函数定义"></a> 函数定义</h1><p>以下是简单的规则：</p><ul><li>函数代码块以 <strong>def关键词</strong> 开头，后接 <strong>函数标识符名称</strong> 和 <strong>圆括号()</strong>。</li><li>任何传入参数和自变量必须放在圆括号中间，<strong>圆括号之间可以用于定义参数</strong>。</li><li>函数内容以冒号起始，并且缩进。</li><li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li></ul><h2 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(函数列表)</span>:</span></span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure><h1 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h1><p>定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。<br>这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。</p><h1 id="参数传递"><a class="markdownIt-Anchor" href="#参数传递"></a> 参数传递</h1><p>在 python 中，类型属于对象，而变量是没有类型的，它<strong>只是一个引用，可以代表任何对象</strong></p><blockquote><p><strong>可更改(mutable)与不可更改(immutable)对象</strong>：<br>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p><ul><li>不可变类型：新建了一个对象赋值给变量，原对象被丢弃</li><li>可变类型：修改了对象</li></ul></blockquote><ul><li>python的参数传递：<ul><li>不可变类型：类似于值传递，即拷贝传值，不影响原对象</li><li>可变类型：类似于引用传递，影响原对象</li></ul></li><li>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</li></ul><h1 id="参数"><a class="markdownIt-Anchor" href="#参数"></a> 参数</h1><p>python中的正式参数类型：</p><ul><li>必需参数</li><li>关键字参数</li><li>默认参数</li><li>不定长参数</li></ul><h2 id="必需参数"><a class="markdownIt-Anchor" href="#必需参数"></a> 必需参数</h2><p>必需参数须以<strong>正确的顺序</strong>传入函数。调用时的<strong>数量必须和声明时的一样</strong>。</p><h2 id="关键字参数"><a class="markdownIt-Anchor" href="#关键字参数"></a> 关键字参数</h2><p>关键字参数和函数调用关系紧密，函数调用<strong>使用关键字参数来确定传入的参数值</strong>。</p><ul><li>使用关键字参数<strong>允许函数调用时参数的顺序与声明时不一致</strong>，因为 Python 解释器能够<strong>用参数名匹配参数值</strong>。</li></ul><h2 id="默认参数"><a class="markdownIt-Anchor" href="#默认参数"></a> 默认参数</h2><p>与C++中的默认参数一致，调用函数时，如果没有传递参数，则会使用默认参数。</p><h2 id="不定长参数"><a class="markdownIt-Anchor" href="#不定长参数"></a> 不定长参数</h2><p>也称收集参数，你可能需要一个函数能处理比当初声明时更多的参数，这些参数叫做不定长参数。</p><h3 id="单星号tuple"><a class="markdownIt-Anchor" href="#单星号tuple"></a> 单星号*(tuple)</h3><p>加了 <strong>星号</strong>* 的参数会以 <strong>元组(tuple)</strong> 的形式导入，存放所有未命名的变量参数。</p><ul><li>若没有指定，则为空元组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">(*vartuple, end = <span class="string">"\n"</span>)</span>:</span></span><br><span class="line">    <span class="string">"打印所有传入的参数"</span></span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> vartuple:</span><br><span class="line">        print(var, end = end)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用printinfo</span></span><br><span class="line"><span class="comment"># printinfo(1,2,3,4,5,end="")</span></span><br><span class="line"><span class="comment"># 12345</span></span><br></pre></td></tr></table></figure><h3 id="双星号dict"><a class="markdownIt-Anchor" href="#双星号dict"></a> 双星号**(dict)</h3><p>加了 <strong>两个星号**</strong> 的参数会以 <strong>字典(dict)</strong> 的形式导入。使用方法与上面类似。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li><strong>星号*</strong> 可以单独出现，但是如果单独出现 <strong>星号*</strong> 后的参数必须用关键字传入。</li><li>其实 <strong>星号*</strong> 起到“打包”作用，将多个参数打包成一个元组<ul><li><strong>星号*</strong> 在形参中的作用是“打包”，在实参中的作用是“解包”</li></ul></li><li>若作为不定长参数传入元组和字典时，<strong>要加上<em>星号*</em> 和 <em>双星号**</em>，即传入时要解包</strong>，否则元组和字典只会被当作一个参数</li></ul><h1 id="变量作用域"><a class="markdownIt-Anchor" href="#变量作用域"></a> 变量作用域</h1><h2 id="局部变量"><a class="markdownIt-Anchor" href="#局部变量"></a> 局部变量</h2><p>定义在函数内部的变量是局部变量，它的作用域：函数内部，不能在函数外部被引用</p><h2 id="全局变量"><a class="markdownIt-Anchor" href="#全局变量"></a> 全局变量</h2><p>与局部变量相对，拥有更大的作用域，可以在函数中访问</p><ul><li>函数中可以访问全局变量，但是不能修改（Python会在函数内部新建了一个局部变量，真正的全局变量不被改变）</li></ul><h2 id="global关键字"><a class="markdownIt-Anchor" href="#global关键字"></a> global关键字</h2><p>Python使用 <strong>屏蔽（shadowing）</strong> 保护全局变量：一旦函数内部试图修改全局变量，那么就会新建一个名字一样的局部变量代替，保护全局变量。<br>如果你还是要坚持修改，使用 <strong>global关键字</strong> 声明该全局变量，即可在函数内部修改全局变量。</p><h2 id="内嵌函数"><a class="markdownIt-Anchor" href="#内嵌函数"></a> 内嵌函数</h2><p>Python的函数定义支持嵌套，定义在别的函数内部的被称为内嵌函数或者内部函数</p><ul><li>内部函数整个作用域在外部函数之内，只有在<strong>外部函数里才能调用内嵌函数</strong></li><li><strong>内部函数可以引用外部函数的局部变量</strong>，此时内部函数称为 <strong>闭包</strong> ，但是与全局变量类似，不能在内部函数修改外部函数的局部变量，且不能使用 <strong>global</strong> 修改，可以使用 <strong>nolocal关键字</strong> 修改</li></ul><h2 id="legb原则"><a class="markdownIt-Anchor" href="#legb原则"></a> LEGB原则</h2><p>变量查找的顺序按照 <strong>L→E→G→B</strong></p><ul><li>LEGB含义解释：<ul><li>L-Local：函数内的名字空间</li><li>E-Enclosing function locals：嵌套函数中外部函数的名字空间</li><li>G-Global：函数定义所在模块的名字空间</li><li>B-Builtin：Python内置模块的名字空间</li></ul></li></ul><h2 id="闭包"><a class="markdownIt-Anchor" href="#闭包"></a> 闭包</h2><p><strong>闭包(closure)是语法闭包(lexical closure)的简称，是引用了自由变量的函数</strong>。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。</p><ul><li>Python中的闭包表现在：如果一个内部函数里，对在外部作用域但不是在全局作用域的变量进行引用，那么内部函数就是闭包<ul><li>在闭包中，外部函数的局部变量对应内部函数的局部变量，相当于全局变量与局部变量的关系，<strong>可以访问不能修改</strong>，但是可以使用 <strong>nolocal关键字</strong> 修改</li></ul></li></ul><h2 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h2><p><strong>装饰器(decorator)</strong> 的功能：将被装饰的函数当作参数传递给装饰器对应的函数（名称相同的函数），并返回包装后的被装饰的函数</p><ul><li><p>@语法糖</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 给eat函数加上日志</span><br><span class="line">def log(func):</span><br><span class="line">def wrapper():</span><br><span class="line">    print(&quot;开始调用eat函数&quot;)</span><br><span class="line">    func()</span><br><span class="line">    print(&quot;结束调用eat函数&quot;)</span><br><span class="line">return wrapper</span><br><span class="line"></span><br><span class="line"># @log 等价于 log(eat())</span><br><span class="line">@log</span><br><span class="line">def eat():</span><br><span class="line">print(&quot;开始吃了&quot;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; eat()</span><br><span class="line">开始调用eat函数</span><br><span class="line">开始吃了</span><br><span class="line">结束调用eat函数</span><br></pre></td></tr></table></figure><ul><li>可以省去手动将eat()传递给log()再将返回值重新赋值的过程（eat = log(eat)）</li></ul></li><li><p>如果使用 <strong>@语法糖</strong> 时候，eat()有参数，<strong>最好使用不定长参数</strong>，不然在修改eat()的参数时，也要修改装饰器log()</p></li><li><p><strong>@语法糖也可以嵌套使用</strong></p></li></ul><h1 id="函数式编程"><a class="markdownIt-Anchor" href="#函数式编程"></a> 函数式编程</h1><p>函数式编程(funtional programming)，是一种编程范式，它将电脑运算视为函数运算，并避免使用程序状态以及易变对象。</p><ul><li>其中，<strong>λ演算(lambda calculus)</strong> 为该语言最重要的基础。而且，λ演算的函数 <strong>可以接受函数当作输入（引数）和输出（传出值）</strong>。</li></ul><h2 id="lambda"><a class="markdownIt-Anchor" href="#lambda"></a> lambda</h2><p>Python使用 <strong>lambda关键字</strong> 来创建 <strong>匿名函数</strong>，简化函数定义的过程。</p><ul><li>基本语法：使用 <strong>冒号:</strong> 分隔函数的参数及返回值<ul><li>冒号左边放参数，使用 <strong>逗号,</strong> 隔开</li><li>冒号右边是函数的返回值</li></ul></li><li>执行完 <strong>lambda</strong> 返回的是一个函数对象，如果要对它进行调用，只需要给它绑定一个临时的名字  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = <span class="keyword">lambda</span> x,y : x**y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="filter"><a class="markdownIt-Anchor" href="#filter"></a> filter()</h2><p>filter()函数是一个过滤器，它的作用是在海量得数据里面提取出有用得信息</p><blockquote><p>class filter(object)<br>|  filter(function or None, iterable) --&gt; filter object<br>|<br>|  Return an iterator yielding those items of iterable for which function(item)<br>|  is true. If function is None, return the items that are true.</p></blockquote><ul><li>filter有两个参数：第一个是一个函数或者None<ul><li>如果是一个函数的话，则把第二个可迭代对象里的每一个元素作为函数的参数进行计算，筛选出返回True的元素</li><li>如果是None，则直接将第二个参数中为True的值筛选出来</li></ul></li><li><strong>filter()返回的是一个迭代器对象</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 筛选出0~9中的奇数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(<span class="keyword">lambda</span> x : x%<span class="number">2</span>, range(<span class="number">10</span>)))</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><h2 id="map"><a class="markdownIt-Anchor" href="#map"></a> map()</h2><p>map()会根据提供的函数对指定序列做映射。</p><blockquote><p>class map(object)<br>|  map(func, *iterables) --&gt; map object<br>|<br>|  Make an iterator that computes the function using arguments from<br>|  each of the iterables.  Stops when the shortest iterable is exhausted.</p></blockquote><ul><li>map有两个参数：一个函数和一个可迭代对象，将可迭代对象的每一个元素作为函数的参数进行运算加工，直至可迭代序列每个元素都加工完毕，即 <strong>将序列的每一个元素通过函数进行映射</strong></li><li><strong>map()第二个参数是不定长参数，支持多个可迭代对象</strong>。map()会从所有可迭代对象各取一个元素组成元组，类似于zip()函数，然后将元组传递给func（第一个参数）<ul><li>以短的可迭代对象为止</li></ul></li><li><strong>map()返回的是一个迭代器</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python序列</title>
      <link href="/2020/01/31/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E5%BA%8F%E5%88%97/"/>
      <url>/2020/01/31/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="列表一个打了激素的数组"><a class="markdownIt-Anchor" href="#列表一个打了激素的数组"></a> 列表：一个打了激素的数组</h1><p>列表类似于数组，但是比数组更加强大，它能 <strong>同时存放不同类型的变量</strong></p><h2 id="创建列表"><a class="markdownIt-Anchor" href="#创建列表"></a> 创建列表</h2><p>只需使用 <strong>方括号[]</strong> 将数据包裹起来（数据之间用逗号隔开）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h2 id="增删改查"><a class="markdownIt-Anchor" href="#增删改查"></a> 增删改查</h2><h3 id="增"><a class="markdownIt-Anchor" href="#增"></a> 增</h3><ol><li>append()：将元素添加在列表末尾</li><li>extend()：使用一个列表来扩充另一个列表</li><li>insert()：第一个参数指定待插入位置（索引值），第二个参数是待插入的元素</li></ol><h3 id="删"><a class="markdownIt-Anchor" href="#删"></a> 删</h3><ol><li>remove()：指定一个待删除元素，不需要知道位置</li><li>pop()：将指定元素取出并删除，参数是一个索引值（不带参数的话，默认弹出最后一个）</li><li>del：Python中的del关键词，可以直接删除列表或列表中的某个元素</li></ol><h3 id="改"><a class="markdownIt-Anchor" href="#改"></a> 改</h3><ol><li>使用一个temp变量作为中间值，交换元素</li><li>偷懒方法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eggs[<span class="number">1</span>], eggs[<span class="number">2</span>] = eggs[<span class="number">2</span>], eggs[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"><span class="comment"># temp = eggs[1]</span></span><br><span class="line"><span class="comment"># eggs[1] = eggs[2]</span></span><br><span class="line"><span class="comment"># eggs[2] = temp</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="查"><a class="markdownIt-Anchor" href="#查"></a> 查</h3><p>通过索引值直接获取，与数组相同</p><ul><li>当索引值为负数时，表示从列表的末尾反向索引</li></ul><h2 id="切片slice"><a class="markdownIt-Anchor" href="#切片slice"></a> 切片(slice)</h2><p>取出列表的部分元素，用冒号隔开两个索引值，即可返回一个切片（新列表）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list2 = list[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 以list1中索引值2到5作为一个新列表，赋值给list2</span></span><br></pre></td></tr></table></figure><ul><li>如果索引值全部为空，则返回列表的拷贝</li></ul><h3 id="步长"><a class="markdownIt-Anchor" href="#步长"></a> 步长</h3><p>切片可以接受第三个参数：步长（默认值1）</p><ul><li>可以设置步长为-1，逆置列表</li></ul><h2 id="常用操作符"><a class="markdownIt-Anchor" href="#常用操作符"></a> 常用操作符</h2><ul><li>比较操作符：从第一个元素开始比较，只要有一个赢了，就算整个列表赢了，与字符串的比较同理</li><li>连接操作符(+)：将多个列表对象来合并起来</li><li>重复操作符(*)：重复列表</li><li>成员关系操作符：<strong>in</strong> 和 <strong>not in</strong>（只能判断一个层次的成员关系）</li></ul><h1 id="元组戴上了枷锁的列表"><a class="markdownIt-Anchor" href="#元组戴上了枷锁的列表"></a> 元组：戴上了枷锁的列表</h1><p>元组（tuple）：只读，不可写的列表</p><h2 id="创建"><a class="markdownIt-Anchor" href="#创建"></a> 创建</h2><p>使用 <strong>小括号()</strong> 创建，元素用逗号隔开</p><ul><li>其实小括号是可以不要的，关键是逗号，小括号只是补充<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple1 = (<span class="number">520</span>,)</span><br><span class="line">tuple2 = <span class="number">520</span>,</span><br><span class="line"><span class="comment"># tuple1和tuple2是同样的元组</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="访问"><a class="markdownIt-Anchor" href="#访问"></a> 访问</h2><p>直接使用下标访问，或者使用切片</p><h2 id="更新和删除"><a class="markdownIt-Anchor" href="#更新和删除"></a> 更新和删除</h2><ul><li>元组并不能改变，但是我们可以创建一个新的同名元组，来起到更新和删除的功能</li><li>若要删除元组，使用 del 即可</li></ul><h1 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h1><p>字符串在基础知识中已经学了不少，这里只是加入来学习序列的同一性</p><ul><li>字符串和元组一样，不能修改，只能通过新建同名字符串</li></ul><h2 id="切片"><a class="markdownIt-Anchor" href="#切片"></a> 切片</h2><p>字符串可以使用索引值访问，当然也可以使用切片功能</p><h2 id="内置函数"><a class="markdownIt-Anchor" href="#内置函数"></a> 内置函数</h2><ul><li>count(sub,[start[,end]])：计算sub参数在字符串中出现的次数，可选参数start和end</li><li>find(sub[,start[,end]]) 和 index(sub[,start[,end]])：都是寻找sub第一次出现的位置，返回索引值<ul><li>找不到的话find返回-1；index抛出异常</li></ul></li><li>replace(old,new[,count])：将原字符串中的old替换成new，可以指定次数</li><li>split(seq=None, maxsplit=-1)：拆分字符串，返回一个字符串列表</li><li>join(iterable)：拼接字符串<ul><li>使用方法：<strong>&quot;,&quot;.join(elems)</strong>。因为join的参数是一切可迭代对象，如果将其写在左侧，那就<strong>必须对所有这些对象新建join方法</strong>,因而将字符串写在前面。</li></ul></li></ul><h3 id="格式化"><a class="markdownIt-Anchor" href="#格式化"></a> 格式化</h3><h4 id="format"><a class="markdownIt-Anchor" href="#format"></a> format()</h4><p>举例即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"&#123;0&#125; &#123;1&#125; make a &#123;2&#125;"</span>.format(<span class="string">"I"</span>, <span class="string">"will"</span>, <span class="string">"difference"</span>)</span><br><span class="line"><span class="comment"># I will make a difference</span></span><br></pre></td></tr></table></figure><h3 id><a class="markdownIt-Anchor" href="#"></a> %</h3><p>字符串独享的 <strong>格式化操作符(%)</strong></p><ul><li>当 % 出现在字符中，它表示格式化操作符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'%c%c'</span> % (<span class="number">65</span>, <span class="number">97</span>)</span><br><span class="line"><span class="comment"># 'Aa'</span></span><br></pre></td></tr></table></figure><h1 id="序列"><a class="markdownIt-Anchor" href="#序列"></a> 序列</h1><p>列表，元组和字符串都是序列，它们有很多共同点：</p><ul><li>都可以通过索引值访问（默认为0，也支持负数索引）</li><li>可以使用切片</li><li>有很多共同操作符（重复、拼接、成员关系）</li></ul><h2 id="常用bif"><a class="markdownIt-Anchor" href="#常用bif"></a> 常用BIF</h2><ol><li>list([iterable])：将一个可迭代对象转换成列表<ul><li>若参数为空，则创建一个空列表</li></ul></li><li>tuple([iterable])：将一个可迭代对象转换成元组</li><li><strong>str(obj)：将obj对象转换成字符串</strong></li><li><strong>len(sub)：返回sub参数的长度</strong></li><li>max()：返回序列中的最大值</li><li>min()：返回序列中的最小值</li><li>sum(iterable[,start])：从start为基值，加上序列所有元素和</li><li>sorted(iterable, key=None, reverse=False)：返回一个排序的列表，而内建sort()方法是原地排序</li><li>reversed(sequence)：返回逆序的序列，内建方法是原地翻转<ul><li>也可以使用逆向切片实现：seq[::-1]</li></ul></li><li>enumerate(iterable)：生成一个由二元组构成的可迭代对象，<strong>每个二元组由可迭代的索引号及对应的元素组成</strong></li><li>zip(iter1[,iter2[…]])：返回由各个可迭代参数共同组成的多元组序列</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python分支和循环</title>
      <link href="/2020/01/31/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF/"/>
      <url>/2020/01/31/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="条件控制"><a class="markdownIt-Anchor" href="#条件控制"></a> 条件控制</h1><h2 id="if语句"><a class="markdownIt-Anchor" href="#if语句"></a> if语句</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure><ul><li>elif代替了else if，所以if语句的关键字为：<strong>if–elif–else</strong></li><li>在Python中没有switch–case语句</li></ul><h2 id="if嵌套"><a class="markdownIt-Anchor" href="#if嵌套"></a> if嵌套</h2><p>if中含有if</p><h2 id="断言assert"><a class="markdownIt-Anchor" href="#断言assert"></a> 断言(assert)</h2><p>assert关键字后边条件若为假，则程序崩溃，抛出AssertionError</p><h1 id="循环控制"><a class="markdownIt-Anchor" href="#循环控制"></a> 循环控制</h1><h2 id="while循环"><a class="markdownIt-Anchor" href="#while循环"></a> while循环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件(condition)：</span><br><span class="line">    执行语句(statements)……</span><br></pre></td></tr></table></figure><h3 id="简单语句组"><a class="markdownIt-Anchor" href="#简单语句组"></a> 简单语句组</h3><p>类似if语句的语法，如果你的while循环体中只有一条语句，你可以将该语句与while写在同一行中</p><h2 id="for循环"><a class="markdownIt-Anchor" href="#for循环"></a> for循环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure><h3 id="range函数"><a class="markdownIt-Anchor" href="#range函数"></a> range()函数</h3><p>生成数列，以便于for循环</p><h2 id="breakcontinue和else"><a class="markdownIt-Anchor" href="#breakcontinue和else"></a> break，continue和else</h2><ul><li>break，continue和其他语言基本一致</li><li>循环中的else语句：它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，但循环被 break 终止时不执行</li></ul><h2 id="pass语句"><a class="markdownIt-Anchor" href="#pass语句"></a> pass语句</h2><p>Python pass是空语句，是为了保持程序结构的完整性，pass不做任何事情，一般用做占位语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 等待键盘中断 (Ctrl+C)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识</title>
      <link href="/2020/01/26/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/01/26/%E5%AD%A6%E4%B9%A0/Python%E5%AD%A6%E4%B9%A0/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="常用操作符"><a class="markdownIt-Anchor" href="#常用操作符"></a> 常用操作符</h1><h2 id="算术操作符"><a class="markdownIt-Anchor" href="#算术操作符"></a> 算术操作符</h2><p><strong>+、-、*、/、%、**(乘方)、//(地板除法)</strong></p><ul><li>地板除法(floor)：计算结果取比商小的最大整型值(舍去小数，取整)</li></ul><h2 id="比较操作符"><a class="markdownIt-Anchor" href="#比较操作符"></a> 比较操作符</h2><p><strong>&lt;、&lt;=、&gt;、&gt;=、==、!=</strong></p><ul><li>返回布尔类型值</li></ul><h2 id="逻辑操作符"><a class="markdownIt-Anchor" href="#逻辑操作符"></a> 逻辑操作符</h2><p><strong>and、or、not</strong></p><ul><li>返回布尔类型值</li></ul><h1 id="变量variable"><a class="markdownIt-Anchor" href="#变量variable"></a> 变量(variable)</h1><p><strong>当为一个值起名字的时候，它将会存储在内存中，称为变量(variable)</strong></p><ul><li>Python与大多数计算机语言不同，它并不是把值储存在变量中，而像是把名字&quot;贴&quot;在值上边</li><li>使用变量之前，要先赋值</li></ul><hr><h1 id="字符串string"><a class="markdownIt-Anchor" href="#字符串string"></a> 字符串(string)</h1><p><strong>字符串也称为文本，就是引号内的一切内容</strong></p><ul><li>Python 创建字符串时，可以是单引号或双引号(不能混用)<ul><li>如果字符串内容有引号，要用<strong>转义字符 '\'</strong></li></ul></li><li>如果在数字相加时加上引号，则变成了字符串的连接</li></ul><h2 id="原始字符串"><a class="markdownIt-Anchor" href="#原始字符串"></a> 原始字符串</h2><p><strong>将字符串不通过转义输出，在字符串前面加上一个英文字母’r’即可</strong></p><ul><li><p>例如：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">r"C:\Eason"</span></span><br></pre></td></tr></table></figure></li><li><p>使用字符串时都需要注意：无论是否为原始字符串，都不能以反斜杠作为结尾</p><ul><li>反斜杠放在末尾表示还未结束，换行继续的意思<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'中南大学'</span> \</span><br><span class="line"><span class="string">'我来了'</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="长字符串"><a class="markdownIt-Anchor" href="#长字符串"></a> 长字符串</h2><p>三重引号字符串(&quot;&quot;“内容”&quot;&quot;)即为长字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"""</span></span><br><span class="line"><span class="string">我是中南人</span></span><br><span class="line"><span class="string">哈哈哈哈哈</span></span><br><span class="line"><span class="string">"""</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="标准数据类型"><a class="markdownIt-Anchor" href="#标准数据类型"></a> 标准数据类型</h1><p><strong>Python的变量是没有类型的，但是不代表Python没有数据类型</strong><br>Python3 中有六个标准的数据类型：</p><ul><li><strong>Number(数字)</strong></li><li><strong>String(字符串)</strong></li><li><strong>List(列表)</strong></li><li><strong>Tuple(元组)</strong></li><li><strong>Set(集合)</strong></li><li><strong>Dictionary(字典)</strong></li></ul><p>其中：</p><ul><li><strong>不可变数据：Number、String、Tuple</strong></li><li><strong>可变数据：List、Set、Dictionary</strong></li></ul><h2 id="number数字"><a class="markdownIt-Anchor" href="#number数字"></a> Number(数字)</h2><p><strong>Python3 支持 int、float、bool、complex(复数)。</strong></p><ul><li>在 Python3 里，只有一种整数类型 int，表示为长整型，<strong>默认无限长</strong>，没有 python2 中的Long。</li><li>内置的 <strong>type()</strong> 函数可以查询变量所指的对象类型，<strong>只有一个参数：待确定类型的数据。返回对象类型</strong></li><li><strong>isinstance()</strong> 函数也可以判断，<strong>有两个参数：第一个待确定类型的数据；第二个指定一个数据类型。返回一个布尔值</strong></li><li>isinstance 和 type 的区别在于：<ul><li>type()不会认为子类是一种父类类型。</li><li>isinstance()会认为子类是一种父类类型。</li></ul></li></ul><blockquote><p><em>注意：在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。到 Python3 中，把 True 和 False 定义成关键字了，但它们的值还是 1 和 0，它们可以和数字相加。</em></p></blockquote><h2 id="string字符串"><a class="markdownIt-Anchor" href="#string字符串"></a> String(字符串)</h2><p>之前已简单介绍，此后再详细介绍</p><h2 id="list列表"><a class="markdownIt-Anchor" href="#list列表"></a> List(列表)</h2><p>List 是 Python 中使用最频繁的数据类型。 <strong>列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</strong></p><ul><li>列表是写在 <strong>方括号[]</strong> 之间、用逗号分隔开的元素列表。</li></ul><h2 id="tuple元组"><a class="markdownIt-Anchor" href="#tuple元组"></a> Tuple(元组)</h2><p>tuple与list类似，不同之处在于元组的<strong>元素不能修改</strong>。</p><ul><li>元组写在 <strong>小括号()</strong> 里，元素之间用逗号隔开。</li><li>其实，可以把字符串看作一种特殊的元组。</li></ul><h2 id="set集合"><a class="markdownIt-Anchor" href="#set集合"></a> Set(集合)</h2><p>set 是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。<strong>基本功能是进行<em>成员关系测试</em> 和 <em>删除重复元素</em>。</strong></p><ul><li>可以使用 <strong>大括号{}</strong> 或者 <strong>set()</strong> 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</li></ul><h2 id="dictionary字典"><a class="markdownIt-Anchor" href="#dictionary字典"></a> Dictionary(字典)</h2><p>字典（dictionary）是Python中另一个非常有用的内置数据类型。</p><ul><li>字典是一种映射类型，字典用 <strong>大括号{}</strong> 标识，它是一个无序的  <strong>键(key) : 值(value)</strong> 的集合。</li><li><strong>key不可变且唯一</strong></li><li>与java中的HashMap十分相似</li></ul><hr><h1 id="python数据类型转换"><a class="markdownIt-Anchor" href="#python数据类型转换"></a> Python数据类型转换</h1><p>数据类型的转换，你只需要<strong>将数据类型作为函数名即可</strong>。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>int(x,[base])</td><td>将x转换为一个整数</td></tr><tr><td>float(x)</td><td>将x转换到一个浮点数</td></tr><tr><td>complex(real [,imag])</td><td>创建一个复数</td></tr><tr><td>str(x)</td><td>将对象 x 转换为字符串</td></tr><tr><td>repr(x)</td><td>将对象 x 转换为表达式字符串</td></tr><tr><td>eval(str)</td><td>用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td>tuple(s)</td><td>将序列 s 转换为一个元组</td></tr><tr><td>list(s)</td><td>将序列 s 转换为一个列表</td></tr><tr><td>set(s)</td><td>转换为可变集合</td></tr><tr><td>dict(d)</td><td>创建一个字典。d 必须是一个 (key, value)元组序列。</td></tr><tr><td>frozenset(s)</td><td>转换为不可变集合</td></tr><tr><td>chr(x)</td><td>将一个整数转换为一个字符</td></tr><tr><td>ord(x)</td><td>将一个字符转换为它的整数值</td></tr><tr><td>hex(x)</td><td>将一个整数转换为一个十六进制字符串</td></tr><tr><td>oct(x)</td><td>将一个整数转换为一个八进制字符串</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成概论</title>
      <link href="/2020/01/02/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%BB%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%AE%BA/"/>
      <url>/2020/01/02/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%BB%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统概论"><a class="markdownIt-Anchor" href="#计算机系统概论"></a> 计算机系统概论</h1><ul><li>机器字长<ul><li>CPU一次能处理数据的位数</li><li>与CPU中的<strong>寄存器位数</strong>有关</li></ul></li><li>存储容量：存放二进制信息的总位数<ul><li>主存容量：存储单元个数 X 存储字长</li></ul></li></ul><h1 id="冯诺依曼机的特点"><a class="markdownIt-Anchor" href="#冯诺依曼机的特点"></a> 冯·诺依曼机的特点</h1><ul><li>计算机由运算器、存储器、控制器、输入设备和输出设备五大部件组成</li><li>指令和数据以同等的地位存于存储器，并可按地址寻址</li><li>指令和数据均用二进制表示</li><li>指令由操作码和地址码组成</li><li>指令在存储器内按顺序存放</li><li>机器以运算器为中心</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基本语法</title>
      <link href="/2019/12/27/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/12/27/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li>立即数系统默认为int/double<ul><li>如要赋值一个long，必须要在最后加上L符号表示这是个long类型</li></ul></li><li>数组初始化<blockquote><p>int[] a = new int[]{1,2,3};</p></blockquote></li><li>类型转换<ul><li>低精度可以直接赋给高精度<blockquote><p>byte &lt; short &lt; char &lt; int &lt; long &lt; float &lt; double<br>java中的char是十六位，双字节，因此比short大</p></blockquote></li><li>高精度不能直接赋值给低精度：需要强制类型转换</li><li>不同类型之间的运算结果为<strong>精度最高的类型</strong></li></ul></li><li>基本数据类型和字符串转换<ul><li>String.valueOf(各种基本类型)，返回String对象</li><li>XXX.parseXXX(字符串)，返回的是primitive类型，而不是对象</li></ul></li><li>文档注释：&quot;/**&quot; 开头，&quot;*/&quot;结束</li><li><strong>字符串相加(实为连接)：&quot;+&quot;是Java中唯一重载过的一个字符</strong></li><li>&amp;&amp; 和 || 都是短路运算符，即如果第一个可以判断出表达式的TF，就不再运算后面的内容</li><li>运算符的优先级：<ul><li>点号，括号，分号，逗号</li><li>算术运算符</li><li>移位运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>赋值运算符</li></ul></li><li>Java流程<ul><li>选择：if-else switch-case(会让你判断结果)</li><li>循环：for while do-while break continue</li><li>注意：判断中只能为boolean类型，不能为数值</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO操作</title>
      <link href="/2019/12/27/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%20IO%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/12/27/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%20IO%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="io操作"><a class="markdownIt-Anchor" href="#io操作"></a> IO操作</h1><ul><li><strong>IO：输入输出，站在内存角度</strong></li><li>输入输出，最典型的是文件输入输出<ul><li>文件输入：将已有文件的内容输入内存-&gt;文件读</li><li>文件输出：将内存数据输出到文件-&gt;文件写</li></ul></li><li>IO操作支持的API一般保存在<strong><a href="http://java.io" target="_blank" rel="noopener">java.io</a></strong>包</li></ul><h1 id="file类"><a class="markdownIt-Anchor" href="#file类"></a> File类</h1><ol><li>最常见的构造函数：<ul><li>public File(String pathname)</li></ul></li></ol><ul><li>Windows系统分隔符&quot;\&quot;，但是要用&quot;\\“表示，因为”\&quot;转义字符</li><li>Unix系统分隔符是&quot;/&quot;，但是Windows系统也能使用，所以一般用&quot;/&quot;</li></ul><ol start="2"><li>常用方法：<ul><li>getAbsolutePath()，exists()，isDirectory()，isFile()，length()，delete()……</li><li>没有复制文件(读取，再新建)，移动文件(读取，删除，再新建)的功能</li><li>文件的length用字节表示，删除为永久删除</li></ul></li></ol><h1 id="读写文件"><a class="markdownIt-Anchor" href="#读写文件"></a> 读写文件</h1><ul><li>流(Stream)：就是指像水流一样长长的一串连续的东西。在很多时候，流(Stream)是字节流(Byte Steram)的简称，也就是长长的一串字节。</li></ul><h2 id="读文件"><a class="markdownIt-Anchor" href="#读文件"></a> 读文件</h2><ol><li><strong>InputStream</strong><ol><li><strong>FileInputStream</strong>：字节流，支持类型多，但是对双字节字符支持不佳(不能识别中文)</li><li><strong>BufferedInputStream</strong>(常用)：带缓冲，速度较快，但只能使用read或readLine</li></ol></li><li><strong>Reader</strong><ol><li><strong>FileReader</strong>：字符流，一般支持字符，对双字节字符支持较好(可以识别中文)</li><li><strong>BufferedReader</strong>(常用)：带缓冲，速度较快</li></ol></li></ol><ul><li>readLine：按行读，在网络编程中应用较多，会阻塞</li><li>flush：将缓冲区中的数据立马存入硬盘</li></ul><h2 id="写文件"><a class="markdownIt-Anchor" href="#写文件"></a> 写文件</h2><ol><li><strong>OutputStream</strong><ol><li><strong>FileOutputStream</strong>：字节流，对中文支持尚可</li><li><strong>BufferedOutputStream</strong>：带缓冲，速度较快</li></ol></li><li><strong>Writer</strong><ol><li><strong>FileWriter</strong>：字符流</li><li><strong>BufferedWriter</strong>(常用)：带缓冲，速度较快</li></ol></li><li><strong>PrintStream</strong></li></ol><h2 id="randomaccessfile"><a class="markdownIt-Anchor" href="#randomaccessfile"></a> RandomAccessFile</h2><ul><li>随机访问，在文件随机位置定义一个起始点，从起始点读写，有着各种类型的读写</li><li>在于可以随意在文件中间定义起始点：seek(long pos) 函数</li><li>public RandomAccessFile(String name，String mode) throws FileNotFountException</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ul><li>一般使用BufferedReader，PrintStream</li><li>流使用完后要关闭，关闭最外层流，内层流自动关闭</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程开发</title>
      <link href="/2019/12/27/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
      <url>/2019/12/27/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="认识多线程"><a class="markdownIt-Anchor" href="#认识多线程"></a> 认识多线程</h1><ul><li>进程(process)：操作系统层面，计算机能够“同时”运行的各个应用程序；管理上，每个进程占用独自的内存资源分时间片</li><li>线程(Thread)：应用程序层面，程序能够“同时”运行的各个任务；管理上，各个线程共用进程的内存资源<ul><li>例：一个程序，可以下载文件，同时播放音乐。两个任务分别运行。</li></ul></li></ul><h1 id="开发线程"><a class="markdownIt-Anchor" href="#开发线程"></a> 开发线程</h1><ul><li>关键是<strong>将需要用线程管理的代码（不依赖主程序，可以同时运行的代码），放在线程中</strong>。</li></ul><h2 id="方法1继承-thread-类开发多线程"><a class="markdownIt-Anchor" href="#方法1继承-thread-类开发多线程"></a> 方法1：继承 <em><strong>Thread</strong></em> 类开发多线程</h2><ol><li><p>继承 <strong>java.lang.Thread</strong> 类开发多线程</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure></li><li><p>在这个类重写 <strong>Thread</strong> 类中的<strong>run函数</strong>：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>实例化线程对象，调用其 <strong>start()</strong> 函数启动该线程</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li></ol><h2 id="方法2实现-runnable-接口开发多线程"><a class="markdownIt-Anchor" href="#方法2实现-runnable-接口开发多线程"></a> 方法2：实现 <em><strong>Runnable</strong></em> 接口开发多线程</h2><ol><li><p>编写一个类，实现 <strong>java.lang.Runnable</strong> 接口</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure></li><li><p>在这个类中重写 <strong>java.lang.Runnable</strong> 接口中的函数：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>实例化 <strong>java.lang.Thread</strong> 对象，实例化上面编写的 <strong>Runnable</strong> 实现类，将后者传入 <strong>Thread</strong> 对象的构造函数，调用 <strong>Thread</strong> 对象的 <strong>start()</strong> 函数来启动线程</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Runnable threadJob = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(threadJob);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// new Thread(new MyRunnable()).start();</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="两种方法比较"><a class="markdownIt-Anchor" href="#两种方法比较"></a> 两种方法比较</h2><ol><li>第一种每个对象都是一个线程，而第二种每个对象不是一个线程，必须将其传入Thread对象才能运行</li><li>第一种每个线程都有自己的成员变量，而第二种共享成员变量</li><li>Java不支持多重继承，只能继承一个类，但是可以实现多个接口，第一种方法虽然较简单，但是扩展性没有第二种强</li></ol><h1 id="线程控制"><a class="markdownIt-Anchor" href="#线程控制"></a> 线程控制</h1><ul><li><strong>启动(start)、暂停(suspend)、继续(resume)、停止(stop)，销毁(destroy)</strong></li><li>Thread的suspend(暂停)，resume(继续)虽然可以使用，但是由于有死锁危险，被废弃。因为线程暂停时，并不释放线程所拥有的资源。<ul><li>解决方法：建议让<strong>线程暂停，等价于让线程结束运行</strong>。因为结束运行会释放资源；线程结束运行的标志：run函数运行完毕。线程继续相当于新开一个线程，在原来线程基础上运行。所以线程暂停时，要注意保护现场。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常处理</title>
      <link href="/2019/12/27/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2019/12/27/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="认识异常"><a class="markdownIt-Anchor" href="#认识异常"></a> 认识异常</h1><ul><li>java.lang.Exception</li><li>程序出现异常，有什么危害？<ol><li>异常退出，错误提示</li><li>程序在出现异常之后，后面的代码将不会执行</li></ol></li></ul><h1 id="解决异常"><a class="markdownIt-Anchor" href="#解决异常"></a> 解决异常</h1><ol><li>预见所有异常可能，进行约束。很难做到</li><li>一网打尽  try-catch-finally<ul><li>用try块来管理可能出现异常的代码</li><li>用catch块处理某种异常</li><li>用finally块包起来不管异常与否都要运行的代码，保证程序安全性</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 不管异常与否都要运行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>try至少接一个catch或finally，而且两个之间不能有代码</li><li>catch能有多个(从小到大排序)，但finally至多一个</li><li>只有try-finally必须throws异常</li><li>try中异常后的代码不执行</li><li>finally最大的特点是：即使在try中跳出了代码块，甚至return跳出了函数，finally内的代码仍然能运行</li></ul><h1 id="抛出异常"><a class="markdownIt-Anchor" href="#抛出异常"></a> 抛出异常</h1><ul><li><strong>throw：在函数中抛出一个异常对象</strong></li><li><strong>throws：标注该函数可能会抛出某种异常</strong></li><li>一般情况下，标注了throws的函数，调用时一定要用try-catch处理异常或者再次抛出(直至到JVM，它也不会处理，出现异常的话只好死给你看)</li><li>RuntimeException在编译时不会报错，但是在运行时会出错，相当于main函数抛出异常</li><li>自定义异常：extends Exception即可</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用API</title>
      <link href="/2019/12/27/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%E5%B8%B8%E7%94%A8API/"/>
      <url>/2019/12/27/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%E5%B8%B8%E7%94%A8API/</url>
      
        <content type="html"><![CDATA[<p>API：Application Programming Interface，Java内置的一些类及其功能</p><h1 id="javalang"><a class="markdownIt-Anchor" href="#javalang"></a> java.lang</h1><ul><li>Java语言核心包，包含了Java编程最基本的支持类</li><li>java.lang默认被任何程序import，使用里面的类，不需要导入。其他包必须导入才能使用</li><li>包括：Object，Math，String，StringBuffer，StringBuilder，基本数据类型包装类，System</li></ul><h2 id="math"><a class="markdownIt-Anchor" href="#math"></a> Math</h2><ul><li>负责数值运算</li><li>一般采用<strong><a href="http://Math.Xxx" target="_blank" rel="noopener">Math.Xxx</a></strong>调用</li><li>例：在一个100个元素的1维数组（默认值为0）中，随机将50个值赋为1<ul><li>思路：先用一个ArrayList保存1－100的元素值。每次从中随机取出一个值，并将其赋给数组的一个元素。然后从ArrayList中删除这个值</li></ul></li></ul><h2 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h2><ul><li>负责字符串处理</li><li>不可变，采用池机制，任何一个新字符串都会被新建空间存放，因此循环中用String会大大影响程序性能</li><li>调用replace这种函数时，原字符串不变，会返回一个新的字符串</li></ul><h2 id="stringbuffer和stringbuilder"><a class="markdownIt-Anchor" href="#stringbuffer和stringbuilder"></a> StringBuffer和StringBuilder</h2><ul><li>两者都是可变的字符串</li><li>StringBuffer：可变，效率低，线程安全</li><li>StringBuilder：可变，效率高，线程不安全<ul><li>如果要操作少量的数据用String</li><li>多线程操作字符串缓冲区下操作大量数据StringBuffer</li><li>单线程操作字符串缓冲区下操作大量数据StringBuilder。</li></ul></li></ul><h2 id="基本数据类型包装类"><a class="markdownIt-Anchor" href="#基本数据类型包装类"></a> 基本数据类型包装类</h2><h3 id="包装类"><a class="markdownIt-Anchor" href="#包装类"></a> 包装类</h3><ul><li>Java是面向对象的语言，但是基本类型，如int，short，float，double等并没有遵循面向对象；Java中为它们各自设计一个包装类</li><li>boolean——Boolean，byte——Byte，short——Short，char——Character，<strong>int——Integer</strong>，long——Long，float——Float，double——Double</li><li>作用<ol><li>将各种数据用对象包装，便于管理</li><li>便于和字符串之间相互转换<ul><li>String.valueOf(各种类型)</li><li>Xxx.parseXxx(字符串)</li></ul></li></ol></li></ul><h2 id="system"><a class="markdownIt-Anchor" href="#system"></a> System</h2><ol><li>显示时间：System.currentTimeMillis()<ul><li>看程序运行多长时间</li></ul></li><li>终止程序：System.exit(int status)</li><li>强制垃圾收集：System.gc()</li></ol><h1 id="javautil"><a class="markdownIt-Anchor" href="#javautil"></a> java.util</h1><h2 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h2><h3 id="collection"><a class="markdownIt-Anchor" href="#collection"></a> Collection</h3><ol><li><strong>List接口：有顺序,下标访问，可重复，一维变长</strong><ol><li>ArrayList：底层数组存储，线程不安全</li><li>LinkedList：底层链表存储，线程不安全</li><li>Vector：底层数组存储，线程安全</li></ol><ul><li>功能基本相同：增删改查</li></ul></li><li><strong>Set接口：无下标，不可重复(唯一)，一维变长</strong><ol><li>HashSet：普通的set，保存元素，乱序</li><li>LinkedHashSet：顺序按照元素添加顺序</li><li>TreeSet：自动排序(自然/比较器排序)</li></ol></li></ol><h3 id="collections类"><a class="markdownIt-Anchor" href="#collections类"></a> Collections类</h3><ul><li>Collection<strong>s</strong>是类，不是接口</li><li>为集合提供处理功能的工具类</li><li>sort，frequency，disjoint，max/min，replaceAll……</li></ul><h3 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h3><ul><li><strong>&lt;Key,Value&gt;，key不可重复，每个key对应一个value(类似于映射)</strong></li></ul><ol><li>HashMap：普通map，乱序</li><li>LinkedHashMap：按添加顺序排序</li><li>TreeMap：按Key排序，(自然/比较器排序)</li><li>Hashtable(线程同步)，Properties：具有更多功能</li></ol><h3 id="遍历方法"><a class="markdownIt-Anchor" href="#遍历方法"></a> 遍历方法</h3><ol><li>List：下标访问，可以用普通for或高级for遍历</li><li>Set：无下标<ol><li>利用迭代器进行，迭代遍历</li><li>高级for</li><li>foreach</li></ol></li><li>Map：无下标<ol><li>在for循环中使用entries实现Map的遍历</li><li>在for循环中遍历key或者values，一般适用于只需要map中的key或者value时使用，在性能上比使用entrySet较好</li><li>通过Iterator遍历</li><li>通过键找值遍历，这种方式的效率比较低，因为本身从键取值是耗时的操作</li></ol></li></ol><h2 id="日期操作"><a class="markdownIt-Anchor" href="#日期操作"></a> 日期操作</h2><ol><li>Date</li><li>Calendar</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java网络编程</title>
      <link href="/2019/12/27/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/12/27/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="ip和port"><a class="markdownIt-Anchor" href="#ip和port"></a> IP和Port</h1><ol><li>如何定位到某台电脑？<ul><li><strong>IP地址</strong></li><li>IPV4：32位，分割成4个&quot;8位二进制数&quot;，2019.11.26耗尽</li><li>IPV6：128位</li></ul></li><li>确定IP后，如何确定特定的网络应用程序？<ul><li><strong>端口(Port)</strong></li><li>0~65535，其中0~1024被占用(HTTP:80)</li></ul></li></ol><ul><li>IP确定电脑地址，Port确定应用程序，实现计算机之间的相互通讯</li></ul><h1 id="tcp和udp"><a class="markdownIt-Anchor" href="#tcp和udp"></a> TCP和UDP</h1><ul><li>TCP(Transmission Control Protocol)<ul><li>基于连接，只有C/S两端连接上才能通信</li><li>打电话</li></ul></li><li>UDP(User Datagram Protocol)<ul><li>基于报文，只传送信息，并不保证信息传送一定成功，性能好</li><li>写信</li></ul></li></ul><h1 id="cs模式"><a class="markdownIt-Anchor" href="#cs模式"></a> C/S模式</h1><ul><li>Client/Server模式</li><li>客户端的通信通过服务器的转发</li><li>过程：<ol><li>服务器启动（确定端口）</li><li>客户端连到服务器（根据服务器IP和端口）</li><li>客户端发信息给服务器</li><li>服务器发信息给另一个客户端</li></ol></li></ul><h1 id="javanet包"><a class="markdownIt-Anchor" href="#javanet包"></a> java.net包</h1><ul><li>ServerSocket：开启服务器，指定端口，接受客户端连接。<ul><li>accept()：阻塞函数(死等函数)</li></ul></li><li>Socket：套接字。负责实际的通信连接，以及发送接收信息。<ul><li>getOutputStream，getIntputStream，老师推荐使用：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream())</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> IntputStreamReader(socket.getIntputStream()))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java界面和事件</title>
      <link href="/2019/12/27/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%E7%95%8C%E9%9D%A2%E5%92%8C%E4%BA%8B%E4%BB%B6/"/>
      <url>/2019/12/27/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%E7%95%8C%E9%9D%A2%E5%92%8C%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="gui"><a class="markdownIt-Anchor" href="#gui"></a> GUI</h1><p>GUI(Graphics User Interface)：图形用户界面</p><h2 id="swing"><a class="markdownIt-Anchor" href="#swing"></a> Swing</h2><ul><li>用于开发GUI程序，有三大要素：窗口(Window)，控件(Component)，渲染</li></ul><h3 id="窗口"><a class="markdownIt-Anchor" href="#窗口"></a> 窗口</h3><ol><li>javax.swing.JFrame:普通窗口</li><li>javax.swing.JWindow：无标题栏的窗口</li><li>javax.swing.JDialog：窗口间调用时的对话框</li></ol><h3 id="控件"><a class="markdownIt-Anchor" href="#控件"></a> 控件</h3><ul><li><p>常见以下控件：</p><ol><li>按钮(JButton)</li><li>标签(JLabel)</li><li>文本框(JTextField)</li><li>多行文本框(JTextArea)</li><li>密码框(JPasswordField)</li><li>单选按钮(JRadioButton)</li><li>下拉列表框(JComboBox)：addItem</li><li>复选框(JCheckBox)</li><li>菜单：JMenuBar，JMenu，JMenuItem</li></ol></li><li><p>为了更好的组织界面，通常：<strong>先将控件添加到面板(JPanel)上，再添加到窗口上</strong></p></li><li><p>JPanel上的控件，<strong>默认FlowLayout布局</strong>：系统确定的大小，从左到右，从上到下按照顺序布局，不可更改。</p></li><li><p>如果要自由地安排布局，一般将JPanel的布局方式设置为null，通过setSize设置控件大小，setLocation设置控件位置。</p></li></ul><h3 id="渲染"><a class="markdownIt-Anchor" href="#渲染"></a> 渲染</h3><ul><li>颜色(Color)，字体(Font)，图标(Icon)……</li><li>所有控件都可以设置背景颜色和前景颜色(字的颜色)：<ul><li>setBackground(Color c)</li><li>setForeground(Color c)</li><li>颜色用java.awt.Color来表示</li></ul></li><li>所有含文字的控件都可以设置字体；<ul><li>setFont(Font f)</li><li>字体用java.awt.Font来表示</li></ul></li></ul><h3 id="layout"><a class="markdownIt-Anchor" href="#layout"></a> Layout</h3><ol><li>FlowLayout：流式布局，JPanel默认布局<ul><li>从左到右，从上到下</li></ul></li><li>GridLayout：网格布局<ul><li>将界面划分成相等大小的块</li></ul></li><li>BorderLayout：边界布局<ul><li>分成东南西北中，每个方向最多放一个组件</li></ul></li><li>null：空布局</li></ol><h1 id="事件处理"><a class="markdownIt-Anchor" href="#事件处理"></a> 事件处理</h1><h2 id="方式"><a class="markdownIt-Anchor" href="#方式"></a> 方式</h2><ul><li>事件(Event)是指用户为了交互而产生的键盘和鼠标动作<ul><li>上面定义不严谨，程序出现异常，也可以被认为是一个事件</li><li>事件是一个对象</li></ul></li><li>事件的处理者(Listener)必须有监听的能力</li><li>通常三步走：<strong>长耳朵，绑定，监听</strong><ol><li>编写一个类，implements相应的Listener，实现事件的响应（长耳朵）</li><li>将需要监听的控件和这个类的对象绑定（告诉它你要监听事件）</li><li>控件开始监听，一旦有该种事件发生，会实现事件的相应</li></ol></li></ul><h2 id="常见event-listener"><a class="markdownIt-Anchor" href="#常见event-listener"></a> 常见Event-Listener</h2><ul><li>Event和Listener都在java.awt.event包</li></ul><ol><li><em><strong>ActionListener-ActionEvent</strong></em>：鼠标点击控件，文本框中回车</li><li><strong>KeyListener-KeyEvent</strong>：操作键盘发生的事件</li><li><strong>MouseListener-MouseEvent</strong>：通用的操作鼠标发生的事件；画图软件</li><li><em>MouseMotionListener-MouseEvent</em>：鼠标拖动或移动事件</li><li>FocusListener-FocusEvent：控件得到聚焦</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象</title>
      <link href="/2019/12/27/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/12/27/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><ul><li>面向对象的三大特征：<ul><li><strong>封装(Encapsulation)</strong></li><li><strong>继承(Inheritance)</strong></li><li><strong>多态(Polymorphism)</strong></li></ul></li><li>面向对象(Object Oriented)是一个编程思想：将事件看成事件(过程)的集合还是物体(对象)的集合</li><li>类是对象的抽象</li><li>对象是类的实例</li><li>对象拥有两类内容：<ul><li>成员变量：属性(Property, Member Variable, Field)</li><li>成员函数(方法)：功能(Member Function, Method)</li></ul></li><li>对象的引用性质：<strong>Java中的对象名只是一个引用(指针)，或者是一个遥控器，并不代表其实际占据内存，只有通过&quot;.&quot;号才能访问到其真实内存中的数据</strong></li></ul><h1 id="成员变量和成员函数"><a class="markdownIt-Anchor" href="#成员变量和成员函数"></a> 成员变量和成员函数</h1><h2 id="成员函数"><a class="markdownIt-Anchor" href="#成员函数"></a> 成员函数</h2><ul><li>目的：复用代码</li></ul><h3 id="参数传递方式"><a class="markdownIt-Anchor" href="#参数传递方式"></a> 参数传递方式：</h3><ol><li><strong>简单数据类型</strong>采用<strong>值传递</strong><ul><li>primitive类型</li></ul></li><li><strong>引用数据类型</strong>采用<strong>引用传递</strong><ul><li>对象的引用，数组</li></ul></li></ol><h3 id="函数重载overload"><a class="markdownIt-Anchor" href="#函数重载overload"></a> 函数重载(Overload)</h3><ul><li>允许多个函数名字相同，但是要满足要求<ol><li>参数个数不同</li><li>个数相同，类型不同</li><li>个数相同，类型相同，但是不同类型的参数出现的顺序不同</li></ol><ul><li><em>函数的返回值不能作为重载的条件</em></li><li>函数重载也叫静态多态(Static Polymorphism)</li></ul></li></ul><h3 id="构造函数constructor"><a class="markdownIt-Anchor" href="#构造函数constructor"></a> 构造函数(Constructor)</h3><ul><li>构造函数也是一种函数，为了强制对象初始化，但必须满足：<ol><li>函数名与类相同</li><li>不含返回类型(并不是void)</li></ol></li><li>特点：<ol><li>对象实例化时自动调用一次</li><li>可以被重载</li><li>如果一个类没有定义任何构造函数，系统自动为其分配一个空的，不带参数的默认构造函数，如果定义了构造函数，默认构造函数自动失效(不会自动创建)</li></ol></li></ul><h3 id="析构函数destructor"><a class="markdownIt-Anchor" href="#析构函数destructor"></a> 析构函数(Destructor)</h3><ul><li>对象结束其生命周期时或者该对象没有被引用，系统会执行析构函数</li><li>在java中，对象的内存在哪个时刻回收，取决于垃圾回收器何时运行</li></ul><h1 id="静态变量和静态函数"><a class="markdownIt-Anchor" href="#静态变量和静态函数"></a> 静态变量和静态函数</h1><h2 id="静态变量"><a class="markdownIt-Anchor" href="#静态变量"></a> 静态变量</h2><ul><li>默认情况下，各个成员都有自己独有的成员变量，占据不同内存。</li><li>而<strong>静态变量是该类所有对象公用的变量</strong></li><li>访问方式：“对象名.变量名”，“<strong>类名.变量名</strong>”(推荐)</li></ul><h2 id="静态函数"><a class="markdownIt-Anchor" href="#静态函数"></a> 静态函数</h2><ul><li><strong>静态函数只能访问静态变量，不能访问类中的普通成员变量。</strong></li><li>建议用“<strong>类名.函数名</strong>”访问。</li><li>作用：一般情况下可以用来执行一些不隶属于任何一个特定对象的公共的工作。</li></ul><h1 id="封装encapsulation"><a class="markdownIt-Anchor" href="#封装encapsulation"></a> 封装(Encapsulation)</h1><ul><li>隐藏对象的属性和实现细节，仅对外公开接口</li></ul><h2 id="最大层面的封装包"><a class="markdownIt-Anchor" href="#最大层面的封装包"></a> 最大层面的封装：包</h2><ul><li>用包来管理类</li></ul><ol><li>如何把类放入包中<br>在文件头声明类所在的包：<strong>package 包名</strong>;<ul><li>Java中，包名一般名词，首字母小写；</li><li>如果包中还含有包，用.号隔开</li></ul></li><li>如何使用包中的类<ol><li>同一个包中的类直接使用</li><li>不同包中的类不能直接使用，需以下操作：<ul><li>import 另一个包中的类<ul><li>import 类路径;</li><li>import 包路径.*; 表示导入包中所有类（不含子包中的类）</li></ul></li><li>被使用的类是一个public类<ul><li><strong>public类对包外可见，非public类只能在包内可见</strong>；public-类的类名必须与所在文件名相同</li><li>一个文件中，最多只能有一个public类</li></ul></li></ul></li></ol></li></ol><h2 id="细节层面的封装访问区分符"><a class="markdownIt-Anchor" href="#细节层面的封装访问区分符"></a> 细节层面的封装：访问区分符</h2><ul><li><p>有些成员不适合其他类直接调用，这不安全。用访问区分符来管理成员的访问权限</p></li><li><p>在成员定义前面加上访问区分符：public，protected，default，private</p></li><li><p>访问权限如下：</p><table><thead><tr><th>访问权限</th><th>本类</th><th>同包类</th><th>外包子类</th><th>外包类</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table></li><li><p>以上访问区分符适合成员变量和函数</p></li><li><p>default是一种包访问，外包不能访问</p></li><li><p>一般情况下，成员变量定义为私有(private),成员函数定义为公有(public)，<strong>如果涉及到继承，可以将成员定义为保护型</strong></p></li><li><p>如果需要读取成员变量或者修改成员变量怎么做：</p><ul><li>setXXX函数和getXXX函数</li><li>也叫做setter和getter函数</li></ul></li></ul><h1 id="继承inheritance"><a class="markdownIt-Anchor" href="#继承inheritance"></a> 继承(Inheritance)</h1><h2 id="概念-2"><a class="markdownIt-Anchor" href="#概念-2"></a> 概念</h2><ol><li>原因：通过继承，降低代码量，提高可维护性；定义共同协议</li><li>实现方式：extends关键字</li><li>性质：<ul><li>不允许多重继承，一个类只能extends一次</li><li>所有的成员都可以被继承，但是要考虑访问区分符：<ul><li><strong>父类的private成员不能被继承</strong></li><li><strong>父类的default成员，不能被包外子类继承</strong></li><li>成员变量可以被继承，作为子类的成员变量直接使用（属性）</li><li>成员函数可以被继承，作为子类的成员函数直接使用（功能）</li></ul></li></ul></li><li>本质：实例化子类对象时，系统会首先实例化父类对象<ul><li>如果父类没有默认构造函数，子类必须用<strong>super()显式调用</strong>(必须写在<strong>第一行</strong>)</li><li>调用本类的其他构造函数this()也必须写在第一行，且不能与super()同时使用，因为this()中也会调用super()，使父类对象构造的两次</li></ul></li></ol><h2 id="成员的覆盖override"><a class="markdownIt-Anchor" href="#成员的覆盖override"></a> 成员的覆盖(Override)</h2><ul><li><p>子类中重定义父类的成员，方法(参数一致，返回类型兼容)</p></li><li><p>覆盖是表现多态特性的具体做法</p></li><li><p>子类对象调用成员时，自动调用子类成员，父类成员不被调用。一定要调用父类成员，可以用super关键字。</p></li><li><p><strong>super</strong>和<strong>this</strong>是相对的两个关键词，一个指代父类；一个指代自己</p><table><thead><tr><th>使用</th><th>执行</th></tr></thead><tbody><tr><td>super.</td><td>调用父类的成员</td></tr><tr><td>super(参数列表)</td><td>调用父类构造函数</td></tr><tr><td>this.</td><td>调用本类中成员</td></tr><tr><td>this(参数列表)</td><td>调用本类中另一个构造函数</td></tr></tbody></table></li><li><p><strong>覆盖不允许缩小访问权限</strong></p></li><li><p>Java中有一个类：Object类，是所有成员的父类</p><ul><li>常见方法：equals(Object obj)，toString()</li></ul></li></ul><h1 id="多态polymorphism"><a class="markdownIt-Anchor" href="#多态polymorphism"></a> 多态(Polymorphism)</h1><h2 id="概念-3"><a class="markdownIt-Anchor" href="#概念-3"></a> 概念</h2><ul><li>多种形态：某个东西，在不同情况下呈现出不同形态</li><li>动态多态的理论基础是：父类引用可以指向子类对象。</li><li><strong>当父类引用调用被覆盖的成员时，调用的是子类成员</strong>，从子类向上找</li><li>作用：<ol><li>函数形参为父类类型，实参为子类对象</li><li>函数返回类型是父类类型，函数中实际返回子类对象</li></ol></li></ul><h2 id="父类和子类的类型转换"><a class="markdownIt-Anchor" href="#父类和子类的类型转换"></a> 父类和子类的类型转换</h2><ol><li>子类转化为父类<ul><li>可以直接赋值</li></ul></li><li>父类转化为父类<ul><li>严格来说，无法转换</li><li>特殊情况：该父类原本是子类的对象，使用强制类型转换</li></ul></li></ol><ul><li>“对象名 <strong>instanceof</strong> 类名” 可以判断对象类型</li></ul><h2 id="抽象abstract"><a class="markdownIt-Anchor" href="#抽象abstract"></a> 抽象(abstract)</h2><ul><li>抽象函数：将函数体去掉，定义为抽象函数<ul><li>特点：必须在子类中被重写，否则报错，除非子类也是抽象类</li></ul></li><li><strong>含有抽象函数的类叫抽象类，必须用abstract修饰</strong></li><li>特点：<ol><li>抽象类必须用abstract修饰，抽象类不能被实例化，只能被继承</li><li>抽象类中含有抽象函数（包括继承的，也可以不含有），也可以含有普通函数（便于子类调用）</li><li>抽象函数必须在子类中被重写(<strong>注意权限不能缩小</strong>)，否则报错，除非子类也是抽象类</li></ol></li><li>抽象类中不一定都是抽象函数，但是含抽象函数的类一定是抽象类</li><li>抽象类不能被实例化，但是它有构造函数(因为子类中会使用super()调用父类构造函数)</li></ul><h2 id="接口interface"><a class="markdownIt-Anchor" href="#接口interface"></a> 接口(interface)</h2><ul><li>特点：<ol><li>全部是<strong>public抽象函数</strong>，默认public，abstract(可省略)<ul><li>因此实现接口的类中<strong>重写方法必须是public</strong>，因为权限不能缩小</li></ul></li><li>接口中定义的“变量”只能是<strong>静态public常量</strong>，系统默认使用public，static，final修饰，可以省略</li><li>一个类继承抽象类–&gt;实现（<strong>implements</strong>）接口</li><li><strong>一个类继承一个父类同时实现多个接口</strong></li></ol></li></ul><h2 id="抽象类和接口的区别"><a class="markdownIt-Anchor" href="#抽象类和接口的区别"></a> 抽象类和接口的区别</h2><table><thead><tr><th>参数</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>方法</td><td>可以有正常方法</td><td>只有抽象方法</td></tr><tr><td>实现</td><td>extends</td><td>implements</td></tr><tr><td>构造</td><td>可以有</td><td>不能有</td></tr><tr><td>正常类</td><td>只有不能实例化</td><td>完全不同类型</td></tr><tr><td>修饰符</td><td>public、protected和default</td><td>默认修饰符是public，不能使用其他</td></tr><tr><td>main</td><td>可以有main且可以运行</td><td>不能有</td></tr></tbody></table><ul><li><strong>接口可以extends接口，但不能implements接口，不能extends类</strong></li><li><strong>抽象类可以implements接口，也可以extends实体类(<em>这个类必须有明确的构造函数</em>)，因为抽象类也可以有实体函数</strong></li></ul><h2 id="final关键字"><a class="markdownIt-Anchor" href="#final关键字"></a> final关键字</h2><ol><li>修饰类：不能被继承</li><li>修饰函数：不能被重写</li><li>修饰成员变量：不能被改变(哪怕是同一个值)，用来定义常量</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储器</title>
      <link href="/2019/12/26/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%BB%84/%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2019/12/26/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%BB%84/%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><h2 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h2><ol><li>按存储介质分类<ol><li>半导体存储器：TTL，MOS(易失)</li><li>磁表面存储器</li><li>磁芯存储器</li><li>光盘存储器</li></ol></li><li>按照存取方式<ol><li>RAM(Random Access Memory)</li><li>ROM(Read Only Memory)</li><li>串行访问存储器</li></ol></li><li>按在计算机中的作用分类<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191216180240.png" class="lazyload"></li></ol><h2 id="层次结构"><a class="markdownIt-Anchor" href="#层次结构"></a> 层次结构</h2><ol><li>存储器三个主要特性的关系<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191216181028.png" class="lazyload"></li><li>缓存-主存层次和主存-辅存层次<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191216181224.png" class="lazyload"></li></ol><h1 id="主存储器"><a class="markdownIt-Anchor" href="#主存储器"></a> 主存储器</h1><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191216181356.png" class="lazyload"></p><ul><li>编址单位：字节</li><li>技术指标：<ol><li>容量：主存<strong>存放二进制代码的总位数</strong></li><li>速度：<ul><li>存取时间：存储器的<strong>访问时间</strong></li><li>存取周期：连续两次独立的存储器操作所需的<strong>最小间隔时间</strong>，比存取时间长，差个复原时间</li></ul></li><li>带宽：<strong>位/秒(bit/s)</strong></li></ol></li></ul><h2 id="半导体存储芯片"><a class="markdownIt-Anchor" href="#半导体存储芯片"></a> 半导体存储芯片</h2><ul><li>容量：<strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi mathvariant="normal">地</mi><mi mathvariant="normal">址</mi><mi mathvariant="normal">线</mi></mrow></msup><mo>×</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">线</mi></mrow><annotation encoding="application/x-tex">2^{地址线} \times 数据线</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.363em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">地</span><span class="mord cjk_fallback mtight">址</span><span class="mord cjk_fallback mtight">线</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">线</span></span></span></span></strong></li><li>译码驱动方式:<ul><li>线选法</li><li>重合法</li></ul></li></ul><h2 id="ram"><a class="markdownIt-Anchor" href="#ram"></a> RAM</h2><ol><li>静态RAM(SRAM)</li><li>动态RAM(DRAM)<ul><li><strong>2ms(刷新周期)</strong> 内再生(刷新)，<strong>一行行进行</strong></li><li>刷新方式：<ol><li>集中刷新(有死区)</li><li>分散刷新(无死区)</li><li>异步刷新(两者结合)：刷新安排在指令译码阶段，不会出现死区</li></ol></li></ul></li></ol><h2 id="rom"><a class="markdownIt-Anchor" href="#rom"></a> ROM</h2><ol><li>掩膜ROM：不能修改</li><li>PROM(一次性编程)</li><li>EPROM(多次性编程)</li><li>EEPROM(电可擦除)</li><li>Flash Memory(闪速型存储器)</li></ol><h1 id="存储器与cpu的连接"><a class="markdownIt-Anchor" href="#存储器与cpu的连接"></a> 存储器与CPU的连接</h1><ol><li>存储器容量的扩展<ol><li>位扩展(增加存储字长)</li><li>字扩展(增加存储字的数量)</li><li>字、位扩展</li></ol></li><li>存储器与CPU的连接<ol><li>地址线的连接<ul><li>低位接存储芯片，高位作片选信号</li></ul></li><li>数据线的连接</li><li>读/写命令线的连接</li><li>片选线的连接</li><li>合理选择存储芯片</li><li>其他：时序，负载</li></ol></li></ol><ul><li>做题步骤：<ol><li>写出对应二进制地址码</li><li>确定芯片的数量及类型<ul><li>优先位扩展：字扩展要设计片选型号，而位扩展只需将数据线引出即可</li><li>RAM，ROM尽量选择外特性一致，简化连接，避免二级译码</li></ul></li><li>分配地址线</li><li>确定片选信号</li></ol></li></ul><h1 id="存储器的校验"><a class="markdownIt-Anchor" href="#存储器的校验"></a> 存储器的校验</h1><ol><li>编码的最小距离：任意两组合法代码之间的二进制位数的<strong>最少差异数</strong><ul><li>L - 1 = D + C</li><li>L：最小距离；D：检错位数；C：纠错位数</li><li><strong>汉明码是具有一位纠错能力的编码</strong></li></ul></li><li>汉明码的组成三要素<ol><li>添加k位校验位：<strong>2^k ≥ n+k+1</strong> [传输n位，分成k组]</li><li>检测位的位置：<strong>2^i</strong> (i=0,1,……) [这一位不与其他组共用]<ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub><mi mathvariant="normal">检</mi><mi mathvariant="normal">测</mi><mi mathvariant="normal">的</mi><msub><mi>g</mi><mn>1</mn></msub><mi mathvariant="normal">：</mi><mn>1</mn><mi mathvariant="normal">，</mi><mn>3</mn><mi mathvariant="normal">，</mi><mn>5</mn><mi mathvariant="normal">，</mi><mn>7</mn><mi mathvariant="normal">，</mi><mn>9</mn><mo>…</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">C_{1}检测的g_{1}：1，3，5，7，9……</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">检</span><span class="mord cjk_fallback">测</span><span class="mord cjk_fallback">的</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">：</span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord">3</span><span class="mord cjk_fallback">，</span><span class="mord">5</span><span class="mord cjk_fallback">，</span><span class="mord">7</span><span class="mord cjk_fallback">，</span><span class="mord">9</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub><mi mathvariant="normal">检</mi><mi mathvariant="normal">测</mi><mi mathvariant="normal">的</mi><msub><mi>g</mi><mn>2</mn></msub><mi mathvariant="normal">：</mi><mn>2</mn><mi mathvariant="normal">，</mi><mn>3</mn><mi mathvariant="normal">，</mi><mn>6</mn><mi mathvariant="normal">，</mi><mn>7</mn><mi mathvariant="normal">，</mi><mn>10</mn><mo>…</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">C_{2}检测的g_{2}：2，3，6，7，10……</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">检</span><span class="mord cjk_fallback">测</span><span class="mord cjk_fallback">的</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">：</span><span class="mord">2</span><span class="mord cjk_fallback">，</span><span class="mord">3</span><span class="mord cjk_fallback">，</span><span class="mord">6</span><span class="mord cjk_fallback">，</span><span class="mord">7</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>4</mn></msub><mi mathvariant="normal">检</mi><mi mathvariant="normal">测</mi><mi mathvariant="normal">的</mi><msub><mi>g</mi><mn>3</mn></msub><mi mathvariant="normal">：</mi><mn>4</mn><mi mathvariant="normal">，</mi><mn>5</mn><mi mathvariant="normal">，</mi><mn>6</mn><mi mathvariant="normal">，</mi><mn>7</mn><mi mathvariant="normal">，</mi><mn>12</mn><mo>…</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">C_{4}检测的g_{3}：4，5，6，7，12……</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">检</span><span class="mord cjk_fallback">测</span><span class="mord cjk_fallback">的</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">：</span><span class="mord">4</span><span class="mord cjk_fallback">，</span><span class="mord">5</span><span class="mord cjk_fallback">，</span><span class="mord">6</span><span class="mord cjk_fallback">，</span><span class="mord">7</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>8</mn></msub><mi mathvariant="normal">检</mi><mi mathvariant="normal">测</mi><mi mathvariant="normal">的</mi><msub><mi>g</mi><mn>4</mn></msub><mi mathvariant="normal">：</mi><mn>8</mn><mi mathvariant="normal">，</mi><mn>9</mn><mi mathvariant="normal">，</mi><mn>10</mn><mi mathvariant="normal">，</mi><mn>11</mn><mi mathvariant="normal">，</mi><mn>12</mn><mo>…</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">C_{8}检测的g_{4}：8，9，10，11，12……</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">检</span><span class="mord cjk_fallback">测</span><span class="mord cjk_fallback">的</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">：</span><span class="mord">8</span><span class="mord cjk_fallback">，</span><span class="mord">9</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></li></ul></li><li>检测位的取值：所在小组中承担的<strong>奇偶校验任务</strong>有关</li></ol></li><li>汉明码纠错过程<br>形成新的检测位P[i]，和该组中1个数有关(奇偶校验决定，一般为偶校验)</li></ol><h1 id="提高访问速度的措施"><a class="markdownIt-Anchor" href="#提高访问速度的措施"></a> 提高访问速度的措施</h1><ul><li>采用高速器件</li><li>采用层次结构 Cache-主存</li><li>调整主存结构<ol><li>单体多字：增加存储器的带宽</li><li>多体并行<ol><li>高位交叉：<strong>顺序编址</strong>，各个体<strong>并行工作</strong>(适合存储器扩展，但不适合增加带宽)</li><li>低位交叉：各个体<strong>轮流编制</strong>，<strong>在不改变存取周期的前提下，增加存储器的带宽</strong>(流水线方式)</li></ol></li><li>高性能存储芯片<ol><li>SDRAM(同步RAM)</li><li>RDRAM</li><li>带Cache的DRAM<ul><li>集成了一个Cache，有利于猝发式读取</li></ul></li></ol></li></ol></li></ul><h1 id="高速缓冲存储器"><a class="markdownIt-Anchor" href="#高速缓冲存储器"></a> 高速缓冲存储器</h1><h2 id="概述-2"><a class="markdownIt-Anchor" href="#概述-2"></a> 概述</h2><p>避免CPU&quot;空等&quot;，<strong>程序访问局部性原理</strong></p><h3 id="cache工作原理"><a class="markdownIt-Anchor" href="#cache工作原理"></a> Cache工作原理</h3><ol><li>主存和缓存的编址<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191217163036.png" class="lazyload"><ul><li>主存和缓存<strong>按块存储</strong>，<strong>块大小相等</strong>，B为块长</li></ul></li><li>命中和未命中<br>缓存有C块，主存有M块，M &gt;&gt; C<ul><li>命中：主存块调入缓存，建立了对应关系</li><li>用<strong>标记</strong>记录与某缓存块建立了对应关系的<strong>主存块号</strong></li></ul></li><li>Cache命中率：CPU欲访问的信息再Cache中的比率<ul><li>与Cache的<strong>容量</strong>和<strong>块长</strong>有关</li><li>块长取一个存取周期内从主存调出的信息长度</li></ul></li><li>Cache-主存系统的效率<ul><li>效率e与命中率有关<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191217164120.png" class="lazyload"><br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191217164226.png" class="lazyload"></li></ul></li></ol><h3 id="cache的结构"><a class="markdownIt-Anchor" href="#cache的结构"></a> Cache的结构</h3><ol><li>Cache存储体</li><li>地址映射变换机构</li><li>替换机构</li></ol><h3 id="cache的读写操作"><a class="markdownIt-Anchor" href="#cache的读写操作"></a> Cache的读写操作</h3><ol><li>读：<img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191217165151.png" class="lazyload"></li><li>写：<strong>Cache和主存的一致性</strong><ol><li>写直达法：既写入Cache又写入主存。<strong>写操作时间就是访问主存的时间</strong></li><li>写回法：只把数据写入Cache而不写入主存，但Cache数据被替换出去时才写回主存。<strong>写操作时间就是访问Cache的时间</strong></li></ol></li></ol><h3 id="cache的改进"><a class="markdownIt-Anchor" href="#cache的改进"></a> Cache的改进</h3><ol><li>增加Cache的级数</li><li>统一缓存和分立缓存</li></ol><h2 id="cache-主存的地址映射"><a class="markdownIt-Anchor" href="#cache-主存的地址映射"></a> Cache-主存的地址映射</h2><h3 id="直接映射"><a class="markdownIt-Anchor" href="#直接映射"></a> 直接映射</h3><ul><li><strong>每个缓存块 i ———— 若干个主存块</strong></li><li><strong>每个主存块 j ———— 一个缓存块</strong></li></ul><blockquote><p>把主存划分成若干个<strong>与Cache相等的区</strong>，然后每个区里的字块一一映射到Cache字块<br>主存地址 = 主存字块标记(区号)[t] + Cache字块地址[c] + 字块内地址[b]<br>t + c = m</p></blockquote><h3 id="全相联映射"><a class="markdownIt-Anchor" href="#全相联映射"></a> 全相联映射</h3><ul><li><strong>主存中的任一块</strong>可以映射到<strong>缓存中的任一块</strong></li></ul><blockquote><p>主存地址 = 主存字块标记(m=t+c) + 字块内地址(b)</p></blockquote><h3 id="组相联映射"><a class="markdownIt-Anchor" href="#组相联映射"></a> 组相联映射</h3><ul><li>直接映射和全相联映射的结合</li><li>Cache被分成<strong>Q组</strong>，每组<strong>R块</strong></li><li><strong>某一主存块j</strong> 按 <strong>modQ</strong> 映射到缓存的<strong>第i组</strong>中的<strong>任一块</strong></li></ul><blockquote><p>直接映射：给定的一个块只能放在一个组<br>全相联映射：给定的一个块可以放到这个组中任一块<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191217172401.png" class="lazyload"></p></blockquote><h2 id="替换算法"><a class="markdownIt-Anchor" href="#替换算法"></a> 替换算法</h2><ol><li>先进先出(FIFO)</li><li>近期最少使用(LRU)：较好的利用局部性原理</li></ol><h1 id="辅助存储器"><a class="markdownIt-Anchor" href="#辅助存储器"></a> 辅助存储器</h1><h2 id="概述-3"><a class="markdownIt-Anchor" href="#概述-3"></a> 概述</h2><ul><li>不与CPU直接交换信息</li><li>磁表面技术指标：<ol><li>记录密度：道密度Dt，位密度Db</li><li>存储容量：C = n X k X s<ul><li>C为存储总量，n为盘面数，k为磁道数，s为磁道的二进制代码数</li></ul></li><li>平均寻址时间：寻道时间+等待时间<ul><li>平均等待时间：盘片旋转一周所需的时间的一半(即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mrow><mi mathvariant="normal">转</mi><mi mathvariant="normal">速</mi><mo>×</mo><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{转速 \times2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">转</span><span class="mord cjk_fallback mtight">速</span><span class="mbin mtight">×</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>)</li></ul></li><li>数据传输率：Dr = Db X V</li><li>误码率</li></ol></li></ul><h2 id="磁记录原理和记录方式"><a class="markdownIt-Anchor" href="#磁记录原理和记录方式"></a> 磁记录原理和记录方式</h2><h3 id="磁记录原理"><a class="markdownIt-Anchor" href="#磁记录原理"></a> 磁记录原理</h3><ul><li>磁层表面被磁化的<strong>极性方式不同</strong>，以区别0和1</li></ul><h3 id="记录方式"><a class="markdownIt-Anchor" href="#记录方式"></a> 记录方式</h3><ol><li><strong>归零制(RZ)</strong>：RZ记录&quot;1&quot;时，通以正向脉冲；记录&quot;0&quot;时，通以反向脉冲</li><li><strong>不归零(NRZ)</strong>：NRZ记录时，始终有驱动电流，不是正向就是反向。变化才翻转(见变就翻)</li><li><strong>&quot;见1就翻&quot;的不归零制(NEZ1)</strong>：始终有电流，只有见&quot;1&quot;才翻转</li><li><strong>调相制(PM)</strong>：又称相位编码(PE)，记录方式：记录&quot;1&quot;时，写电流由负变正；记录&quot;0&quot;时，写电流由正变负。电流变化出现在中间时刻。连续记录相同信息时，在每两个相同信息的交界处，电流反向；如果相邻信息不同，则电流不变向。</li><li><strong>调频制(FM)</strong>：又称倍频制，以驱动电流变化的频率记录区别0，1。记录&quot;0&quot;时，电流不变；记录&quot;1&quot;时，电流中间时刻反向。交界处均反向一次。所以&quot;0&quot;变化一次，&quot;1&quot;变化两次</li><li><strong>改进型调频制(MFM)</strong>：基本相同FM，但是MFM只有当连续记录两个或两个以上的&quot;0&quot;时，才在每位的起始位改变一次电流，不在每个起始点改变电流。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算方法</title>
      <link href="/2019/12/24/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%BB%84/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
      <url>/2019/12/24/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%BB%84/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="无符号数和有符号数"><a class="markdownIt-Anchor" href="#无符号数和有符号数"></a> 无符号数和有符号数</h1><h2 id="无符号数"><a class="markdownIt-Anchor" href="#无符号数"></a> 无符号数</h2><ul><li>寄存器的位数：反映无符号数的范围</li><li>0 ~ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="有符号数"><a class="markdownIt-Anchor" href="#有符号数"></a> 有符号数</h2><h3 id="机器数和真值"><a class="markdownIt-Anchor" href="#机器数和真值"></a> 机器数和真值</h3><ul><li>符号&quot;数字化&quot;的数，称为机器数</li><li>带&quot;+&quot;,&quot;-&quot;符号的数，称为真值</li></ul><h3 id="原码表示法"><a class="markdownIt-Anchor" href="#原码表示法"></a> 原码表示法</h3><ul><li>符号位0表示正数，符号位1表示负数</li><li>数值位即真值的绝对值<ul><li>整数的符号与数值之间用**逗号&quot;,&quot;**隔开</li><li>小数的符号位与数值之间用**小数点&quot;.&quot;**隔开</li></ul></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>+</mo><mn>0</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">原</mi></msub><mo stretchy="false">(</mo><mn>0.0</mn><mo stretchy="false">)</mo><mi mathvariant="normal">≠</mi><mo stretchy="false">[</mo><mo>−</mo><mn>0</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">原</mi></msub><mo stretchy="false">(</mo><mn>1.0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[+0]_{原}(0.0) \neq [-0]_{原}(1.0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">+</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，原码的0有两种形式</li></ul><h3 id="补码表示法"><a class="markdownIt-Anchor" href="#补码表示法"></a> 补码表示法</h3><ul><li>补的概念：一个负数加上 “模” 即得该负数的补数</li><li>求补码：<ul><li>正数：不变</li><li>负数：<strong>原码(除符号位)求反 + 1</strong> (<strong>反码+1</strong>)</li></ul></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1.0000</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>=</mo><mn>1.0000</mn></mrow><annotation encoding="application/x-tex">[-1.0000]_{补} = 1.0000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，因为补码0只有一种，所以可以多表示一位数字</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>+</mo><mn>0</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo stretchy="false">(</mo><mn>0.0</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mo>−</mo><mn>0</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo stretchy="false">(</mo><mn>0.0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[+0]_{补}(0.0) = [-0]_{补}(0.0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">+</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，补码的0只有一种</li></ul><h3 id="反码表示法"><a class="markdownIt-Anchor" href="#反码表示法"></a> 反码表示法</h3><ul><li>补码和原码之间互相转换的中间过渡</li><li>求反码：<ul><li>正数：不变</li><li>负数：<strong>原码(除符号位)求反</strong></li></ul></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>+</mo><mn>0</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">反</mi></msub><mo stretchy="false">(</mo><mn>0.0</mn><mo stretchy="false">)</mo><mi mathvariant="normal">≠</mi><mo stretchy="false">[</mo><mo>−</mo><mn>0</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">反</mi></msub><mo stretchy="false">(</mo><mn>1.0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[+0]_{反}(0.0) \neq [-0]_{反}(1.0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">+</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">反</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">反</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，反码的0有两种形式</li></ul><h3 id="三种机器数小结"><a class="markdownIt-Anchor" href="#三种机器数小结"></a> 三种机器数小结</h3><ul><li><strong>最高位均为符号位</strong>。符号位和数值部分用逗号&quot;,“或小数点”.&quot;(<strong>书写时，实际不存在</strong>)</li><li>正值<strong>三码合一</strong>，即符号位&quot;0&quot;，数值部分为真值</li><li>负值三种方式均不同，但符号位均&quot;1&quot;<ul><li>补码是原码的&quot;求反加1&quot;</li><li>反码是原码的&quot;每位求反&quot;</li></ul></li><li>不论正负，<strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi>y</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub></mrow><annotation encoding="application/x-tex">[-y]_{补}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>y</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub></mrow><annotation encoding="application/x-tex">[y]_{补}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>连同符号位在内，每位求反，末位加1</strong></li></ul><h3 id="移码表示法"><a class="markdownIt-Anchor" href="#移码表示法"></a> 移码表示法</h3><ul><li>移码：在真值上加上一个常数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，与 <strong>补码仅差一个符号位</strong> ，将补码的符号位取反即得到移码</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>+</mo><mn>0</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">移</mi></msub><mo stretchy="false">(</mo><mn>1.0</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mo>−</mo><mn>0</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">移</mi></msub><mo stretchy="false">(</mo><mn>1.0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[+0]_{移}(1.0) = [-0]_{移}(1.0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">+</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">移</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">移</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，移码的0只有一种</li></ul><h1 id="定点表示和浮点表示"><a class="markdownIt-Anchor" href="#定点表示和浮点表示"></a> 定点表示和浮点表示</h1><h2 id="定点表示"><a class="markdownIt-Anchor" href="#定点表示"></a> 定点表示</h2><ul><li>小数点固定在某一位置的数为定点数</li><li>数值部分决定了定点机中数的表示范围</li></ul><h2 id="浮点表示"><a class="markdownIt-Anchor" href="#浮点表示"></a> 浮点表示</h2><ul><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mi>S</mi><mo>×</mo><msup><mi>r</mi><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">N = S \times r ^ j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span></p><ul><li><strong>S 尾数：小数，可正可负</strong></li><li><strong>j 阶码：整数，可正可负</strong></li><li><strong>r 基数：固定，与计算机有关，取2，4，8，16 ……</strong></li></ul></li><li><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191223202817.png" class="lazyload"></p></li><li><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191223205035.png" class="lazyload"></p><ul><li>上溢中断，下溢为机器0</li></ul></li><li><p>浮点数的规格化形式(原码)</p><ul><li>r = 2 ：尾数最高位为 1</li><li>r = 4 ：尾数最高2位不全为0</li><li>r = 8 ：尾数最高3位不全为0</li><li><strong>基数不同，浮点数的规格化形式不同</strong></li></ul></li><li><p>浮点数的规格化</p><ul><li>r = 2<ul><li>左规：尾数左移 1 位，阶码减 1</li><li>右规：尾数右移 1 位，阶码加 1</li></ul></li><li><strong>基数 r 越大，可表示的浮点数的范围越大</strong></li><li><strong>基数 r 越大，浮点数的精度降低</strong></li><li>规格化后范围变小</li></ul></li><li><p>机器零：</p><ul><li>当浮点数 <strong>尾数为 0</strong> 时，不论其阶码为何值按机器零处理</li><li>当浮点数 <strong>阶码等于或小于它所表示的最小数</strong> 时，不论尾数为何值，按机器零处理</li></ul></li><li><p>IEEE 754标准：尾数为规格化表示，非 “0” 的有效位最高位为 “1”（隐含）</p></li></ul><h1 id="定点运算"><a class="markdownIt-Anchor" href="#定点运算"></a> 定点运算</h1><h2 id="移位运算"><a class="markdownIt-Anchor" href="#移位运算"></a> 移位运算</h2><ol><li>移位的意义：和加减配合，实现乘除<ul><li>数值相对于小数点移动，而不是小数点移动</li></ul></li><li>算术移位规则<ul><li>正数：补0</li><li>负数：<ul><li>原码：补0</li><li>补码：左移补0，右移补1</li><li>反码：补1</li></ul></li></ul></li><li>算术移位和逻辑移位<ul><li>算术移位：无符号数</li><li>逻辑移位：有符号数</li></ul></li></ol><h2 id="加减法"><a class="markdownIt-Anchor" href="#加减法"></a> 加减法</h2><ol><li>加法：A+B<ul><li>整数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>A</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>+</mo><mo stretchy="false">[</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>=</mo><mo stretchy="false">[</mo><mi>A</mi><mo>+</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[A]_{补} + [B]_{补} = [A+B]_{补}(mod 2^{n+1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>小数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>A</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>+</mo><mo stretchy="false">[</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>=</mo><mo stretchy="false">[</mo><mi>A</mi><mo>+</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[A]_{补} + [B]_{补} = [A+B]_{补}(mod 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></li></ul></li><li>减法：A-B<ul><li>转化为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub></mrow><annotation encoding="application/x-tex">[-B]_{补}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，就变成了加法</li></ul></li></ol><ul><li><strong>连同符号位一起相加，符号位产生的进位自然丢掉</strong></li></ul><ol start="3"><li>溢出判断<ol><li>一位符号位判溢出<ul><li>两个数符号相同，结果变号即溢出</li></ul></li><li>两位符号位判溢出<ul><li>双符号位相同，未溢出；不同则溢出</li><li><strong>最高符号位代表其真正的符号</strong></li></ul></li></ol></li></ol><h2 id="乘法运算"><a class="markdownIt-Anchor" href="#乘法运算"></a> 乘法运算</h2><ol><li>分析笔算乘法<ul><li>符号位单独处理</li><li>乘数的某一个决定是否加被乘数</li><li>乘积位数扩大一倍</li></ul></li><li>笔算乘法改进<ul><li><strong>乘法</strong>运算可用<strong>加和移位</strong>实现</li><li>由乘数的末位决定被乘数是否与原部分积相加，然后：<strong>➡1位形成新的部分积</strong>，同时：<strong>乘数➡1位</strong>(末位移丢)，空出的高位存放部分积的地位</li><li><strong>被乘数只与部分积的高位相加</strong></li><li>3个寄存器，其中2个具有移位功能；1个全加器</li></ul></li></ol><h3 id="原码乘法"><a class="markdownIt-Anchor" href="#原码乘法"></a> 原码乘法</h3><h4 id="原码一位乘"><a class="markdownIt-Anchor" href="#原码一位乘"></a> 原码一位乘</h4><ul><li>乘积的符号位单独处理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>⊕</mo><msub><mi>y</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_{0} \oplus y_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>数值部分为<strong>绝对值</strong>相乘 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mo>∗</mo></msup><mo>×</mo><msup><mi>y</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">x^* \times y^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.772026em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8831359999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></li><li>用 <strong>逻辑移位</strong> 的次数 <strong>(乘数位数)</strong> 判断乘法是否结束</li></ul><h4 id="原码两位乘"><a class="markdownIt-Anchor" href="#原码两位乘"></a> 原码两位乘</h4><ul><li><p>原码乘：<strong>符号位</strong>和<strong>数值位</strong>部分<strong>分开运算</strong></p></li><li><p>两位乘：每次用 <strong>乘数的 2 位判断</strong> 原部分积，<strong>是否加</strong>和<strong>如何加</strong>被乘数</p><table><thead><tr><th>乘数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>y</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">y_{n-1}y_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th><th>新的部分积</th></tr></thead><tbody><tr><td>00</td><td>加&quot;0&quot;，➡2位</td></tr><tr><td>01</td><td>加1倍的被乘数，➡2位</td></tr><tr><td>10</td><td>加2倍的被乘数，➡2位</td></tr><tr><td>11</td><td>加3倍的被乘数，➡2位</td></tr></tbody></table><ul><li>如何加3倍的被乘数：先减一倍，再加四倍</li></ul></li><li><p><strong>绝对值的补码运算</strong>，采用补码右移：因为要用到减法，所以采用补码运算</p></li><li><p>用 <strong>算术移位</strong> 的次数判断乘法是否结束</p></li></ul><h4 id="比较"><a class="markdownIt-Anchor" href="#比较"></a> 比较</h4><table><thead><tr><th>异同处</th><th>原码一位乘</th><th>原码两位乘</th></tr></thead><tbody><tr><td>符号位</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>⊕</mo><msub><mi>y</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_{0} \oplus y_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>⊕</mo><msub><mi>y</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_{0} \oplus y_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td></tr><tr><td>操作数</td><td>绝对值</td><td><strong>绝对值的补码</strong></td></tr><tr><td>移位</td><td>逻辑右移</td><td>算术右移</td></tr><tr><td>移位次数</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>(n为偶数)</td></tr><tr><td>最多加法次数</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{n}{2}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>(n为偶数)</td></tr></tbody></table><ul><li>n为奇数：最高位补0，就变成了偶数个</li></ul><h3 id="补码乘法"><a class="markdownIt-Anchor" href="#补码乘法"></a> 补码乘法</h3><ol><li>补码一位乘</li><li>Booth算法(被乘数、乘数符号任意)</li></ol><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><ol><li>整数乘法与小数乘法完全相同</li><li>原码乘：符号位<strong>单独处理</strong></li><li>补码乘：符号位<strong>自然形成</strong></li><li>原码乘去掉符号位运算，即为无符号数乘法</li></ol><h1 id="浮点四则运算"><a class="markdownIt-Anchor" href="#浮点四则运算"></a> 浮点四则运算</h1><h2 id="浮点加减运算"><a class="markdownIt-Anchor" href="#浮点加减运算"></a> 浮点加减运算</h2><ol><li>对阶<ol><li>求阶差</li><li>对阶原则：<strong>小阶向大阶看齐</strong></li></ol></li><li>尾数求和</li><li>规格化<ol><li>定义：r = 2：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>≤</mo><mrow><mo fence="true">∣</mo><mi>S</mi><mo fence="true">∣</mo></mrow><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{1}{2} \leq \left| S \right| \leq1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li>判断：<ul><li>原码：<strong>不论正数、负数，第一数位为1</strong></li><li>补码：<strong>符号位和第 一数位不同</strong></li><li>特例：<ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>=</mo><mn>1.10..0</mn></mrow><annotation encoding="application/x-tex">[-\frac{1}{2}]_{补} = 1.10..0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">0</span></span></span></span> 不是规格化数</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>=</mo><mn>1.00..0</mn></mrow><annotation encoding="application/x-tex">[-1]_{补} = 1.00..0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">0</span></span></span></span> 是规格化数</li></ul></li></ul></li><li>左规：<strong>尾数左移一位，阶码减 1，直到数符和第一数位不同为止</strong></li><li>右规：<strong>尾数溢出时，即尾数为：01.xxx或10.xxx时，尾数右移一位，阶码加 1</strong></li></ol></li><li>舍入：在<strong>对阶</strong>和<strong>右规</strong>过程中，可能出现<strong>尾数末位丢失</strong>引起误差，需考虑舍入<ol><li>0舍1入法</li><li>恒置1法</li></ol></li></ol><h2 id="浮点乘除运算"><a class="markdownIt-Anchor" href="#浮点乘除运算"></a> 浮点乘除运算</h2><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>S</mi><mi>x</mi></msub><mo>×</mo><msup><mn>2</mn><msub><mi>j</mi><mi>x</mi></msub></msup></mrow><annotation encoding="application/x-tex">x = S_{x} \times 2^{j_{x}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05724em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>S</mi><mi>y</mi></msub><mo>×</mo><msup><mn>2</mn><msub><mi>j</mi><mi>y</mi></msub></msup></mrow><annotation encoding="application/x-tex">y = S_{y} \times 2^{j_{y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8246640000000001em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8246640000000001em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:-0.05724em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li></ul><ol><li>乘法：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>×</mo><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>S</mi><mi>x</mi></msub><mo>×</mo><msub><mi>S</mi><mi>y</mi></msub><mo stretchy="false">)</mo><mo>×</mo><msup><mn>2</mn><mrow><msub><mi>j</mi><mi>x</mi></msub><mo>+</mo><msub><mi>j</mi><mi>y</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">x \times y = (S_{x} \times S_{y}) \times 2^{j_{x}+j_{y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8246640000000001em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8246640000000001em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05724em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:-0.05724em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li>除法：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>x</mi><mi>y</mi></mfrac><mo>=</mo><mfrac><msub><mi>S</mi><mi>x</mi></msub><msub><mi>S</mi><mi>y</mi></msub></mfrac><mo>×</mo><msup><mn>2</mn><mrow><msub><mi>j</mi><mi>x</mi></msub><mo>−</mo><msub><mi>j</mi><mi>y</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">\frac{x}{y} = \frac{S_{x}}{S_{y}} \times 2^{j_{x}-j_{y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1764999999999999em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.4307509999999999em;vertical-align:-0.5423199999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8884309999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5423199999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8246640000000001em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8246640000000001em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05724em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:-0.05724em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li>步骤：<ol><li>阶码采用 <strong>补码定点加(乘法)减(除法)</strong> 运算</li><li>尾数乘除同定点运算</li><li>规格化</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO系统</title>
      <link href="/2019/12/23/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%BB%84/IO%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/12/23/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%BB%84/IO%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><h2 id="io设备与主机信息传送的控制方式"><a class="markdownIt-Anchor" href="#io设备与主机信息传送的控制方式"></a> I/O设备与主机信息传送的控制方式</h2><ol><li>程序查询</li><li>程序中断</li><li>DMA</li></ol><h1 id="io设备"><a class="markdownIt-Anchor" href="#io设备"></a> I/O设备</h1><ol><li>输入设备：键盘，鼠标，触摸屏……</li><li>输出设备：显示器，打印机……</li><li>其他：A/D，D/A……</li><li>多媒体：VR……</li></ol><h1 id="io接口"><a class="markdownIt-Anchor" href="#io接口"></a> I/O接口</h1><h2 id="概述-2"><a class="markdownIt-Anchor" href="#概述-2"></a> 概述</h2><ul><li>为什么要设置接口：<ol><li>实现设备的选择</li><li>实现数据缓冲达到速度匹配</li><li>实现数据串——并格式转换</li><li>实现电平转换</li><li>传送控制命令</li><li>反映设备的状态（“忙”、“就绪”、“中断请求”）</li></ol></li></ul><h2 id="功能和组成"><a class="markdownIt-Anchor" href="#功能和组成"></a> 功能和组成</h2><ul><li>总线连接方式的 I/O 接口电路<ol><li>设备选择线</li><li>数据线</li><li>命令线</li><li>状态线</li></ol></li></ul><table><thead><tr><th>功能</th><th>组成</th></tr></thead><tbody><tr><td>选址</td><td>设备选择电路</td></tr><tr><td>传送命令</td><td>命令寄存器、命令译码器</td></tr><tr><td>传送数据</td><td>数据缓冲寄存器(DBR)</td></tr><tr><td>反映设备状态</td><td>设备状态标记</td></tr></tbody></table><ul><li>状态标记：完成触发器D，工作触发器B，中断请求触发器INTR，屏蔽触发器MASK</li></ul><h2 id="接口类型"><a class="markdownIt-Anchor" href="#接口类型"></a> 接口类型</h2><ol><li>按数据 <strong>传送方式</strong> 分类</li><li>按功能 <strong>选择的灵活性</strong> 分类</li><li>按 <strong>通用性</strong> 分类</li><li>按数据传送的 <strong>控制方式</strong> 分类</li></ol><h1 id="程序查询方式"><a class="markdownIt-Anchor" href="#程序查询方式"></a> 程序查询方式</h1><h1 id="程序中断方式"><a class="markdownIt-Anchor" href="#程序中断方式"></a> 程序中断方式</h1><h1 id="dma方式"><a class="markdownIt-Anchor" href="#dma方式"></a> DMA方式</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总线</title>
      <link href="/2019/12/16/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%BB%84/%E6%80%BB%E7%BA%BF/"/>
      <url>/2019/12/16/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%BB%84/%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="系统总线"><a class="markdownIt-Anchor" href="#系统总线"></a> 系统总线</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><ul><li>总线是连接各个部件的信息传输线，是<strong>各个部件共享的传输介质</strong></li><li>总线(Bus)是指计算机组件间<strong>规范化的交换数据（data）的方式</strong>，即以一种通用的方式为各组件提供数据传送和控制逻辑。</li></ul><h2 id="总线分类"><a class="markdownIt-Anchor" href="#总线分类"></a> 总线分类</h2><ol><li>片内总线：<strong>芯片内部</strong>的总线</li><li>系统总线：<strong>计算机各部件之间</strong>的信息传输线<ol><li>数据总线：<strong>双向</strong>，与机器字长、存储字长有关</li><li>地址总线：<strong>单向</strong>，与存储地址、I/O地址有关</li><li>控制总线：<strong>有出 有入</strong></li></ol></li><li>通信总线：<strong>计算机系统之间</strong>或<strong>与其他系统</strong>之间的通信<ul><li>串行，并行</li></ul></li></ol><h2 id="总线特性及性能指标"><a class="markdownIt-Anchor" href="#总线特性及性能指标"></a> 总线特性及性能指标</h2><h3 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h3><p>机械，电气，功能，时间</p><h3 id="性能指标"><a class="markdownIt-Anchor" href="#性能指标"></a> 性能指标</h3><ol><li><strong>总线宽度：数据线的根数</strong></li><li><strong>标准传输率：即总线带宽，每秒传输最大字节数(MBps/Mbps)</strong></li><li><strong>时钟</strong>，复用，信号线数，总线控制方式，其他指标(负载能力)</li></ol><h2 id="总线结构"><a class="markdownIt-Anchor" href="#总线结构"></a> 总线结构</h2><h3 id="单总线"><a class="markdownIt-Anchor" href="#单总线"></a> 单总线</h3><p>只有一条系统总线</p><h3 id="多总线"><a class="markdownIt-Anchor" href="#多总线"></a> 多总线</h3><ol><li>双总线</li><li>三总线(两种结构)</li><li>四总线</li></ol><h2 id="总线控制"><a class="markdownIt-Anchor" href="#总线控制"></a> 总线控制</h2><ul><li>控制方式：<ol><li><strong>链式查询方式</strong></li><li><strong>计数器定时查询方式</strong></li><li><strong>独立请求方式</strong></li></ol></li><li>总线传输周期：<ul><li>申请分配阶段：<strong>主模块申请</strong>，总线仲裁决定</li><li>寻址阶段：主模块向从模块<strong>给出地址和命令</strong></li><li>传输阶段：主模块和从模块<strong>交换数据</strong></li><li>结束阶段：主模块<strong>撤销有关信息</strong></li></ul></li><li>总线通信四种方式<ul><li>同步通信：由<strong>统一时标</strong>控制数据传送</li><li>异步通信：采用<strong>应答方式</strong>(互锁)，没有公共时钟标准</li><li>半同步通信：<strong>同步，异步结合</strong></li><li>分离式通信：充分挖掘系统总线每个瞬间的潜力(效率最高，最复杂)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编伪操作</title>
      <link href="/2019/12/14/%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E4%BC%AA%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/12/14/%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E4%BC%AA%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="处理器选择伪操作"><a class="markdownIt-Anchor" href="#处理器选择伪操作"></a> 处理器选择伪操作</h1><p>这类伪操作一般放在程序的最前面，如不给出,则汇编程序默认值为  .8086</p><h1 id="段定义伪操作"><a class="markdownIt-Anchor" href="#段定义伪操作"></a> 段定义伪操作</h1><h2 id="完整的段定义伪操作"><a class="markdownIt-Anchor" href="#完整的段定义伪操作"></a> 完整的段定义伪操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">段名  SEGMENT  [定位类型]  [组合类型]  [使用类型]  [‘类别’]</span><br><span class="line">    ……</span><br><span class="line">    ……            ;语句序列</span><br><span class="line">段名  ENDS</span><br></pre></td></tr></table></figure><ol><li>段名是为该段起的名字，用来指出汇编程序为该段分配的存储区起始位置</li><li>定位类型：<strong>PARA(默认)</strong>，WORD，BYTE，PAGE。<ul><li>段地址起始地址的限制，PARA限制16的整数倍</li></ul></li><li>组合类型：<strong>PRIVATE(默认)</strong>，PUBLIC，COMMON，STACK，MEMORY(同PUBLIC)，AT 表达式</li><li>使用类型：USE16，USE32.<ul><li>使用xx位寻址方式</li></ul></li><li>类别：在引号中给出连接时组成的段组的类型名。在连接后形成的装入模块中，可使相同类别的段位置靠在一起。</li></ol><h2 id="假定伪指令assume"><a class="markdownIt-Anchor" href="#假定伪指令assume"></a> 假定伪指令ASSUME</h2><ul><li>格式：ASSUME  段寄存器：段名 [，段寄存器：段名]</li><li>功能：<strong>建立段寄存器与段之间的对应关系</strong>。该伪指令一般出现在代码段中。<ul><li>只是建立对应关系，但没有赋值，还<strong>需要自己初始化段寄存器的值</strong></li></ul></li><li>其中段寄存器名必须是CS,DS,ES和SS中的一个。段名必须是由SEGMENT定义的段中的段名。</li></ul><h2 id="段组定义伪操作"><a class="markdownIt-Anchor" href="#段组定义伪操作"></a> 段组定义伪操作</h2><ul><li>格式：段组名  GROUP  数据段名1[，数据段名2……]</li><li>功能：汇编程序把各数据段组成一个段组，以便程序在访问各数据段时使用一个数据段寄存器DS。</li></ul><h1 id="数据定义及存储器分配伪操作"><a class="markdownIt-Anchor" href="#数据定义及存储器分配伪操作"></a> 数据定义及存储器分配伪操作</h1><h2 id="格式"><a class="markdownIt-Anchor" href="#格式"></a> 格式</h2><p>[变量名]   助记符   操作数 [ , 操作数 , … ]  [ ; 注释]</p><ul><li>变量名必须是一个合法的标识符，可写可不写</li><li>助记符：<strong>DB（字节）、DW（字）、DD（双字）、DF（6字节）、DQ（四字）、DT（10字节）</strong></li><li>操作数是定义内存单元时的初值表达式，一个定义语句可以有多个初值表达式，各表达式之间必须用逗号 <strong>‘,’</strong> 分开；如果某个存储单元没有初值表达式，则必须用一个问号 <strong>‘?’</strong> 来表示；<ul><li>注：‘?’表示保留存储空间但不存入数据</li></ul></li><li>注释可以不写</li></ul><h2 id="重复说明符dup"><a class="markdownIt-Anchor" href="#重复说明符dup"></a> 重复说明符DUP</h2><ul><li>一般形式：<strong>repeat_conut DUP(表达式，表达式……)</strong><ul><li>repeat_conut是重复次数</li><li>(表达式，表达式……)是被重复的部分</li><li>表达式可以是<strong>存储单元的初值</strong>，也可以是<strong>另一个DUP式子(可以嵌套)</strong></li><li>多个表达式要用逗号 <strong>‘,’</strong> 分开</li></ul></li></ul><h2 id="强制属性操作符ptr"><a class="markdownIt-Anchor" href="#强制属性操作符ptr"></a> 强制属性操作符PTR</h2><ul><li>类似于C语言的强制类型转换，为临时属性</li><li>一般格式：<strong>数据类型　PTR　地址表达式</strong><ul><li>例如：MOV byte ptr[BX]，1H</li></ul></li></ul><h2 id="label伪操作"><a class="markdownIt-Anchor" href="#label伪操作"></a> LABEL伪操作</h2><ul><li>同一个变量可以具有不同的类型属性，除了可以用PTR来定义外，还可以用LABEL伪操作来定义</li><li>一般格式：<strong>符号名  LABEL　变量类型</strong></li><li>LABEL为当前地址的另一别称，不占内存空间</li></ul><h1 id="表达式赋值伪操作"><a class="markdownIt-Anchor" href="#表达式赋值伪操作"></a> 表达式赋值伪操作</h1><h2 id="等价语句"><a class="markdownIt-Anchor" href="#等价语句"></a> 等价语句</h2><p><strong>符号名　EQU　表达式</strong></p><ul><li>作用：左边的符号名代表右边的表达式</li><li>注意：等价语句不会给符号名分配空间，不能重名，也不能被重新定义</li></ul><h2 id="等号"><a class="markdownIt-Anchor" href="#等号"></a> 等号&quot;=&quot;</h2><p><strong>符号名＝数值表达式</strong></p><ul><li>汇编语言提供了 <strong>等号&quot;=&quot;</strong> 来定义符号常数的方法，即可用符号名代表一个常数。</li><li>数值表达式在汇编时<strong>应该可以计算出数值</strong>，它<strong>不能含有向前引用的符号名称</strong>。</li><li>用等号语句定义的符号<strong>可以被重复定义</strong>。</li></ul><h2 id="equ和的区别"><a class="markdownIt-Anchor" href="#equ和的区别"></a> EQU和&quot;=&quot;的区别</h2><ul><li>由EQU伪指令定义后的符号名是<strong>不能重复再定义的</strong></li><li>而“=”伪指令中定义的符号名<strong>可重复定义</strong></li></ul><h1 id="地址计数器与对准伪操作"><a class="markdownIt-Anchor" href="#地址计数器与对准伪操作"></a> 地址计数器与对准伪操作</h1><h2 id="地址计数器"><a class="markdownIt-Anchor" href="#地址计数器"></a> 地址计数器 $</h2><ul><li>作用：保存当前正在汇编的指令的地址</li><li>$ 用在伪操作的参数字段：表示地址计数器的当前值</li></ul><h2 id="org伪操作"><a class="markdownIt-Anchor" href="#org伪操作"></a> ORG伪操作</h2><ul><li>作用：告诉汇编程序，本伪指令下面的内存变量从该“数值表达式”所指定的地址开始分配。</li></ul><h1 id="基数控制伪操作"><a class="markdownIt-Anchor" href="#基数控制伪操作"></a> 基数控制伪操作</h1><p>RADIX  表达式 ; 规定无标记数的基数</p><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><h2 id="offset运算符"><a class="markdownIt-Anchor" href="#offset运算符"></a> OFFSET运算符</h2><ul><li>格式：OFFSET  变量或标号</li><li>功能：分离出其后变量或标号的<strong>偏移地址</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符重载</title>
      <link href="/2019/12/13/%E5%AD%A6%E4%B9%A0/C++%E5%AD%A6%E4%B9%A0/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2019/12/13/%E5%AD%A6%E4%B9%A0/C++%E5%AD%A6%E4%B9%A0/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p><strong>函数类型 operator 运算符名称(形参表)</strong><br>{ <strong>对运算符的重载处理</strong> }</p><ul><li>函数名是由 <strong>operator</strong> 和 <strong>运算符</strong> 组成的</li></ul><hr><ul><li>运算符重载的规则<ol><li>不允许用户自定义新的运算符</li><li>不允许重载的5个运算符：<table><thead><tr><th>符号</th><th>类型</th></tr></thead><tbody><tr><td>.</td><td>成员访问运算符</td></tr><tr><td>*</td><td>成员指针访问运算符</td></tr><tr><td>::</td><td>域运算符</td></tr><tr><td>sizeof</td><td>长度运算符</td></tr><tr><td>?:</td><td>条件运算符</td></tr></tbody></table></li><li>不能改变 <strong>操作数个数</strong></li><li>不能改变 <strong>优先级</strong> 和 <strong>结合性</strong></li><li>不能有默认参数</li><li>参数 <strong>至少有一个</strong> 是类对象（或者对象的引用）</li><li>= 和 &amp; 不必重载</li></ol></li></ul><hr><ul><li>运算符重载的两个方式：<ol><li>作为成员函数<ul><li>可以少写一个函数参数</li><li>一般为单目操作符</li><li><strong>=，[]，()，-&gt;只能作为成员函数重载</strong></li></ul></li><li>友元函数<ul><li>一般为 <strong>双目操作符</strong> 的重载（为了普适交换律），以及 流插入 <strong>“&lt;&lt;”</strong> 和 流提取 <strong>“&gt;&gt;”</strong> 的重载</li><li>双目运算符的参数列表必须有 <strong>两个参数</strong></li></ul></li><li>不能是普通函数</li></ol></li></ul><hr><ul><li>单目运算符：++，–的重载<ul><li>前增：Object operator ++ ();</li><li>后增：Object operator ++ ( <strong>int</strong> );</li><li>为了让编译器区别前置和后置，在后置的声明中加入一个 <strong>虚参数</strong> ，以示区别</li><li>而且后增返回的应该为变化前的对象，此时应该调用复制构造函数：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="comment">//进行++</span></span><br><span class="line"><span class="keyword">return</span> temp;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><ul><li>流插入 <strong>“&lt;&lt;”</strong> 和 流提取 <strong>“&gt;&gt;”</strong> 的重载<ul><li><p>必须作为 <strong>友元函数</strong> ！</p></li><li><p>传入两个参数：一个流参数，一个对象，均为 <strong>引用</strong></p><ul><li>如果要对 <strong>临时对象</strong> (如返回对象)，进行 “&lt;&lt;”，此时要用const修饰引用的对象(ostream &amp;os,<strong>const</strong> Object &amp;obj)，因为临时对象为 <strong>右值且默认const属性</strong>, C++ 规定右值不能绑定到非 const 限定的左值引用。</li></ul></li><li><p>返回的类型要为 <strong>流</strong>，以便于连续向输出/输出流 <strong>插入信息</strong></p></li><li><p>&quot;&lt;&lt;&quot;的重载格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream &amp;os,Object &amp;obj)&#123;</span><br><span class="line">   os&lt;&lt;obj.members;</span><br><span class="line">   <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>&quot;&gt;&gt;&quot;的重载格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream &amp;is,Object &amp;obj)&#123;</span><br><span class="line">is&gt;&gt;obj.members;</span><br><span class="line"><span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><ul><li>类型转换函数<blockquote><p>operator 类型名()<br>{实现转换的语句}<br>//operator double(); 将对象转换为double类型。至于怎么转换，自己定义</p></blockquote><ul><li><strong>不能指定类型，没有参数</strong></li><li>必须为成员函数，因为转换的主体是本类的对象</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8086寻址方式</title>
      <link href="/2019/12/13/%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96/8086%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/12/13/%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96/8086%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="有效地址ea"><a class="markdownIt-Anchor" href="#有效地址ea"></a> 有效地址EA</h1><ul><li>8086中把<strong>操作数的偏移地址</strong>称为有效地址(EA)<br><strong>EA = 基址 + (变址*比例因子) + 位移量</strong></li></ul><table><thead><tr><th>四种成分</th><th>16位寻址</th><th>32位寻址</th></tr></thead><tbody><tr><td>位移量</td><td>0、8、16位</td><td>0、8、16、32位</td></tr><tr><td>基址寄存器</td><td>BX，BP</td><td>任何32位通用寄存器(包括ESP)</td></tr><tr><td>变址寄存器</td><td>SI，Di</td><td>除ESP以外的32位通用寄存器</td></tr><tr><td>比例因子</td><td>无</td><td>1、2、4、8</td></tr></tbody></table><ul><li>比例因子为固定值，其他三个成分都可正可负，以保证指针移动的灵活性</li><li>比例因子：386及后续机型新增的寻址方式中的一个术语，其值可以为1、2、4、8。</li></ul><h1 id="与数据有关的寻址方式"><a class="markdownIt-Anchor" href="#与数据有关的寻址方式"></a> 与数据有关的寻址方式</h1><ul><li>以MOV指令为例<ul><li>立即寻址：MOV  AX,3069H</li><li><strong>寄存器寻址：MOV  AL,BH</strong></li><li><strong>直接寻址：MOV  AX,[2000H]</strong></li><li>寄存器间接寻址：MOV AX,[BX]</li><li><strong>寄存器相对寻址：MOV AX,COUNT[SI]</strong></li><li>基址变址寻址：MOV AX,[BP][DI]</li><li>相对基址变址寻址：MOV AX,MASK[BX][SI]</li></ul></li></ul><h2 id="立即数寻址"><a class="markdownIt-Anchor" href="#立即数寻址"></a> 立即数寻址</h2><p>如：MOV AX, 3069H</p><ul><li><strong>操作数作为指令的一部分</strong>直接写在指令中，这种操作数成为立即数，这种寻址方式也成为立即数寻址方式</li><li>特点：操作数存放在存储器中，<strong>指令的下一单元即为立即操作数n</strong>。</li></ul><h2 id="寄存器寻址"><a class="markdownIt-Anchor" href="#寄存器寻址"></a> 寄存器寻址</h2><p>如：MOV AL, BH</p><ul><li><strong>指令中要用到的操作数已经存储在某寄存器中，或把目标操作数存入某寄存器</strong>。把指令中指出所使用寄存器（即寄存器的助记符）的寻址方式成为寄存器寻址</li><li>特点：操作数直接存放在寄存器中，<strong>速度较快</strong></li></ul><h2 id="直接寻址"><a class="markdownIt-Anchor" href="#直接寻址"></a> 直接寻址</h2><p>如：MOV AX, [2000H]</p><ul><li><strong>EA = 操作数</strong></li><li>指令所要的操作数存放在内存中，指令中<strong>直接给出该操作数的有效地址</strong></li><li>特点：操作数的有效地址只包含位移量一种成分</li><li>直接寻址的地址要写在”[]”内</li></ul><h2 id="寄存器间接寻址"><a class="markdownIt-Anchor" href="#寄存器间接寻址"></a> 寄存器间接寻址</h2><p>如：MOV AX, [BX]</p><ul><li><strong>EA = BX</strong></li><li>操作数在存储器中，<strong>操作数的有效地址使用SI、DI、BX和BP等四个寄存器之一来指定</strong></li><li>特点：有效地址在寄存器中，操作数在存储器中</li></ul><h2 id="寄存器相对寻址"><a class="markdownIt-Anchor" href="#寄存器相对寻址"></a> 寄存器相对寻址</h2><p>如：MOV AX，COUNT[SI] (也可表示为 MOV AX, [COUNT+SI])</p><ul><li><strong>EA = COUNT + SI</strong></li><li>操作数在存储器中，其有效地址是<strong>一个基址寄存器(BX、BP)或变址寄存器(SI、DI)的内容和指令中的8位/16位偏移量之和</strong></li><li>特点：有效地址由两种成分组成</li></ul><h2 id="基址变址-寻址"><a class="markdownIt-Anchor" href="#基址变址-寻址"></a> 基址变址 寻址</h2><p>如：MOV AX,[BP][SI](或MOV AX,[BP+SI])</p><ul><li><strong>EA = BP+SI</strong></li><li>操作数存储在存储器中，其地址是一个基址寄存器（BX、BP）和一个变址寄存器（SI、DI）的内容之和</li><li>处理数组和表格，首地址放在基址寄存器(BX,BP)，而用变址寄存器(SI,DI)来访问数组的各个元素</li></ul><h2 id="相对基址变址寻址"><a class="markdownIt-Anchor" href="#相对基址变址寻址"></a> 相对基址变址寻址</h2><p>如：MOV AX,MASK[BX][SI]</p><ul><li><strong>EA = MASK+BX+SI</strong></li><li>操作数存放于存储器中，其有效地址是由一个基址寄存器（BX、BP）、一个变址寄存器（SI、DI）和指令中的8位/16位偏移量之和</li><li>通常用于二维数组的寻址</li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编指令</title>
      <link href="/2019/12/13/%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"/>
      <url>/2019/12/13/%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="标志寄存器flasgs"><a class="markdownIt-Anchor" href="#标志寄存器flasgs"></a> 标志寄存器FLASGS</h1><ol><li>ZF(Zero Flag)</li></ol><ul><li>零标志位，执行完相关指令后，其结果是否为0</li><li>为0则ZF=1；不为0则ZF=0</li></ul><ol start="2"><li>CF(Carry Flag)</li></ol><ul><li>进位标志位，当运行结果的最高有效位有进位（加法）或借位（减法）时，进位标志置1，即CF=1;否则CF=0</li></ul><ol start="3"><li>SF(Sign Flag)</li></ol><ul><li>运行结果最高位为1，则SF=1，否则SF=0</li></ul><ol start="4"><li>PF(Parity Flag)</li></ol><ul><li>当运行结果最低字节的“1”的个数为零或者偶数时，PF=1，否则，PF=0</li></ul><ol start="5"><li>OF(Overflow Flag)</li></ol><ul><li>若算术运算的结果有溢出则OF=1，否则OF=0</li></ul><h1 id="数据传送指令"><a class="markdownIt-Anchor" href="#数据传送指令"></a> 数据传送指令</h1><h2 id="mov"><a class="markdownIt-Anchor" href="#mov"></a> MOV</h2><p>中文名：传送指令<br>允许以下操作：</p><ol><li>MOV 寄存器，寄存器/内存单元/段寄存器/立即数</li><li>MOV 内存单元，寄存器/段寄存器/立即数</li><li>MOV 段寄存器，寄存器/内存单元</li></ol><p>不允许以下操作：<br>4. 两个操作数类型不一样</p><ul><li>例如源操作数是字节，而目的操作数是字</li></ul><ol start="5"><li>两个操作数不能都是内存单元的数<ul><li>主存之间的直接传送不允许</li></ul></li><li>段寄存器的操作限制：<ol><li><strong>不允许直接传立即数给段寄存器</strong><blockquote><p>不能直接用变量名，因为变量其实也是个立即数</p></blockquote></li><li>不要直接改变CS值</li><li>不允许段寄存器之间的直接数据传送</li></ol></li></ol><h2 id="push"><a class="markdownIt-Anchor" href="#push"></a> PUSH</h2><p>进栈操作，以一个字为例，系统自动完成两步操作：</p><ol><li>SP ⬅ SP-2 //堆栈指针减2</li><li>(SP+1,SP) ⬅ SRC //将数据压入堆栈</li></ol><h2 id="pop"><a class="markdownIt-Anchor" href="#pop"></a> POP</h2><p>出栈操作，弹出一个字为例，系统自动完成两步操作：</p><ol><li>操作数 ⬅ SP</li><li>SP ⬅ SP+2<br>功能：将栈顶内容弹至某一寄存器，段寄存器(CS除外)或存储器</li></ol><h2 id="xchg"><a class="markdownIt-Anchor" href="#xchg"></a> XCHG</h2><p>XCHG OPR1, OPR2<br>功能：交换指令，OPR1，OPR2互换</p><h2 id="lea"><a class="markdownIt-Anchor" href="#lea"></a> LEA</h2><p>LEA Reg，Mem<br>功能：将一个内存变量的有效地址送给指定的寄存器</p><h2 id="类型转换指令"><a class="markdownIt-Anchor" href="#类型转换指令"></a> 类型转换指令</h2><h3 id="cbw-al-ax"><a class="markdownIt-Anchor" href="#cbw-al-ax"></a> CBW AL → AX</h3><ul><li>执行的操作：<ul><li>若(AL)的最高有效位为0则 AH = 00H</li><li>若(AL)的最高有效位为1则 AH = 0FFH</li></ul></li></ul><h3 id="cwd-ax-dxax"><a class="markdownIt-Anchor" href="#cwd-ax-dxax"></a> CWD AX → (DX,AX)</h3><ul><li>执行操作：<ul><li>若（AX）的最高有效位为0，则（DX)= 0000H</li><li>若（AX）的最高有效位为1，则（DX)= 0FFFFH</li></ul></li></ul><h1 id="算术指令"><a class="markdownIt-Anchor" href="#算术指令"></a> 算术指令</h1><h2 id="加法"><a class="markdownIt-Anchor" href="#加法"></a> 加法</h2><ul><li>重要的条件标志位：ZF，CF，SF，OF<ul><li>ZF，SF设置较为简单</li><li>CF：最高有效位是否有进位</li><li>OF：两个操作数符号(最高有效位)相同，结果与之相反则OF=1；否则OF=0</li></ul></li><li>INC对符号位无影响</li></ul><h3 id="add"><a class="markdownIt-Anchor" href="#add"></a> ADD</h3><p>功能：DST ⬅ DST+SRC</p><h3 id="adc"><a class="markdownIt-Anchor" href="#adc"></a> ADC</h3><p>功能：带进位的加法，DST ⬅ DST+SRC+CF</p><h3 id="inc"><a class="markdownIt-Anchor" href="#inc"></a> INC</h3><p>功能：OPR ⬅ OPR+1</p><h2 id="减法"><a class="markdownIt-Anchor" href="#减法"></a> 减法</h2><ul><li>CF：减数 &gt; 被减数，此时有借位，则CF=1；否则CF=0</li><li>OF：两个数符号(最高有效位)相反，而结果符号与减数相同，则OF=1；否则OF=0</li><li>DEC对符号位无影响</li></ul><h3 id="sub"><a class="markdownIt-Anchor" href="#sub"></a> SUB</h3><p>功能：功能：DST ⬅ DST-SRC</p><h3 id="dec"><a class="markdownIt-Anchor" href="#dec"></a> DEC</h3><p>功能：OPR ⬅ OPR-1</p><ul><li>对CF标志位无影响</li></ul><h3 id="neg"><a class="markdownIt-Anchor" href="#neg"></a> NEG</h3><p>功能：求补，每位求反(包括符号位)后加1</p><ul><li>OPR ⬅ 0 - OPR</li><li>因此，除了OPR=0，其他情况CF=1</li></ul><h3 id="cmp"><a class="markdownIt-Anchor" href="#cmp"></a> CMP</h3><p>功能：得到(OPR1-OPR2)的结果，改变标志位ZF或CF</p><h2 id="乘法"><a class="markdownIt-Anchor" href="#乘法"></a> 乘法</h2><ul><li>无符号乘法：MUL  SRC</li><li>有符号乘法：IMUL SRC</li><li>功能：<ul><li>若是字节数据相乘，<strong>AL和SRC相乘的结果放在AX</strong><ul><li>AX⬅AL*SRC</li></ul></li><li>若是字数据相乘，(AX)和SRC相乘得到的双字数据，<strong>高字放入DX，低字放入AX</strong><ul><li>DX,AX⬅AX*SRC</li></ul></li></ul></li><li><strong>乘法中OF，CF使用来判断相乘的结果是什么类型。</strong><blockquote><p>字节相乘的结果是字节还是字。OF=CF=0为字节，OF=CF=1为字<br>字相乘的结果是字还是双字。OF=CF=0为字，OF=CF=1为双字</p></blockquote></li></ul><h2 id="除法"><a class="markdownIt-Anchor" href="#除法"></a> 除法</h2><ul><li>无符号除法：DIV SRC</li><li>有符号除法：IDIV SRC</li><li>执行的操作(低位放商，高位放余数)：<ul><li>字节操作：<blockquote><p>(AL)⬅(AX)/(SRC)的商<br>(AH)⬅(AX)/(SRC)的余数</p></blockquote></li><li>字操作：<blockquote><p>(AX)⬅(DX,AX)/(SRC)的商<br>(DX)⬅(DX,AX)/(SRC)的余数</p></blockquote></li></ul></li><li><strong>对标志位没影响，但也会产生溢出</strong></li><li>可能产生编号为0的内部中断：除法错中断</li></ul><h1 id="逻辑指令"><a class="markdownIt-Anchor" href="#逻辑指令"></a> 逻辑指令</h1><h2 id="逻辑运算指令"><a class="markdownIt-Anchor" href="#逻辑运算指令"></a> 逻辑运算指令</h2><h3 id="and"><a class="markdownIt-Anchor" href="#and"></a> AND</h3><p>功能：两个操作数<strong>按位与操作</strong>，结果存入操作数<br>用途：该指令用于清除目的操作数中与源操作数中置0位对应的位</p><ul><li>DST ⬅ DST &amp; SRC</li></ul><h3 id="or"><a class="markdownIt-Anchor" href="#or"></a> OR</h3><p>功能：两个操作数<strong>按位或操作</strong>，结果放入操作数<br>用途：用于设置目的操作数中与源操作数置1位的对应位</p><ul><li>DST ⬅ DST | SRC</li></ul><h3 id="not"><a class="markdownIt-Anchor" href="#not"></a> NOT</h3><p>功能：按位取反</p><ul><li>DST ⬅ ~DST</li></ul><h3 id="xor"><a class="markdownIt-Anchor" href="#xor"></a> XOR</h3><p>功能：两个操作数<strong>按位异或</strong>，将结果放入操作数</p><ul><li>DST ⬅ DST⊕SRC</li></ul><h3 id="test"><a class="markdownIt-Anchor" href="#test"></a> TEST</h3><p>功能：两个操作数相与，但结果不保存，只根据其特征置条件码</p><ul><li>OPR1 &amp; OPR2</li></ul><h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3><ul><li>NOT不允许使用立即数，其他4条指令至少有一个操作数必须在寄存器中</li><li>NOT不影响符号位，其他4条指令 <strong>将CF，OF置0</strong> ，AF无定义，而SF，ZF，PF根据结果来设置</li></ul><h2 id="移位指令"><a class="markdownIt-Anchor" href="#移位指令"></a> 移位指令</h2><ul><li><strong>移位指令后面的数只能为 1，大于1的时候用cl</strong></li><li>如：shr xxx,cl；shr xxx,1</li></ul><h3 id="算术移位arithmetic"><a class="markdownIt-Anchor" href="#算术移位arithmetic"></a> 算术移位(arithmetic)</h3><p>算术移位指令有：算术左移<strong>SAL</strong>和算术右移<strong>SAR</strong></p><ul><li>指令格式为SAL/SAR  OPR,CL/Imm</li><li>受影响的标志位：CF、OF、PF、ZF和SF(AF无定义)</li><li>功能：<ul><li>算术左移SAL把目的操作数的低位向高位移，空出的低位补0</li><li>算术右移SAR把目的操作数的高位向低位移，空出的高位用最高位（符号位）填补</li><li>算术移位指令常用于带符号数*2或/2</li></ul></li></ul><h3 id="逻辑移位logical"><a class="markdownIt-Anchor" href="#逻辑移位logical"></a> 逻辑移位(logical)</h3><p>逻辑左移<strong>SHL</strong>和逻辑右移<strong>SHR</strong>它们的指令格式如下：<br>SHL/SHR　OPR, CL/Imm</p><ul><li>受影响的标志位：CF(移出放在CF)、OF、PF、SF和ZF（AF无定义）。</li><li>逻辑左移/右移指令只有它们的移位方向不同，移位后空出的位都补0</li><li>逻辑移位指令常用于无符号数*2或/2<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191212171032.png" class="lazyload"></li></ul><h3 id="循环移位rotate"><a class="markdownIt-Anchor" href="#循环移位rotate"></a> 循环移位(rotate)</h3><p>循环移位指令有：</p><ol><li>循环：左移<strong>ROL</strong>，右移<strong>ROR</strong>；</li><li>带进位循环：左移<strong>RCL</strong>，右移<strong>RCR</strong></li></ol><ul><li>指令的格式：ROL/ROR　OPR, CL/Imm</li><li>受影响的标志位：CF和OF</li><li>循环左移/右移指令只是移位方向不同，它们移出的位不仅要进入CF，而且还要填补空出的位。</li><li>带进位循环移动将CF加入循环中</li></ul><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>无符号数：逻辑移位<br>有符号数：算术移位</p><ul><li>逻辑左移和算术左移一致，均把移出的放在CF，末位补0</li><li>逻辑右位的方法是逻辑左移镜像</li><li>算术右移移出的放在CF，但是首位补符号位，而不是补0</li></ul><h1 id="串处理指令"><a class="markdownIt-Anchor" href="#串处理指令"></a> 串处理指令</h1><h2 id="方向标志"><a class="markdownIt-Anchor" href="#方向标志"></a> 方向标志</h2><p>执行串处理指令时会根据DF(direction flag)来使地址自动增加/减少</p><ul><li><strong>CLD(DF=0)增加</strong> 和 <strong>STD(DF=1)减少</strong></li></ul><h2 id="重复前缀指令rep"><a class="markdownIt-Anchor" href="#重复前缀指令rep"></a> 重复前缀指令REP</h2><p>重复前缀指令是重复其后的字符串操作指令，<strong>重复的次数由CX来决定</strong>。</p><ul><li>一般格式为：REP　MOVS / STOS / LODS</li></ul><h2 id="相等重复前缀指令reperepz"><a class="markdownIt-Anchor" href="#相等重复前缀指令reperepz"></a> 相等重复前缀指令REPE(REPZ)</h2><p>重复条件：CX != 0 &amp;&amp; ZF = 1</p><h2 id="不等重复前缀指令repnerepnz"><a class="markdownIt-Anchor" href="#不等重复前缀指令repnerepnz"></a> 不等重复前缀指令REPNE(REPNZ)</h2><p>重复条件：CX != 0 &amp;&amp; ZF = 0</p><h2 id="串比较指令-cmps"><a class="markdownIt-Anchor" href="#串比较指令-cmps"></a> 串比较指令 CMPS</h2><ul><li>语句格式：<ul><li>CMPSB——字节串比较</li><li>CMPSW——字串比较</li></ul></li><li>功能：将SI所指的源串中的一个字节（或字）存储单元中的数据与DI所指的目的串中的一个字节（或字）存储单元中的数据相减，并<strong>根据相减的结果设置标志，但结果并不保存</strong></li></ul><h1 id="控制转移指令"><a class="markdownIt-Anchor" href="#控制转移指令"></a> 控制转移指令</h1><h2 id="无条件转移指令"><a class="markdownIt-Anchor" href="#无条件转移指令"></a> 无条件转移指令</h2><p>包括：<strong>JMP</strong>、<strong>子程序调用和返回</strong>、<strong>中断的调用和返回指令</strong></p><h2 id="条件转移指令"><a class="markdownIt-Anchor" href="#条件转移指令"></a> 条件转移指令</h2><p>分为三类:</p><ol><li>基于<strong>无符号数</strong>的条件转移指令</li><li>基于<strong>有符号数</strong>的条件转移指令</li><li>基于<strong>特殊算术标志位</strong>的条件转移指令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JXX  LABEL  ;条件满足：转移，(IP)⬅(IP)+位移量</span><br><span class="line">            ;条件不满足，顺序执行</span><br></pre></td></tr></table></figure><ul><li>操作数LABEL采用短转移，成为相对寻址方式</li><li>JXX不影响标志位，但要利用标志位。</li></ul><h3 id="根据单个条件标志的设置情况转移"><a class="markdownIt-Anchor" href="#根据单个条件标志的设置情况转移"></a> 根据单个条件标志的设置情况转移</h3><table><thead><tr><th>指令助忆符</th><th>检测转移的条件</th><th>功能描述</th></tr></thead><tbody><tr><td>JZ(JE)</td><td>ZF=1</td><td>结果为零或相等则转移</td></tr><tr><td>JNZ(JNE)</td><td>ZF=0</td><td>结果不为0或不等则转移</td></tr><tr><td>JS/JNS</td><td>SF=1/SF=0</td><td>结果为负/正则转移</td></tr><tr><td>JO/JNO</td><td>OF=1/OF=0</td><td>结果溢出/不溢出则转移</td></tr><tr><td>JP/JNP</td><td>PF=1/PF=0</td><td>奇偶位为1/0则转移</td></tr></tbody></table><h3 id="无符号数的条件转移"><a class="markdownIt-Anchor" href="#无符号数的条件转移"></a> 无符号数的条件转移</h3><ul><li>Below，Equal，Above</li></ul><table><thead><tr><th>指令助忆符</th><th>检测转移的条件</th><th>功能描述</th></tr></thead><tbody><tr><td>JB/JNAE</td><td>CF=1</td><td>小于时，或进位为1则转移</td></tr><tr><td>JNB/JAE</td><td>CF=0</td><td>不小于，或进位为0转移</td></tr><tr><td>JBE/JNA</td><td>CFvZF=1</td><td>小于等于则转移</td></tr><tr><td>JNBE/JA</td><td>CF^ZF=0</td><td>不小于等于,即大于,则转移</td></tr></tbody></table><h3 id="有符号数的条件转移"><a class="markdownIt-Anchor" href="#有符号数的条件转移"></a> 有符号数的条件转移</h3><ul><li>Less，Equal，Greater</li></ul><table><thead><tr><th>指令助忆符</th><th>检测转移的条件</th><th>功能描述</th></tr></thead><tbody><tr><td>JL/JNGE</td><td>SF⊕OF=1</td><td>小于则转移</td></tr><tr><td>JNL/JGE</td><td>SF⊕OF=1</td><td>不小于，即大于等于转移</td></tr><tr><td>JLE/JNG</td><td>ZF=1 or SF!=OF</td><td>小于等于则转移</td></tr><tr><td>JG/JNLE</td><td>ZF=0 and SF=OF</td><td>不小于等于,即大于,则转移</td></tr></tbody></table><h2 id="循环指令"><a class="markdownIt-Anchor" href="#循环指令"></a> 循环指令</h2><h3 id="loop"><a class="markdownIt-Anchor" href="#loop"></a> LOOP</h3><ul><li>指令格式：LOOP 短标号</li><li>执行过程：如果CX ≠ 0，转向“标号”所指向的指令，否则，终止循环，执行该指令的下一条指令</li><li>说明：使用LOOP可以代替以下两条指令：<blockquote><p>DEC  CX<br>JNE  短标号</p></blockquote></li></ul><h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3><ul><li>相等/为0循环指令 LOOPE/LOOPZ</li><li>不相等/不为零循环指令LOOPNE/LOOPNZ</li></ul><h2 id="子程序调用和返回"><a class="markdownIt-Anchor" href="#子程序调用和返回"></a> 子程序调用和返回</h2><h3 id="调用指令-call"><a class="markdownIt-Anchor" href="#调用指令-call"></a> 调用指令 CALL</h3><p>类似JMP指令，但是不同于JMP，CALL指令需要保存返回地址(将其入栈)</p><h3 id="返回指令-ret"><a class="markdownIt-Anchor" href="#返回指令-ret"></a> 返回指令 RET</h3><p>将栈内保存的地址弹出，折返调用该子程序的位置</p><h2 id="中断的调用和返回指令"><a class="markdownIt-Anchor" href="#中断的调用和返回指令"></a> 中断的调用和返回指令</h2><h3 id="中断指令-int"><a class="markdownIt-Anchor" href="#中断指令-int"></a> 中断指令 INT</h3><ul><li>一般格式：INT TYPE</li><li>其中：立即数TYPE是一个0~0FFH范围内的整数。</li><li>指令执行的步骤：<ol><li>把标志寄存器压栈，清除标志位IF和TF；</li><li>把代码段寄存器CS和指令指针寄存器IP的内容压栈；</li><li>IP ← TYPE<em>4，CS ← TYPE</em>4+2</li></ol></li></ul><h3 id="溢出指令-into"><a class="markdownIt-Anchor" href="#溢出指令-into"></a> 溢出指令 INTO</h3><p>当标志位OF为1时，引起中断。</p><h3 id="中断返回指令-iret"><a class="markdownIt-Anchor" href="#中断返回指令-iret"></a> 中断返回指令 IRET</h3><ul><li>当一个中断服务程序执行完毕时，CPU将恢复被中断的现场，返回到引起中断的程序中。</li><li>该指令执行的过程基本上是INT指令的逆过程:<ol><li>从栈顶弹出内容送入IP</li><li>再从新栈顶弹出内容送入CS</li><li>再从新栈顶弹出内容送入标志寄存器</li></ol></li></ul><h2 id="中断和子程序的比较"><a class="markdownIt-Anchor" href="#中断和子程序的比较"></a> 中断和子程序的比较</h2><ul><li>相同之处：暂停当前程序的执行，转而执行另一程序段，当该程序段执行完时，CPU都自动恢复原程序的执行。</li><li>不同之处：<ol><li>调用：子程序人为调用；中断不可预见(除了INT引起的中断)</li><li>实现方式：子程序调用是用CALL指令来实现的，但没有调用中断的指令，只有发出中断请求的事件（指令INT是发出内部中断信号，而不要理解为调用中断服务程序）；</li><li>返回方式：子程序RET；中断IRET</li><li>在通常情况下，子程序是由应用系统的开发者编写的，而中断服务程序是由系统软件设计者编写的。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承与派生</title>
      <link href="/2019/12/12/%E5%AD%A6%E4%B9%A0/C++%E5%AD%A6%E4%B9%A0/%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/"/>
      <url>/2019/12/12/%E5%AD%A6%E4%B9%A0/C++%E5%AD%A6%E4%B9%A0/%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<ul><li>继承的三种方式：<ol><li>public</li><li>private (默认)</li><li>protected</li></ol></li></ul><hr><ul><li>三种继承方式的不同<table><thead><tr><th>继承方式</th><th>public</th><th>protected</th><th>private</th></tr></thead><tbody><tr><td>public</td><td>public</td><td>protected</td><td>不可访问</td></tr><tr><td>private</td><td>private</td><td>private</td><td>不可访问</td></tr><tr><td>protected</td><td>protected</td><td>protected</td><td>不可访问</td></tr></tbody></table></li><li>tips：<ul><li>xx继承的话，访问权限必须 &lt;= xx</li><li>基类的private均不可访问</li><li>protected 成员不能在类外被访问</li></ul></li></ul><hr><ul><li>类里定义的默认成员变量和函数均为private</li><li>类默认为public</li><li>全局成员默认public</li></ul><hr><ul><li>派生类的构成<ol><li>从基类接受成员</li><li>调整从基类接受的成员。</li></ol><ul><li>变化访问权限</li><li>重写，同名即覆盖</li></ul><ol start="3"><li>新增成员</li></ol></li></ul><hr><ul><li>执行派生类构造函数的顺序：<ol><li>调用 <strong>基类</strong> 构造函数，只与 <strong>声明的顺序</strong> 有关，和派生类中的调用顺序无关</li><li>调用 <strong>子对象</strong> (对象中的对象) 构造函数</li></ol><ul><li>调用方法：<strong>子对象名</strong> (参数表)，没有显式调用的话则为默认构造函数</li></ul><ol start="3"><li>再执行 <strong>派生类</strong> 的构造函数本身</li></ol></li></ul><hr><ul><li>虚基类(virtual)的作用：在继承间接共同基类时，只保存<strong>一份成员</strong><ul><li>C++编译系统只执行 <strong>最后的派生类对虚基类的构造函数的调用</strong> ，而忽略虚基类其他的派生类。所以我们可以直接显式的调用虚基类的构造函数。</li></ul></li><li>虚基类和抽象类的区别<ul><li>虚基类式相对它的派生类而言，它可以是个普通的类，被虚继承才叫做虚基类</li><li>而抽象类是类中有一个以上的纯虚函数，只能用于继承，不能生成对象，但是能定义对象指针，然后指向派生类对象，实现多态性</li></ul></li></ul><hr><ul><li>基类和派生类的转换<ul><li>只有public继承的类型才是真正的子类型</li><li>只能用 <strong>派生类对象对基类对象</strong> 赋值，反之不允许<ul><li>因为基类有的派生类都有，而派生类有的基类不一定有</li></ul></li><li>同一基类的不同派生类对象之间不能赋值</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态性与虚函数</title>
      <link href="/2019/12/11/%E5%AD%A6%E4%B9%A0/C++%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E6%80%81%E6%80%A7%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2019/12/11/%E5%AD%A6%E4%B9%A0/C++%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E6%80%81%E6%80%A7%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>静态多态性：函数重载</li><li>动态多态性：运行阶段调用被派生类重写的函数，通过虚函数实现</li></ul><hr><ul><li>派生类对象可以代替基类对象向基类对象的引用初始化或赋值<ul><li>派生类的对象可以初始化基类对象</li></ul></li></ul><hr><ul><li>虚函数：基类中声明函数是 <strong>虚拟的</strong> ，并不是实际存在的函数，然后在 <strong>派生类中才正式定义</strong> 此函数<ul><li>但是，在基类中也可以写出定义，以供基类对象调用，即虚函数可以有定义内容</li><li>在基类中没有定义的函数可以作为纯虚函数声明</li></ul></li></ul><hr><ul><li>纯虚函数：基类对象不会使用该函数，返回值也没有意义，可以只给出函数的原型，并在末尾加上 <em>“=0”</em><ul><li>virtual 函数类型 函数名 (参数表列) = 0；</li></ul></li></ul><hr><ul><li>抽象类<ul><li>定义该类的唯一目的是：<strong>用它作为基类去建立派生类</strong></li><li>凡是包含 <strong>纯虚函数</strong> 的类都是抽象类</li><li>不能定义对象，但是能定义对象指针</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOS-21H</title>
      <link href="/2019/12/11/%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96/DOS-21H/"/>
      <url>/2019/12/11/%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96/DOS-21H/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AH,xxH</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><p>常用Dos功能调用：</p><ol><li><p><strong>单字符输入（01H号调用）</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AH,01H</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><ul><li>从键盘输入字符的ASCII码送入寄存器AL中，并送显示器显示</li></ul></li><li><p><strong>单字符显示（02H号调用）</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV DL,待显示字符的ASCII码</span><br><span class="line">MOV AH,02H</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><ul><li>将DL寄存器中的字符送显示器显示</li></ul></li><li><p><strong>打印输出（05H号调用）</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV DL,待打印字符的ASCII码</span><br><span class="line">MOV AH,05H</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><ul><li>将DL寄存器中的字符送打印机打印</li></ul></li><li><p><strong>结束调用（4CH号调用）</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AH,4CH</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><ul><li>终止当前程序并返回调用程序</li></ul></li><li><p><strong>显示字符串（09H号调用）</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LEA DX,待显示字符串的首偏移地址</span><br><span class="line">MOV AH,09H</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><ul><li>将当前数据区(DX为首地址)中以 <strong>‘＄’</strong> 结尾的字符串送显示器显示，一般把缓冲区设为全 <strong>‘＄’</strong></li></ul></li><li><p><strong>字符串输入（0AH号调用）</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LEA DX,缓冲区的首偏移地址</span><br><span class="line">MOV AH,0AH</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><ul><li>从键盘上输入一字符串到用户定义的输入缓冲区(DX为首地址)中，并送显示器显示</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编小知识点</title>
      <link href="/2019/12/11/%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96/"/>
      <url>/2019/12/11/%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<ul><li>bit(比特)：一个二进制位，电子计算机的最小的信息单元</li><li>Byte(字节)：一个字节，八个二进制位</li><li>Word(字)：两个字节，分为高位字节和地位字节，十六个二进制位</li></ul><hr><ul><li>寻址能力：$ 2 ^ N(N为地址线宽度) $</li><li>传输能力：数据线宽度</li></ul><hr><ul><li>通用寄存器：通常用来存放一般性数据<ul><li>16位：AX, BX, CX, DX</li><li>以上四个可以拆成两个8位寄存器，例如：AX = AH + AL，拆分使用的话，AH和AL是完全独立的寄存器，两者的数据不相关</li></ul></li><li>为了区分不同数制：<ul><li>十六进制：末尾加上H；如果首位位字母，补0</li><li>十进制：什么也不加</li><li>二进制：末尾加上B</li></ul></li></ul><hr><ul><li>8086CPU给出物理地址的方法<ul><li><strong>物理地址 = 段地址 x 16 + 偏移地址</strong><ul><li>上式合成20位地址，1MB的寻址能力</li><li>本质含义：用一个基础地址(段地址x16)和一个相对于基础地址的偏移地址相加。给出物理地址</li><li>段地址 x 16 ：将段地址左移4位即可</li></ul></li></ul></li><li>8086CPU可以分成16个段，每个段有64KB，总共1MB</li><li>段的概念：<ul><li>内存并没有被划分成一个一个段，而只是将<strong>若干地址连续的内存单元<em>看作</em>一个段</strong></li></ul></li></ul><hr><ul><li><p>段寄存器：提供段地址</p><ul><li>16位：CS(代码)，DS(数据)，SS(堆栈)，ES(附加)</li></ul></li><li><p>CS和IP为8086CPU中两个<strong>最关键</strong>的寄存器：</p><ul><li>CS为代码段寄存器</li><li>IP为指令指针寄存器</li><li>8086机中，任何时刻，CPU将 <strong>CS:IP (CS*16 + IP)</strong> 指向的内容当作指令执行。<ul><li>读取一条指令后，<strong>IP = IP + 所读取指令长度</strong>，从而指向下一条指令</li></ul></li><li>要通过Jump指令修改，普通的MOV指令不能修改</li></ul></li></ul><hr><ul><li>内存中字的存储：高高低低<ul><li>高地址放高位，低地址放低位</li></ul></li><li>字单元：存放一个字型数据(16位)的内存单元</li><li>起始地址为N的字单元成为N地址字单元</li></ul><hr><ul><li>DS和[address]<ul><li>DS为数据段寄存器，存放数据的段地址</li><li>address为偏移地址,[address]表示一个偏移地址为address的内存单元</li></ul></li></ul><hr><ul><li>SS和SP<ul><li>SS为栈顶的段寄存器</li><li>SP为指向栈底的指针，可以修改</li><li>任何时刻，<strong>SS:SP指向栈顶元素</strong></li></ul></li><li>8086CPU只记录栈顶的位置，栈空间的大小要自己管理</li><li>POP和PUSH指令<strong>只修改SP指针</strong></li></ul><blockquote><p>初始化栈的操作<br>mov ax,1000H<br>mov ss,ax<br>mov sp,0010H<br>;设置栈顶的偏移地址，因栈为空，SP指向栈最底部单元的下一单元</p></blockquote><hr><ul><li>子程序格式：</li></ul><blockquote><p>过程名     PROC      [NEAR/FAR]<br>┆<br>过程名     ENDP</p></blockquote><ul><li>其中PROC表示过程定义开始，ENDP表示过程定义结束。过程名是过程入口地址的符号表示</li><li>一般过程名同标号一样，具有三种属性，即<strong>段属性、偏移地址属性以及类型属性</strong>（NEAR 或 FAR)</li><li>过程属性确定原则：<ul><li>NEAR：在同一代码段中</li><li>FAR：在不同代码段中</li><li>主程序MAIN应该为FAR属性</li></ul></li><li>CALL和RET完成调用和返回<ul><li>CALL调用时使返回地址入栈</li><li>RET时应能使返回地址正确出栈</li></ul></li><li>保护现场和恢复现场<ul><li>利用堆栈来实现</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PROGPROC</span><br><span class="line">PUSHAX</span><br><span class="line">PUSH BX</span><br><span class="line">        PUSHCX</span><br><span class="line">PUSHDX ;保护现场</span><br><span class="line"></span><br><span class="line">        POPDX</span><br><span class="line">POPCX</span><br><span class="line">POPBX</span><br><span class="line">POPAX  ;恢复现场</span><br><span class="line">RET    ;返回断点处</span><br><span class="line">PROCENDP</span><br></pre></td></tr></table></figure><ul><li>参数传递方法<ol><li>通过寄存器传递参数</li><li>如果过程和调用在同一源文件（同一程序模块中），则过程可以直接访问模块中的变量</li><li>通过地址表传递参数</li><li>通过堆栈传送参数或参数地址</li><li>多个模块间参数传递</li></ol><blockquote><ol><li>public 符号,符号……</li></ol><ul><li>说明其后的符号是全局符号。全局符号能被其他模块引用。</li></ul><ol start="2"><li>extrn 符号:类型,符号:类型……</li></ol><ul><li>说明在本模块中需要引用的、由其他模块定义的符号，即外部符号。</li></ul></blockquote></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和对象</title>
      <link href="/2019/12/10/%E5%AD%A6%E4%B9%A0/C++%E5%AD%A6%E4%B9%A0/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/12/10/%E5%AD%A6%E4%B9%A0/C++%E5%AD%A6%E4%B9%A0/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<ul><li>声明对象的两种方式：<ul><li>Object obj(参数表/为空);<ul><li>在栈上</li></ul></li><li>Object *pObj = new Object(参数表/为空);<ul><li>在堆上，这个要记得delete释放</li></ul></li></ul></li></ul><hr><ul><li>默认构造函数种类：<ol><li>没有任何参数，如：Object();</li><li>所有参数都有默认值，如：Object(int x = 0);</li></ol></li><li>两者不能同时共存，一个类只能有一个默认构造函数</li></ul><hr><ul><li>只能有一个析构函数<ul><li>析构函数的作用：<br>不是删除对象，而是撤销对象占用的内存<strong>之前</strong>，完成<strong>一些清理工作</strong></li><li>调用时间：<br>生命期结束时，和变量类似</li></ul></li></ul><hr><ul><li>构造函数和析构函数的调用顺序：<ol><li>先构造的后析构，后构造的先析构<br>类似于栈，先进后出</li><li>子类构造函数必须调用父类的构造函数<br>父类有无参构造函数，会自动调用<br>父类无无参构造函数，必须显式调用，否则报错（Java也是）</li><li>虚基类的构造函数最先调用</li></ol></li></ul><hr><ul><li>对于派生类的构造函数，在定义对象时构造函数的执行顺序为：<ol><li>虚基类的构造函数</li><li>基类的构造函数</li><li>成员对象的构造函数</li><li>派生类本身的构造函数</li></ol></li><li>若一个子类虚继承了两个父类，这两个父类有着共同父类，那么调用构造函数的时候，只调用一次，因为虚继承只保留一份成员</li><li>一个对象能含有多个子对象，因为有可能同一个构造函数调用了多次</li></ul><hr><ul><li>声明对象数组时候，调用n次构造函数(与Java不同)，声明抽象类数组的时候，应该为Object *objs[n]</li></ul><hr><ul><li>编译器不会自动生成默认构造函数，除非迫不得已<blockquote><p>例如：基类有构造函数，而派生类没有，编译器才会生成一个派生类的构造函数</p></blockquote></li></ul><hr><ul><li>构造函数不能为虚函数，析构函数可以是</li></ul><hr><ul><li>对象指针就是对象的起始空间<br>声明对象指针时，注意：Object *p()和(Object *p)()不一样，结合优先级<br>第一个返回一个void指针，等同于void(Object *(p()))<br>第二个才是返回一个对象指针</li></ul><hr><ul><li>常对象，常对象成员：<ol><li>常对象：Object const obj(…)<br>能访问数据成员，但是不能修改<br>只能访问常成员函数</li><li>常数据成员：const int i<br>只能用构造函数的参数初始化，其他任何函数都不能修改</li><li>常成员函数：void get() const //const放在函数名和括号后面<br>可以引用，但是不能改变值</li></ol></li></ul><hr><ul><li>指向对象的<strong>常指针</strong> 和 指向<strong>常对象</strong>的指针<ul><li>类名 * const 指针名，不能改变指向</li><li>const 类名 *指针名，不能改变对象的值<ul><li>一个<strong>常对象</strong>只能用<em>常对象指针</em>指向</li><li>常对象指针也可以指向别的值，但是不能改变该对象</li></ul></li><li>常对象只能调用常成员函数</li></ul></li></ul><hr><ul><li>this指针：指向<strong>本类对象</strong>的指针，它的值是当前被调用的成员函数所在的对象的<strong>起始地址</strong><ul><li>名字固定</li><li>区分对象</li></ul></li></ul><hr><ul><li>复制构造函数：Object(const Object &amp; obj)<ul><li>Object obj1 = obj2; //复制构造函数默认被调用</li><li>return obj; //复制构造函数也被调用，生成一个临时对象</li><li>void fun(Object &amp;obj); //此时也调用了复制拷贝函数，生成了一个临时对象</li></ul></li></ul><hr><ul><li>临时对象<ol><li>以值的方式给函数传参</li><li>类型转换</li><li>函数需要返回对象时</li></ol></li></ul><hr><ul><li>左值和右值<ul><li><p>区别在于：能否获取地址</p><blockquote><p>左值：最早的c++中，左值的定义表示的是可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值。但是修饰符const的出现使得可以声明如下的标识符，它可以取得地址，但是没办法对其进行赋值：</p></blockquote><blockquote><p>右值：右值表示无法获取地址的对象，有常量值、函数返回值、Lambda表达式等。无法获取地址，但不表示其不可改变，当定义了右值的右值引用时就可以更改右值。</p></blockquote></li></ul></li></ul><hr><ul><li>静态成员（static）<ul><li>静态数据成员<ul><li>所有对象公用</li><li>可以初始化，但是只能<strong>在类外初始化</strong>，不能用构造函数初始化，如果时private，也要在类外，在对应的cpp和h文件中初始化<blockquote><p>数据类型 类名::静态数据成员 = 初值; //初始化时不用加static</p></blockquote></li></ul></li><li>静态成员函数<ul><li><strong>不能访问非静态成员</strong></li><li>类的一部分，而不是对象的一部分</li></ul></li></ul></li></ul><hr><ul><li>友元函数（friend）<ul><li>可以访问这个类的<strong>private成员</strong></li><li>可以为普通函数或者成员函数<blockquote><p>还有一个友元类，友元类可以访问该类中所有成员</p></blockquote></li><li>破坏封装性和隐蔽性，但是能提高程序效率</li></ul></li></ul><hr><ul><li>类模板（template）<ul><li>template &lt;typename/class T&gt;</li><li>类模板是类的抽象，类是类模板的实例<blockquote><p>类模板 ⬅ 类 ⬅ 对象</p></blockquote></li><li>类模板函数的声明和定义要放在一起，否则会链接错误</li></ul></li></ul><hr><ul><li>转换构造函数：只能有 <strong>一个形参</strong>，将该形参转换为对象的某个数据，自定义如何转换</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径和最小生成树</title>
      <link href="/2019/11/26/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%92%8C%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2019/11/26/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%92%8C%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>学习数据结构的时候一直忘记了区分这两个，现在正是用博客记录一下。</p><h1 id="一-区别"><a class="markdownIt-Anchor" href="#一-区别"></a> 一、区别</h1><ul><li>最小生成树能保证整个拓扑图的 <strong>所有路径权值之和最小</strong> ，但是不能保证 <strong>任意两点间是最短路径</strong></li><li>最短路径是从 <strong>一点</strong> 出发，到达目的地的路径权值和最小</li></ul><h1 id="二-实现算法"><a class="markdownIt-Anchor" href="#二-实现算法"></a> 二、实现算法</h1><h2 id="最短路径"><a class="markdownIt-Anchor" href="#最短路径"></a> 最短路径</h2><h3 id="dijkstra算法"><a class="markdownIt-Anchor" href="#dijkstra算法"></a> Dijkstra算法</h3><ol><li>指定一个节点为初始点，将其看作一个 <strong>集合S</strong> ，剩余的点看作 <strong>另一个集合U</strong></li><li>根据初始点，求出到其他点的距离 <strong>d[i]</strong>（若相邻，则为边的权值；若不相邻，则为 ∞ ）</li><li>选择最小的<strong>d[i]</strong>，并将其<strong>加入集合S</strong>，在<strong>U中去除</strong>它，暂时用x标记</li><li>再根据x，<strong>更新</strong>跟x相邻点y的d[y]的值：<strong>d[y] = min{ d[y], d[x] + w[x][y] }</strong>，则个操作有可能把距离调小，也有可能没变化，因而称为<strong>松弛操作</strong></li><li>重复3，4两步操作，直至<strong>集合S包括所有的点</strong>，即<strong>集合U为空集</strong>时，求得初始点到其他所有点的最短路径</li></ol><ul><li>时间复杂度 <strong>O(e*logv)</strong></li></ul><h2 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树"></a> 最小生成树</h2><h3 id="prim算法"><a class="markdownIt-Anchor" href="#prim算法"></a> Prim算法</h3><ol><li>选择任意节点为起始点，加入<strong>点集合V</strong>，初始化<strong>边集合E为空</strong></li><li>选取<strong>集合V中的点</strong>到<strong>剩余节点</strong>的<strong>最小权值边</strong>，加入E，然后把该边连接的节点加入V</li><li>重复以上步骤，直至<strong>集合V包括所有的节点</strong></li><li>所求的 <strong>{V，E}</strong> 就是最小生成树</li></ol><ul><li>时间复杂度取决于图的存储方式<ul><li>邻接矩阵 <strong>O(v^2)</strong></li><li>邻接表 <strong>O(e*logv)</strong></li></ul></li></ul><h3 id="kruskal算法"><a class="markdownIt-Anchor" href="#kruskal算法"></a> Kruskal算法</h3><ol><li>新建图 <strong>{V,E}</strong>，<strong>V有原来图的所有顶点</strong>，而 <strong>E为空集</strong>，因而每个节点自成一个连通分量</li><li>在原图的边中选择权值最小的边<ol><li>若该边依附的顶点落在新建图中 <strong>不同的连通分量</strong>，则将此边加入E</li><li>否则舍去此边，寻找下一条权值最小的边</li></ol></li><li>以此类推，直至新建图 <strong>所有的节点在同一连通分量</strong></li></ol><ul><li>时间复杂度 <strong>O(eloge)</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串运算</title>
      <link href="/2019/11/10/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%90%E7%AE%97/"/>
      <url>/2019/11/10/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>实现字符串的加，乘法</p><a id="more"></a><p>一. 加法利用双指针，和人工的竖式运算相同<br>二. 乘法有两个版本：</p><ol><li>版本一为竖式运算普通版</li><li>版本二是优化版的竖式运算。<br>该算法是通过两数相乘时，乘数某位与被乘数某位相乘，与产生结果的位置的规律来完成。具体规律如下：<ul><li>乘数 num1 位数为 M，被乘数 num2 位数为 N， num1 x num2 结果 ans 最大总位数为 M+N，最小位数为 M+N-1</li><li>num[i] x num[j] 的结果 temp (为两位数，“0x&quot;或者&quot;xy”),其第一位位于 ans[i+j]，第二位位于 ans[i+j+1]</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span></span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">int</span> i = num1.length()-<span class="number">1</span>, j = num2.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = n1 + n2 + carry;</span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">        sb.append(temp % <span class="number">10</span>);</span><br><span class="line">        i--;j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry==<span class="number">1</span>) sb.append(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>))   <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    String ans = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num2.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = num2.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num2.length()-i-<span class="number">1</span>;j++)<span class="comment">//补零</span></span><br><span class="line">            sb.append(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = num1.length() - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--)&#123;<span class="comment">//计算 n2*num1</span></span><br><span class="line">            <span class="keyword">int</span> n1 = num1.charAt(k) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = n1 * n2 + carry;</span><br><span class="line">            sb.append(temp%<span class="number">10</span>);</span><br><span class="line">            carry = temp/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>) sb.append(carry);</span><br><span class="line">        ans = addStrings(ans, sb.reverse().toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">multiplyPlus</span><span class="params">(String num1, String num2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>))   <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[num1.length() + num2.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = num2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(n1 == <span class="number">0</span> || n2 ==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = n1 * n2 + ans[i+j+<span class="number">1</span>];</span><br><span class="line">            ans[i+j+<span class="number">1</span>] = temp % <span class="number">10</span>;</span><br><span class="line">            ans[i+j] += temp / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">        <span class="comment">//两个数相乘，位数是n+m(全9)或者n+m-1(只有一个1)，因此只有i=0的时候，才有可能抛弃一位0</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ans[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        result.append(ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长的回文子串</title>
      <link href="/2019/11/09/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E6%9C%80%E9%95%BF%E7%9A%84%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2019/11/09/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E6%9C%80%E9%95%BF%E7%9A%84%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串 s，找到 s 中最长的回文子串。</p><a id="more"></a><h1 id="暴力法"><a class="markdownIt-Anchor" href="#暴力法"></a> 暴力法</h1><p>找出所有的子串，判断它是不是回文串</p><ul><li>时间复杂度O(n^3)</li></ul><h1 id="暴力法优化动态规划"><a class="markdownIt-Anchor" href="#暴力法优化动态规划"></a> 暴力法优化(动态规划)</h1><p>首先定义一个二维数组 <em>P(i,j)</em>,<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191110165844.png" class="lazyload"><br>接下来<br>P(i,j) = (P(i+1,j-1) &amp;&amp; S[i]==S[j])<br>因此，我们不需要去判断S[i,j]是不是回文串，而是通过P(i+1,j-1)和S[i]==S[j]判断，这样时间复杂度减少了O(n)，利用动态规划，空间换时间</p><p>求 长度为 1 和长度为 2 的 P(i,j) 时不能用上边的公式，因为我们代入公式后会遇到 P[i][j] 中 i &gt; j 的情况，比如求 P[1][2] 的话，我们需要知道 P[1+1][2-1]=P[2][1]P[1+1][2−1]=P[2][1] ，而 P[2][1]P[2][1] 代表着 S[2,1] 是不是回文串，显然是不对的，所以我们需要单独判断。</p><p>所以我们先初始化长度是 1 的回文串的 P[i,j]，这样利用上边提出的公式 P(i,j)=(P(i+1,j−1)&amp;&amp;S[i]==S[j])，然后两边向外各扩充一个字符，长度为 3 的，为 5 的，所有奇数长度的就都求出来了。<br>同理，先初始化长度为2的回文串，然后所有偶数长度也能求出</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] P = <span class="keyword">new</span> <span class="keyword">boolean</span>[length][length];</span><br><span class="line">    String ans = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> ansLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= length; len++)&#123;<span class="comment">//遍历所有长度的子串，1~length</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; length; start++)&#123;</span><br><span class="line">            <span class="keyword">int</span> end = start + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(end &gt;= length)<span class="comment">//越界</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            P[start][end] = (len==<span class="number">1</span> || len == <span class="number">2</span> || P[start+<span class="number">1</span>][end-<span class="number">1</span>]) &amp;&amp; s.charAt(start) == s.charAt(end);</span><br><span class="line">            <span class="keyword">if</span>(len&gt;ansLen &amp;&amp; P[start][end])&#123;</span><br><span class="line">                ansLen = len;</span><br><span class="line">                ans = s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="中心扩散法"><a class="markdownIt-Anchor" href="#中心扩散法"></a> 中心扩散法</h1><p>事实上，只需使用恒定的空间，我们就可以在O(n^2)的时间内解决这个问题。</p><p>我们观察到回文中心的两侧互为镜像。因此，回文可以从它的中心展开，并且只有 2n−1 个这样的中心。</p><p>你可能会问，为什么会是 2n−1 个，而不是 n 个中心？原因在于所含字母数为偶数的回文的中心可以处于两字母之间的间隙（例如 “abba” 的中心在两个 ‘b’ 之间）。</p><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);<span class="comment">//字符</span></span><br><span class="line">        <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);<span class="comment">//间隙</span></span><br><span class="line">        <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">            start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            end = i + len / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//left == right，则以字符为中心，传出一个奇数</span></span><br><span class="line">    <span class="comment">//反之，以i，j的间隙为中心，传出一个偶数</span></span><br><span class="line">    <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">    <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">        L--;</span><br><span class="line">        R++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里要小心，跳出 while 循环时，已经不满足 s.charAt(L) == s.charAt(R)</span></span><br><span class="line">    <span class="comment">// 因此L，R与实际匹配的位置多了一次自增自减，因此要 R-L-1,不然原本应该为 R-L+1</span></span><br><span class="line">    <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="manacher马拉车-算法"><a class="markdownIt-Anchor" href="#manacher马拉车-算法"></a> Manacher(马拉车) 算法</h1><p>TBD</p>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode LCP</title>
      <link href="/2019/11/06/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/LeeCode-LCP/"/>
      <url>/2019/11/06/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/LeeCode-LCP/</url>
      
        <content type="html"><![CDATA[<p>LeetCode LCP</p><a id="more"></a><h1 id="lcp1"><a class="markdownIt-Anchor" href="#lcp1"></a> LCP1</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>小A和小B在玩猜数字。小B每次从 1, 2, 3 中随机选择一个，小A每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回小A猜对了几次？</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">game</span><span class="params">(<span class="keyword">int</span>[] guess, <span class="keyword">int</span>[] answer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*int count = 0;</span></span><br><span class="line"><span class="comment">    for(int i = 0 ; i &lt; 3; i++)</span></span><br><span class="line"><span class="comment">        if(guess[i] == answer[i]) count++;</span></span><br><span class="line"><span class="comment">    return count;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用循环时间复杂度较高</span></span><br><span class="line">    <span class="keyword">return</span> (guess[<span class="number">0</span>]==answer[<span class="number">0</span>]?<span class="number">1</span>:<span class="number">0</span>)+(guess[<span class="number">1</span>]==answer[<span class="number">1</span>]?<span class="number">1</span>:<span class="number">0</span>)+(guess[<span class="number">2</span>]==answer[<span class="number">2</span>]?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lcp2"><a class="markdownIt-Anchor" href="#lcp2"></a> LCP2</h1><h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2><p>有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191106210354.png" class="lazyload"><br>输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。返回一个长度为2的数组[n, m]，使得连分数的值等于n / m，且n, m最大公约数为1。</p><h2 id="不需要约分"><a class="markdownIt-Anchor" href="#不需要约分"></a> 不需要约分</h2><p>假设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mfrac><mi>n</mi><mi>d</mi></mfrac></mrow><annotation encoding="application/x-tex">a+\frac{n}{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>中的 <strong>n和d已经约分</strong>，<br>通分后：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>a</mi><mo>∗</mo><mi>d</mi><mo>+</mo><mi>n</mi></mrow><mi>d</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{a*d+n}{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight">d</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>如果需要约分，那么 a<em>d+n 和 d 能写成 x</em>c，y*c，c是公约数，且不为1</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∗</mo><mi>c</mi><mo>=</mo><mi>a</mi><mo>∗</mo><mi>d</mi><mo>+</mo><mi>n</mi><mo>=</mo><mi>a</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>y</mi><mo>∗</mo><mi>c</mi><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">x*c = a*d+n = a*(y*c)+n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span></p><p>那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>a</mi><mo>∗</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">n = (x - a*y)*c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> ，又 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>=</mo><mi>y</mi><mo>∗</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">d = y*c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> ，所以 <strong>n与d有非1的公约数</strong>，与假设矛盾，因此：<strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>a</mi><mo>∗</mo><mi>d</mi><mo>+</mo><mi>n</mi></mrow><mi>d</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{a*d+n}{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight">d</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>不需要约分</strong></p><h2 id="规律"><a class="markdownIt-Anchor" href="#规律"></a> 规律</h2><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191106212849.png" class="lazyload"></p><h2 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] fraction(<span class="keyword">int</span>[] cont) &#123;</span><br><span class="line">    <span class="keyword">int</span> up = <span class="number">1</span>, down = cont[cont.length-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cont.length-<span class="number">2</span>; i &gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">        up += down*cont[i];</span><br><span class="line">        temp = up; up = down; down = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;down,up&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lcp3"><a class="markdownIt-Anchor" href="#lcp3"></a> LCP3</h1><h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191107205446.png" class="lazyload"></p><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><ol><li>判断终点是否在路径内，如果没有，就直接 <em>return false</em>，如果没有接着判断</li><li>先删除在目标后面障碍，因为在目标后面无需再遍历，然后遍历障碍数组，判断是否有障碍在路径内，如果有则 <em>return false</em></li><li>以上全不 <em>false</em> 的话，就可返回 <em>true</em></li></ol><ul><li>写一个判断方法 <em>reach</em> 更加方便，但是Java不能方法内写方法，所以传入较多的参数</li><li><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191107205355.png" class="lazyload"></li></ul><p>啦啦啦<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191107205519.png" class="lazyload"></p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">robot</span><span class="params">(String command, <span class="keyword">int</span>[][] obstacles, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] cmd = command.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, u = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//String转化为char[]数组容易遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : cmd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'U'</span>) u++;</span><br><span class="line">        <span class="keyword">else</span> r++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!reach(r, u, x, y, cmd)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逻辑上删除在目标后面的障碍</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obstacles.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (obstacles[i][<span class="number">0</span>] &lt;= x &amp;&amp; obstacles[i][<span class="number">1</span>] &lt;= y) &#123;</span><br><span class="line">            obstacles[index][<span class="number">0</span>] = obstacles[i][<span class="number">0</span>];</span><br><span class="line">            obstacles[index][<span class="number">1</span>] = obstacles[i][<span class="number">1</span>];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断目标前面的障碍是否在路径上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (reach(r, u, obstacles[i][<span class="number">0</span>], obstacles[i][<span class="number">1</span>], cmd)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">reach</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> u, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span>[] cmd)</span></span>&#123;</span><br><span class="line">    <span class="comment">//求出最小的循环次数</span></span><br><span class="line">    <span class="keyword">int</span> i = Math.min(x/r,y/u);</span><br><span class="line">    <span class="keyword">int</span> nx = i*r, ny = i*u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : cmd)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nx == x &amp;&amp; ny == y)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'U'</span>) ny+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>         nx+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lcp4"><a class="markdownIt-Anchor" href="#lcp4"></a> LCP4</h1><h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191110165924.png" class="lazyload"></p><h2 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h2><p>这是求 <strong>二分图的最大匹配</strong> ，用到的是匈牙利算法，CSDN上有个<a href="https://blog.csdn.net/Dark_Scope/article/details/8880547" target="_blank" rel="noopener">趣写算法系列之–匈牙利算法</a>，讲的很形象</p><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[][] board;<span class="comment">//棋盘，false代表坏点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] dir = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;<span class="comment">//上下左右四个顶点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] link;<span class="comment">//link[v2] = v1,表示目前v1，v2相连</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] visit;<span class="comment">//查找顶点是否被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">domino</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span>[][] broken)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (broken.length == <span class="number">0</span> )&#123;<span class="comment">//棋盘无坏点，直接返回 棋盘个数/2</span></span><br><span class="line">        <span class="keyword">return</span> n * m &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    board = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">boolean</span>[] i : board)&#123;<span class="comment">//棋盘全部初始化为true</span></span><br><span class="line">        Arrays.fill(i,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] i : broken)&#123;<span class="comment">//坏点设为false</span></span><br><span class="line">        board[i[<span class="number">0</span>]][i[<span class="number">1</span>]] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hungary();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span></span>&#123;<span class="comment">//匈牙利算法，返回最大匹配数</span></span><br><span class="line">    <span class="keyword">int</span> maxOfMatch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = board.length, m = board[<span class="number">0</span>].length;</span><br><span class="line">    visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[n*m];<span class="comment">//用一维数组存储二维数组</span></span><br><span class="line">    link = <span class="keyword">new</span> <span class="keyword">int</span>[n*m];</span><br><span class="line">    Arrays.fill(link, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; r++) &#123;<span class="comment">//遍历v1中的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = ((r&amp;<span class="number">1</span>) == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>); c &lt; m; c+=<span class="number">2</span>)&#123;<span class="comment">//让遍历的点不相邻</span></span><br><span class="line">            <span class="keyword">if</span> (board[r][c])&#123;</span><br><span class="line">                Arrays.fill(visit,<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (find(r,c))&#123;</span><br><span class="line">                    maxOfMatch++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxOfMatch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.length, m = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] d : dir)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = row + d[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> c = col + d[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= n || c &gt;= m)&#123;<span class="comment">//越界</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v2 = r * m + c;</span><br><span class="line">        <span class="keyword">if</span> (board [r] [c] &amp;&amp; !visit[v2])&#123;</span><br><span class="line">            visit[v2] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (link[v2] == -<span class="number">1</span> || find(link[v2]/m, link[v2]%m))&#123;<span class="comment">//因为link是用一维数组存储二维数组</span></span><br><span class="line">                link[v2] = row * m + col;                       <span class="comment">//因此row = link[v2]/m, col = lin[v2]%m，由左式可知</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数排序和桶排序</title>
      <link href="/2019/11/05/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%92%8C%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/11/05/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%92%8C%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>比快排更快的算法，在理想情况下，甚至可以做到线性时间的复杂度</p><a id="more"></a><p>以前学过的排序都是基于 <strong>元素之间的比较</strong> 来进行排序的，但是有一些特殊的排序并不基于元素比较，<br>如：计数排序，桶排序，基数排序，</p><ul><li>以计数排序来说，这种算法是利用数组下标来确定元素的位置</li><li>基数排序是将多位数分成个位数进行计数排序</li><li>桶排序是每一个桶代表一个区间范围</li></ul><h1 id="计数排序"><a class="markdownIt-Anchor" href="#计数排序"></a> 计数排序</h1><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><ol><li>创建一个统计数组，数组长度为 <strong>数列的最大值 - 数列的最小值 + 1</strong>，</li><li>同时数列的最小值作为一个偏移量，用于计算整数在统计数组的下标</li><li>遍历无序数列，将元素填入统计数组 <strong>元素值 - 偏移量</strong> 的位置</li><li>对统计数组进行变形，每一个元素都加上前面所有元素之和。<blockquote><p>为什么相加呢？是让统计数组储存的元素值，等于相应整数的最终排序位置的序号。<br>例如：下标为9的元素值为5，那么代表原始数列的整数9，最终排序在第5位</p></blockquote></li><li>倒序遍历数组，从统计数组找到正确的位置，输出到结果数组<blockquote><p>为什么倒序？为了不改变原有顺序，使之稳定</p></blockquote></li></ol><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">     <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">int</span> min = array[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">         <span class="keyword">if</span> (array[i] &gt; max) max = array[i];</span><br><span class="line">         <span class="keyword">if</span> (array[i] &lt; min) min = array[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> d = max -min;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//填写统计数组</span></span><br><span class="line">     <span class="keyword">int</span>[] countArray = <span class="keyword">new</span> <span class="keyword">int</span> [d+<span class="number">1</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">         countArray[array[i] - min]++;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//统计数组变形</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; countArray.length; i++)</span><br><span class="line">         countArray[i] += countArray[i-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">     <span class="comment">//倒序遍历原始数组</span></span><br><span class="line">     <span class="keyword">int</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span>  i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">         sortedArray[countArray[array [i] - min] - <span class="number">1</span>] = array[i];</span><br><span class="line">         countArray[array [i] - min]--;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> sortedArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h2><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><ul><li>时间复杂度仅为O(n+m)</li><li>空间复杂度为O(m)</li></ul><h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3><ol><li>当数列最大和最小值差距过大时，空间浪费，时间复杂度增加</li><li>必须为整数</li></ol><h1 id="桶排序"><a class="markdownIt-Anchor" href="#桶排序"></a> 桶排序</h1><p>桶排序同样是一种线性时间的排序算法。类似于计数排序所创建的统计数组，桶排序需要创建若干个桶来协助排序。</p><ul><li>每一个桶(bucket)代表一个区间范围，里面可以承载一个或多个元素</li></ul><h2 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h2><ol><li>创建若干个桶，并确定每一个桶的区间范围<blockquote><p>创建几个桶，确定区间范围，有很多种不同的方式。我们这里创建的桶数量等于原始数列的元素数量，<em>除了最后一个桶只包含数列最大值外，前面各个桶的区间按照比例来确定</em></p></blockquote></li><li>遍历原始数列，把元素对号入座放入各个桶中</li><li>对每个桶内部的元素分别进行排序</li><li>遍历所有的桶，输出所有元素</li></ol><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] bucketSort(<span class="keyword">double</span>[] array)&#123;</span><br><span class="line">     <span class="keyword">double</span> max = array[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">double</span> min = array[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">         <span class="keyword">if</span> (array[i] &gt; max) max = array[i];</span><br><span class="line">         <span class="keyword">if</span> (array[i] &lt; min) min = array[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">double</span> d = max - min;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> bucketNum = <span class="number">9</span>;</span><br><span class="line">     ArrayList&lt;LinkedList &lt;Double&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;LinkedList &lt;Double&gt;&gt;(bucketNum);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++)</span><br><span class="line">         bucketList.add(<span class="keyword">new</span> LinkedList&lt;Double&gt; ());</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">         <span class="keyword">int</span> num = (<span class="keyword">int</span>)((array[i] - min)*(bucketNum-<span class="number">1</span>)/d);</span><br><span class="line">         bucketList.get(num).add(array[i]);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketList.size(); i++)</span><br><span class="line">         <span class="comment">//JDK底层采用了归并排序或归并的优化版本</span></span><br><span class="line">         Collections.sort(bucketList.get(i));</span><br><span class="line"></span><br><span class="line">     <span class="keyword">double</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">double</span>[array.length];</span><br><span class="line">     <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//增强版的for只能遍历，不能修改值</span></span><br><span class="line">     <span class="keyword">for</span>(LinkedList&lt;Double&gt; list : bucketList) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">double</span> element : list) &#123;</span><br><span class="line">             sortedArray[index++] = element;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> sortedArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优缺点-2"><a class="markdownIt-Anchor" href="#优缺点-2"></a> 优缺点</h2><h3 id="优点-2"><a class="markdownIt-Anchor" href="#优点-2"></a> 优点</h3><ul><li>时间复杂度仅为O(n)</li><li>空间复杂度为O(m)</li></ul><h3 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h3><p>不稳定，第一个桶有n-1个元素，最后一个桶只有一个，此时时间复杂度退化为O(nlogn)，而且白白的创建了许多空桶</p>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2019/11/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/11/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>堆排序是利用二叉堆的特性完成的排序。</p><a id="more"></a><h1 id="二叉堆的特性"><a class="markdownIt-Anchor" href="#二叉堆的特性"></a> 二叉堆的特性</h1><ol><li>最大堆的堆顶是整个堆中最大的元素</li><li>最小堆的堆顶是整个堆中最小的元素</li></ol><ul><li>以最大堆为例，如果删除一个最大堆的堆顶(并不是完全删除，而是跟末尾节点交换位置，然后退出堆)，经过自我调整，第二大的元素就会成为堆顶元素，往复 n-1次即可完成排序</li></ul><h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1><ol><li>把无序数组构建成二叉堆。需要从小到大排序，则构成最大堆；反之，构成最小堆。</li><li>循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶</li></ol><h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下沉调整堆</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parentIndex, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">int</span> childIndex = <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(childIndex &lt; length)&#123;</span><br><span class="line">    <span class="comment">//如果有右孩子，且右孩子的值大于左孩子，则定位到右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(childIndex+<span class="number">1</span> &lt; length &amp;&amp; array[childIndex+<span class="number">1</span>] &gt; array[childIndex])</span><br><span class="line">            childIndex++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果父节点小于任何一个孩子的值，则直接跳出</span></span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= array[childIndex])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">        array[parentIndex] = array[childIndex];</span><br><span class="line">        parentIndex = childIndex;</span><br><span class="line">        childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array[parentIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序(升序)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.将无序数组建成最大堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = array.length/<span class="number">2</span>; i &gt;=<span class="number">0</span>; i--)</span><br><span class="line">        downAdjust(array,i,array.length-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = array.length-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于第一次的调整建成了最大堆，所以堆顶的左右孩子只比最大的元素小，</span></span><br><span class="line">        <span class="comment">//因而只需将堆顶的元素下沉即可重新得到最大堆，参照堆的删除节点操作</span></span><br><span class="line">        downAdjust(array, <span class="number">0</span> ,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h1><p>下沉调整的空间复杂度为O(logn)，需要调整n次，因此时间复杂度为O(nlogn)</p><ul><li>构建堆的时间复杂度为O(n)，而不是(nlogn)</li><li>堆的插入和删除的时间复杂度都是O(logn)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2019/11/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/11/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。</p><a id="more"></a><h1 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h1><p>动态规划与分治法类似，其基本思想也是 <strong>将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</strong>。<br>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。<br>如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，即 <strong>重复利用子问题的答案</strong> 这样就可以避免大量的重复计算，节省时间，这就是动态规划的优势。</p><h1 id="设计步骤"><a class="markdownIt-Anchor" href="#设计步骤"></a> 设计步骤</h1><h2 id="基本步骤"><a class="markdownIt-Anchor" href="#基本步骤"></a> 基本步骤</h2><ol><li><p>划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p></li><li><p>确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足 <em>无后效性</em> 。</p></li><li><p>确定决策并写出 <em><strong>状态转移方程</strong></em>：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p></li><li><p>寻找边界条件：给出的状态转移方程是一个 <em>递推式</em>，需要一个递推的 <em>终止条件或边界条件</em> 。</p></li></ol><h2 id="简化"><a class="markdownIt-Anchor" href="#简化"></a> 简化</h2><p>一般，只要 <strong>解决问题的阶段、状态</strong> 和 <strong>状态转移决策</strong> 确定了，就可以写出 <strong>状态转移方程（包括边界条件）</strong>。实际应用中可以按以下几个简化的步骤进行设计：</p><ol><li>分析最优解的性质，并刻画其结构特征。</li><li>递归的定义最优解。</li><li>以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</li><li>根据计算最优值时得到的信息，构造问题的最优解。</li></ol><h1 id="适用条件"><a class="markdownIt-Anchor" href="#适用条件"></a> 适用条件</h1><ol><li><p><strong>最优化原理</strong>（最优子结构性质）：最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。</p></li><li><p><strong>无后效性</strong>：将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。</p></li><li><p><strong>子问题的重叠性</strong>：动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于 <strong>解决冗余</strong> ，这是动态规划算法的根本目的。动态规划实质上是一种以 <strong>空间换时间</strong> 的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。</p></li></ol><h1 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h1><p>动态规划一般可分为 <strong>线性动规</strong>，<strong>区域动规</strong>，<strong>树形动规</strong>，<strong>背包动规</strong>四类。<br>举例：</p><ul><li>线性动规：拦截导弹，合唱队形，挖地雷，建学校，剑客决斗等；</li><li>区域动规：石子合并， 加分二叉树，统计单词个数，炮兵布阵等；</li><li>树形动规：贪吃的九头龙，二分查找树，聚会的欢乐，数字三角形等；</li><li>背包问题：01背包问题，完全背包问题，分组背包问题，二维背包，装箱问题，挤牛奶（同济ACM第1132题）等；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 算法思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fizz Buzz</title>
      <link href="/2019/11/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/Fizz%20Buzz/"/>
      <url>/2019/11/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/Fizz%20Buzz/</url>
      
        <content type="html"><![CDATA[<p>写一个程序，输出从 1 到 n 数字的字符串表示。</p><ol><li>如果 n 是3的倍数，输出“Fizz”；</li><li>如果 n 是5的倍数，输出“Buzz”；</li><li>如果 n 同时是3和5的倍数，输出 “FizzBuzz”。</li></ol><a id="more"></a><h1 id="暴力法"><a class="markdownIt-Anchor" href="#暴力法"></a> 暴力法</h1><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><ol><li>初始化一个空的答案列表。</li><li>遍历 1 … N1…N。</li><li>对于每个数，判断它能不能同时被 3 和 5 整除，如果可以就把 FizzBuzz 加入答案列表。</li><li>如果不行，判断它能不能被 3 整除，如果可以，把 Fizz 加入答案列表。</li><li>如果还是不行，判断它能不能被 5 整除，如果可以，把 Buzz 加入答案列表。</li><li>如果以上都不行，把这个数加入答案列表。</li></ol><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= n; num++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> divisibleBy3 = (num % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">boolean</span> divisibleBy5 = (num % <span class="number">5</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (divisibleBy3 &amp;&amp; divisibleBy5)</span><br><span class="line">        ans.add(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (divisibleBy3)</span><br><span class="line">        ans.add(<span class="string">"Fizz"</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (divisibleBy5)</span><br><span class="line">        ans.add(<span class="string">"Buzz"</span>);</span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">        ans.add(num + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="字符串连接"><a class="markdownIt-Anchor" href="#字符串连接"></a> 字符串连接</h1><p>这个方法不会降低渐进复杂度，但是当 FizzBuzz 的规则变得更复杂的时候，这将会是个更优雅的解法。比方说，玩个 FizzBuzzJazz 的游戏。</p><h2 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h2><p>我们放弃使用之前的联合判断，取而代之依次判断是否能被给定的数整数。这道题中，就是依次判断能不能被 3 整除，能不能被 5 整除。如果能被 3 整除，就把对应的 Fizz 连接到答案字符串，如果能被 5 整除，就把 Buzz 连接到答案字符串。</p><h2 id="实现-2"><a class="markdownIt-Anchor" href="#实现-2"></a> 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= n; num++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> divisibleBy3 = (num % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">boolean</span> divisibleBy5 = (num % <span class="number">5</span> == <span class="number">0</span>);</span><br><span class="line">        String s = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(divisibleBy3) s += <span class="string">"Fizz"</span>;</span><br><span class="line">        <span class="keyword">if</span>(divisibleBy5) s += <span class="string">"Buzz"</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">""</span>) s += num;</span><br><span class="line"></span><br><span class="line">        ans.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="散列表"><a class="markdownIt-Anchor" href="#散列表"></a> 散列表</h1><p>这个方法是对方法二的优化。当数字和答案的映射是定好的，那么方法二用起来也还可以。但是如果你遇到一个变态的面试官，他跟你说他需要更自由的映射关系呢？<br>每个映射一个判断显然是不可行的，这样写出来的代码一定是丑陋不堪且难以维护的。<br>如果老板有这样一个需求，明天你把映射关系换掉或者删除一个映射关系吧。对于这种要求，我们只能一个个去修改判断条件的代码。</p><h2 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h2><p>但我们实际上有个更优雅的做法，那就是把映射关系放在 <em>散列表</em> 里面。</p><ol><li>把所有的映射关系放在散列表 fizzBuzzHash 中，这个散列表形如 { 3: ‘Fizz’, 5: ‘Buzz’ }。</li><li>遍历 1 … N。</li><li>对于每个数字，遍历 fizzBuzzHash 中的键，检查是否能被它整除。</li><li>如果这个数能被键整除，就把当前键映射的值加到到答案字符串后面去。对于散列表的每个键值对，都这样操作。</li><li>最后将答案字符串加入答案列表。</li></ol><ul><li>通过这样的方式你可以对散列表 <em>添加/删除</em> 映射关系，同时还不需要修改太多代码。</li></ul><h2 id="实现-3"><a class="markdownIt-Anchor" href="#实现-3"></a> 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ans list</span></span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hash map to store all fizzbuzz mappings.</span></span><br><span class="line">    HashMap&lt;Integer, String&gt; fizzBizzDict =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;Integer, String&gt;() &#123;</span><br><span class="line">          &#123;</span><br><span class="line">            put(<span class="number">3</span>, <span class="string">"Fizz"</span>);</span><br><span class="line">            put(<span class="number">5</span>, <span class="string">"Buzz"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= n; num++) &#123;</span><br><span class="line"></span><br><span class="line">      String numAnsStr = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Integer key : fizzBizzDict.keySet()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the num is divisible by key,</span></span><br><span class="line">        <span class="comment">// then add the corresponding string mapping to current numAnsStr</span></span><br><span class="line">        <span class="keyword">if</span> (num % key == <span class="number">0</span>) &#123;</span><br><span class="line">          numAnsStr += fizzBizzDict.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (numAnsStr.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="comment">// Not divisible by 3 or 5, add the number</span></span><br><span class="line">        numAnsStr += Integer.toString(num);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Append the current answer str to the ans list</span></span><br><span class="line">      ans.add(numAnsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位为1的个数</title>
      <link href="/2019/11/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E4%BD%8D%E4%B8%BA1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2019/11/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E4%BD%8D%E4%B8%BA1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><a id="more"></a><h1 id="循环和位移动"><a class="markdownIt-Anchor" href="#循环和位移动"></a> 循环和位移动</h1><p>这个方法比较直接。我们遍历数字的 32 位。如果最后一位是 1 ，将计数器加一，然后数字右移。<br>任何数字和 <strong>掩码1</strong> 进行按位与运算，可以让我们获得最后一位数字，检查下一位时，掩码左移或者参数右移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">            bits++;</span><br><span class="line">        &#125;</span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="位移动的小技巧"><a class="markdownIt-Anchor" href="#位移动的小技巧"></a> 位移动的小技巧</h1><p>我们可以把前面的算法进行优化。我们不再检查数字的每一个位，而是不断把数字最后一个 1 反转，并把答案加一。当数字变成 0 的时候，我们就知道它没有 1 的位了，此时返回答案。<br>这里关键的想法是对于任意数字n，将 <em>n</em> 和 <em>n-1</em> 做与运算，会把最后一个 1 的位变成 0 。为什么？考虑 n 和 n−1 的二进制表示。<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191101174947.png" class="lazyload"><br>在二进制表示中，数字 n 中最低位的 1 总是对应 n−1 中的 0 。因此，将 n 和 n−1 与运算总是能把 n 中最低位的 1 变成 0 ，并保持其他位不变。</p><ul><li>之前学到，可以利用这个判断一个数是不是2的整次幂，如果是2的整次幂，则 <strong>最低位为1</strong> 的就是 <strong>最高位</strong> ，因此 <strong>n&amp;n-1</strong>就会得到0</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 数 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2019/10/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/10/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>同冒泡排序，快速排序也是交换排序</p><a id="more"></a><h1 id="思想"><a class="markdownIt-Anchor" href="#思想"></a> 思想</h1><p>每一轮挑选一个基准元素，并让其他比它大的元素移动到数列的一边，比它小的移动到另一边，从而把数列拆成两个部分，一个部分的数全部比基准元素打，另一个部分全部比它小。</p><ul><li>这种思想叫做 <strong>分治法</strong></li><li>原数列在每一轮都被拆成两部分，两部分中的每一部分又被拆成两部分，一直递归下去，直至不可再分，因此要遍历 <strong>logn</strong> 轮，而且每一轮的交换和比较要遍历数组，因此时间复杂度为 <strong>O(nlogn)</strong></li></ul><h1 id="基准元素的选择"><a class="markdownIt-Anchor" href="#基准元素的选择"></a> 基准元素的选择</h1><p>最简单的方式是选第一个元素，但是在数列基本有序，或者逆序的情况下，数列没有理想的被分为均匀的两半，<em>每一轮只确定基准元素的位置</em>，时间复杂度退化为O(n^2)</p><ul><li>解决方法：<strong>随机选择一个元素作为基准元素</strong>，并让基准元素和数列首位元素交换位置</li></ul><h1 id="元素的交换"><a class="markdownIt-Anchor" href="#元素的交换"></a> 元素的交换</h1><p>选定了基准元素以后，我们要做的就是把其他元素中小于基准元素都交换到基准元素的一边，大于它的交换到另一边。</p><h2 id="实现方法"><a class="markdownIt-Anchor" href="#实现方法"></a> 实现方法</h2><h3 id="双边循环法"><a class="markdownIt-Anchor" href="#双边循环法"></a> 双边循环法</h3><p>也就是数据结构中学的方法，为双指针法。</p><ul><li>首先选定基准元素pivot，并设置两个指针left，right，分别指向数组的最左边和最右边</li><li>进行循环，从right指针开始，让指针所指向的元素和基准元素做比较。<ol><li>如果大于或等于pivot，则right指针右移</li><li>如果小于pivot，则right指针停止移动，right和left指向的值互换，切换到left指针</li><li>让left指针指向的元素和基准元素作比较，如果小于等于pivot，则左移，反之停止移动，right和left指向的值互换，切换到right指针</li></ol></li><li>一直循环下去，直到 <strong>right == left</strong></li><li>最后把pivot的与两指针汇合处的元素与pivot互换，即完成第一次分治</li></ul><h4 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归结束条件，startIndex大于等于endIndex时</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex &gt;= endIndex) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span><br><span class="line">    <span class="comment">//根据基准元素，分成两部分进行递归快速排序</span></span><br><span class="line">    quickSort(arr, startIndex, pivotIndex-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex+<span class="number">1</span>, endIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">//取第一个位置的元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> left = startIndex;</span><br><span class="line">    <span class="keyword">int</span> right = endIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left != right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt; pivot)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= pivot)</span><br><span class="line">            left++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换left和right指针所指向的元素</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = arr[left];</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            arr[right] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pivot和指针重合点交换</span></span><br><span class="line">    arr[startIndex] = arr[left];</span><br><span class="line">    arr[left] = pivot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单边循环法"><a class="markdownIt-Anchor" href="#单边循环法"></a> 单边循环法</h3><p>双边循环从数组的两边交替遍历元素，虽然更加直观，但是代码量较多。单边循环法只从数组的一边对元素进行遍历和交换。</p><ul><li>选定基准元素pivot，设置一个mark指针指向数列起始位置，这个mark指针代表 <strong>小于基准元素的区域边界</strong></li><li>接下来，从基准元素的下一个位置开始遍历数组<ol><li>如果遍历到的元素大于基准元素，就继续往后遍历</li><li>如果小于基准元素，需要做两件事：<br>第一，把mark指针右移一位，因为小于pivot的区域边界增加了1；<br>第二，让最新遍历到的元素和mark指针所在位置的元素互换，因为最新遍历的元素归属与小于pivot的区域</li></ol></li><li>按照这个思路，继续遍历，直至末位，最后把pivot元素交换到mark指针所在的位置，第一次分治结束</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归结束条件，startIndex大于等于endIndex时</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex &gt;= endIndex) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partitionV2(arr, startIndex, endIndex);</span><br><span class="line">    <span class="comment">//根据基准元素，分成两部分进行递归快速排序</span></span><br><span class="line">    quickSort(arr, startIndex, pivotIndex-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex+<span class="number">1</span>, endIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partitionV2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> mark = startIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex+<span class="number">1</span>; i &lt;= endIndex; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; pivot)&#123;</span><br><span class="line">            mark++;</span><br><span class="line">            <span class="keyword">int</span> p = arr[mark];</span><br><span class="line">            arr[mark] = arr[i];</span><br><span class="line">            arr[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[startIndex] = arr[mark];</span><br><span class="line">    arr[mark] = pivot;</span><br><span class="line">    <span class="keyword">return</span> mark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡算法</title>
      <link href="/2019/10/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/10/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>冒泡排序(bubble sort)是很经典的 <strong>交换排序</strong> 算法，为什么叫做冒泡，就是因为这个算法的每一个元素都像小气泡一样，根据自身大小，往数组的一侧移动。</p><a id="more"></a><h1 id="思想"><a class="markdownIt-Anchor" href="#思想"></a> 思想</h1><p>把相邻的元素两两比较，当一个元素大于右侧元素时，两个元素交换，如果没有，位置不变</p><ul><li>每一遍历完一轮，总有一个最大的元素移到最右侧</li><li>冒泡算法是一个稳定的算法</li><li>每一轮都要遍历所有没排序的元素，总共遍历 <em>n-1</em> 轮，因此时间复杂度为O(n^2)</li></ul><h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//有序标志，每一轮初值为true</span></span><br><span class="line">        <span class="comment">//如果是执行一轮过后还是true，就是没有进行交换，则数组以有序，循环结束</span></span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                isSorted = <span class="keyword">false</span>;<span class="comment">//发生了交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isSorted) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双向冒泡鸡尾酒排序"><a class="markdownIt-Anchor" href="#双向冒泡鸡尾酒排序"></a> 双向冒泡：鸡尾酒排序</h1><p>冒泡排序的每一个元素都是向右移动的，是单向的，鸡尾酒排序是 <strong>双向 的</strong>，奇数找最大的，偶数找最小的，但是代码量增加了一倍，在大部分元素有序的情况下，鸡尾酒排序更有优势</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doubleBubbleSort</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length/<span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//奇数轮</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; array.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                isSorted = <span class="keyword">false</span>;<span class="comment">//发生了交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSorted) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//偶数轮，重新标记</span></span><br><span class="line">        isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = array.length-i-<span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &lt;&gt; array[j-<span class="number">1</span>])&#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j-<span class="number">1</span>];</span><br><span class="line">                array[j-<span class="number">1</span>] = tmp;</span><br><span class="line">                isSorted = <span class="keyword">false</span>;<span class="comment">//发生了交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSorted) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2019/10/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/10/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>生活中的排序无处不在，因此在算法中也无处不在，排序看似简单，但是有着各种各样的算法和思想。</p><a id="more"></a><h1 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h1><h2 id="根据时间复杂度的不同主流的排序算法可以分为3大类"><a class="markdownIt-Anchor" href="#根据时间复杂度的不同主流的排序算法可以分为3大类"></a> 根据时间复杂度的不同，主流的排序算法可以分为3大类。</h2><ol><li>时间复杂度为 <em>O(n^2)</em></li></ol><ul><li>冒泡算法</li><li>选择排序</li><li>插入排序</li><li>希尔排序(希尔排序比较特殊，它的性能略优于O(n^2)，但又比不上O(nlogn))</li></ul><ol start="2"><li>时间复杂度为 <em>O(nlogn)</em></li></ol><ul><li>快速排序</li><li>归并排序</li><li>堆排序</li></ul><ol start="3"><li>时间复杂度为线性</li></ol><ul><li>计数排序</li><li>桶排序</li><li>基数排序</li></ul><h2 id="此外排序算法还划分为-稳定排序-和-不稳定排序"><a class="markdownIt-Anchor" href="#此外排序算法还划分为-稳定排序-和-不稳定排序"></a> 此外，排序算法还划分为 <strong>稳定排序</strong> 和 <strong>不稳定排序</strong></h2><p>如何划分稳定和不稳定：如果值相同的元素在排序后仍然保持排序前的顺序，排序算法就是稳定的</p><h1 id="总表"><a class="markdownIt-Anchor" href="#总表"></a> 总表</h1><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191103155227.png" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断一个数是不是2的整次幂</title>
      <link href="/2019/10/29/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%98%AF%E4%B8%8D%E6%98%AF2%E7%9A%84%E6%95%B4%E6%AC%A1%E5%B9%82/"/>
      <url>/2019/10/29/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%98%AF%E4%B8%8D%E6%98%AF2%E7%9A%84%E6%95%B4%E6%AC%A1%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<ul><li>如果一个整数是2的整次幂，那么当它转化为二进制时，只有最高位时1，其他都是0</li><li>把这个整数减1后，二进制数全变成了1，原本最高位变为0</li><li>因此，只需要 <em>原数值</em> 和 <em>它减1的结果</em> 进行按位与运算，也就是 <strong>n&amp;(n-1)</strong> 是否为0，就可以判断它是不是2的整次幂</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">boolean</span> <span class="title">isPowerOf2</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (num &amp; num-<span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大公约数</title>
      <link href="/2019/10/28/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
      <url>/2019/10/28/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>求一个数的最大公约数，getGreatestCommonDivisor简称gcd</p><a id="more"></a><h1 id="辗转相除法"><a class="markdownIt-Anchor" href="#辗转相除法"></a> 辗转相除法</h1><p>又名 <em>欧几里得算法</em></p><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><p>两个正整数a，b（a&gt;b），它们的最大公约数等于 <em>a/b的余数</em> 和 <em>b</em> 之间的最大公约数</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> big = a&gt;b? a:b;</span><br><span class="line">    <span class="keyword">int</span> small = a&lt;b? a:b;</span><br><span class="line">    <span class="keyword">if</span>(big%small == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> gcd(big%small, small);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2><p>两个整数较大时，模运算性能较差</p><h1 id="更相减损术"><a class="markdownIt-Anchor" href="#更相减损术"></a> 更相减损术</h1><h2 id="原理-2"><a class="markdownIt-Anchor" href="#原理-2"></a> 原理</h2><p>两个正整数a，b（a&gt;b），它们的最大公约数等于 <em>a-b的差值</em> 和 <em>较小数b</em>的最大公约数</p><h2 id="实现-2"><a class="markdownIt-Anchor" href="#实现-2"></a> 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> big = a&gt;b? a:b;</span><br><span class="line">    <span class="keyword">int</span> small = a&lt;b? a:b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gcd(big-small, small);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h2><p>不稳定，当两个数悬殊巨大时，要计算多次，例如：100001和1</p><h1 id="移位运算法"><a class="markdownIt-Anchor" href="#移位运算法"></a> 移位运算法</h1><p>这个算法结合了 <em>辗转相除法</em> 和 *更相减损术 的优势，在更相减损术的基础上使用移位运算，整个算法只用到 <em>移位运算</em> 和 <em>减法</em></p><ul><li>这个算法在两个数比较小时看不出优势，但是当数比较大的时候，计算速度明显提高</li></ul><h2 id="原理-3"><a class="markdownIt-Anchor" href="#原理-3"></a> 原理</h2><p>两个正整数a，b（a&gt;b）</p><ol><li>gcd(a,a)=a，也就是一个数和其自身的公约数仍是其自身。</li><li>gcd(ka,kb)=k gcd(a,b)，也就是最大公约数运算和倍乘运算可以交换。特殊地，当k=2时，说明两个偶数的最大公约数必然能被2整除。</li><li>当k与b互为质数，gcd(ka,b)=gcd(a,b)，也就是约掉两个数中只有其中一个含有的因子不影响最大公约数。特殊地，当k=2时，说明计算一个偶数和一个奇数的最大公约数时，可以先将偶数除以2。</li></ol><h2 id="实现-3"><a class="markdownIt-Anchor" href="#实现-3"></a> 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcdPlus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//采用与1进行与的位运算判断奇偶数，速度更快</span></span><br><span class="line">    <span class="keyword">if</span>((a&amp;<span class="number">1</span>)==<span class="number">0</span> &amp;&amp; (b&amp;<span class="number">1</span>) ==<span class="number">0</span>)<span class="comment">//a，b均为偶数</span></span><br><span class="line">        <span class="keyword">return</span> gcdPlus(a&gt;&gt;<span class="number">1</span>, b&gt;&gt;<span class="number">1</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((a&amp;<span class="number">1</span>)==<span class="number">0</span> &amp;&amp; (b&amp;<span class="number">1</span>) !=<span class="number">0</span>)<span class="comment">//a为偶数，b为奇数</span></span><br><span class="line">        <span class="keyword">return</span> gcdPlus(a&gt;&gt;<span class="number">1</span>, b);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((a&amp;<span class="number">1</span>)==<span class="number">0</span> &amp;&amp; (b&amp;<span class="number">1</span>) !=<span class="number">0</span>)<span class="comment">//a为奇数，b为偶数</span></span><br><span class="line">        <span class="keyword">return</span> gcdPlus(a, b&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> big = a&gt;b? a:b;</span><br><span class="line">        <span class="keyword">int</span> small = a&lt;b? a:b;</span><br><span class="line">        <span class="keyword">return</span> gcdPlus(big-small, small);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h1><ol><li>暴力法：O(min(a, b))</li><li>辗转相除法：近似为O(log(max(a, b)))，但是模运算性能较差</li><li>更相减损术：算法不稳定，最坏为O(max(a, b))</li><li>移位运算法：不但避免模运算，而且稳定，复杂度为O(log(max(a, b)))</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小栈的实现</title>
      <link href="/2019/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E5%B0%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E5%B0%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>实现一个栈，该栈带有出栈（pop），进栈（push），取最小元素（getMin）3个方法，保证时间复杂度为O(1).</p><a id="more"></a><p>如果只声明一个变量储存最小值是不够的，因为如果最小值出栈的话，怎么更新？<br>因而，我们需要储存栈中 <strong>曾经的最小值</strong>，作为“备胎”</p><h1 id="解法步骤"><a class="markdownIt-Anchor" href="#解法步骤"></a> 解法步骤</h1><ol><li>设原有栈为A，此时创建个额外的“备胎”栈B，用于辅助栈A。</li><li>当第一个元素进入栈A时，让新元素也进入栈B。因为这个唯一的元素时栈A目前最小值。</li><li>之后，每当新元素入栈A时，比较 <em>新元素</em> 和 <em>栈A目前最小值</em> 的大小，如果小于 <em>栈A目前的最小值</em>，则让新元素也入栈B，此时 <em>栈B的栈顶元素</em> 是 <em>栈A当前最小值</em>。</li><li>每当有栈A的元素出栈，如果 <em>出栈元素</em> 和 <em>栈B栈顶元素</em> 相同时，栈B栈顶元素也出栈，则接下去栈B栈顶元素变为栈A目前最小值，“备胎转正”。</li><li>当调用getMin()时，返回 <em>栈B的栈顶元素</em> ，这就是栈A目前最小值。</li></ol><ul><li>时间复杂度均是O(1)，最坏情况的空间复杂度为O(n)</li></ul><h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; mainStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> element)</span></span>&#123;</span><br><span class="line">    mainStack.push(element);</span><br><span class="line">    <span class="keyword">if</span>(minStack.empty() || element &lt;= minStack.peek())</span><br><span class="line">        minStack.push(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mainStack.peek().equals(minStack.peek()))</span><br><span class="line">        minStack.pop();</span><br><span class="line">    <span class="keyword">return</span> mainStack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mainStack.empty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"stack is empty"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> minStack.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模式匹配</title>
      <link href="/2019/10/27/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/10/27/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p><a id="more"></a><p>这个是个模式匹配问题，我刚开始没有意识到到，用暴力法匹配所有的子串，解决了问题，虽然在短字符串的匹配中速度比kmp快，但是长字符串的效率很低。<br>看了解答后，才意识到这是我数据结构中学到的 <strong>KMP算法</strong>。</p><h1 id="核心next数组"><a class="markdownIt-Anchor" href="#核心next数组"></a> 核心NEXT数组</h1><p>next数组是求 <strong>前缀，后缀最长的公共子串长度</strong></p><ul><li>求next函数值的问题可以看成另一个模式匹配问题：<strong>整个模式串既是子串又是模式串</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] get_next(String needle)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[needle.length()];</span><br><span class="line">    <span class="comment">//i是后缀，j是前缀，前缀固定，后缀是相对的</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; needle.length()-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || needle.charAt(i) == needle.charAt(j))&#123;</span><br><span class="line">            i++; j++;</span><br><span class="line">            <span class="comment">//next数组优化，当字符失配时，回到相同字符无意义，应继续递归</span></span><br><span class="line">            <span class="keyword">if</span>(needle.charAt(i) != needle.charAt(j)) next[i] = j;</span><br><span class="line">            <span class="keyword">else</span> next[i] = next[j];</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            j = next[j];<span class="comment">//j回溯</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br></pre></td></tr></table></figure><h1 id="strstr的实现"><a class="markdownIt-Anchor" href="#strstr的实现"></a> strStr的实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] next = get_next(needle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; haystack.length() &amp;&amp; j &lt; needle.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || haystack.charAt(i) == needle.charAt(j)) &#123;i++; j++;&#125;</span><br><span class="line">        <span class="keyword">else</span> j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == needle.length()) <span class="keyword">return</span> i-j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
            <tag> KMP算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断链表有环</title>
      <link href="/2019/10/27/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF/"/>
      <url>/2019/10/27/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p>有一个单向链表，如何判断链表是否为有环链表？</p><a id="more"></a><h1 id="hashset法"><a class="markdownIt-Anchor" href="#hashset法"></a> HashSet法</h1><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><ul><li>创建一个以节点ID为Key的HashSet集合</li><li>遍历链表并加入HashSet，判断是否重复，重复则有环</li></ul><h2 id="复杂度"><a class="markdownIt-Anchor" href="#复杂度"></a> 复杂度</h2><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul><h1 id="双指针追及法"><a class="markdownIt-Anchor" href="#双指针追及法"></a> 双指针追及法</h1><h2 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h2><ul><li>声明两个指针p1，p2，都指向头节点</li><li>p1为慢指针，速度一个节点，p2为快指针，速度两个节点，速度差一个节点</li><li>让两个指针开始跑，两个指针跑完一次，判断两个指针指向的节点是否相同，相同则有环，不同则继续下一次循环<br>这个思路类似于数学上的 <em>追及问题</em>，如果跑道是环形的，快指针会追上慢指针</li></ul><h2 id="复杂度-2"><a class="markdownIt-Anchor" href="#复杂度-2"></a> 复杂度</h2><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul><h2 id="源码"><a class="markdownIt-Anchor" href="#源码"></a> 源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCycle</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    Node p1 = head, p2 = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p2 != <span class="keyword">null</span> &amp;&amp; p2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ringMeetNode可以在这里获得</span></span><br><span class="line">        <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class Node&#123;</span></span><br><span class="line"><span class="comment">    int data;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node(int data)&#123;</span></span><br><span class="line"><span class="comment">        this.data = data;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="问题扩展"><a class="markdownIt-Anchor" href="#问题扩展"></a> 问题扩展</h1><h2 id="1如何求出环的长度"><a class="markdownIt-Anchor" href="#1如何求出环的长度"></a> 1.如何求出环的长度</h2><p>当两个指针首次相遇，让两个指针接着前进，并统计前进的循环次数，直到两个指针再次相遇。此时统计前进的循环次数就是环长。</p><h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3><p>p1与p2速度差为一个节点，当快指针再次追上慢指针时，快指针多走了慢指针一圈，因此：<br><strong>环长 = 快指针走的步数 - 慢指针走的步数 = 速度差 * 前进次数 = 前进次数</strong></p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRingLength</span><span class="params">(Node ringMeetNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ringLength = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ringMeetNode可以在isCycle()中获得</span></span><br><span class="line">    Node p1 = ringMeetNode, p2 = ringMeetNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next.next;</span><br><span class="line">        ringLength++;</span><br><span class="line">        <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ringLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2如何求入环节点"><a class="markdownIt-Anchor" href="#2如何求入环节点"></a> 2.如何求入环节点</h2><h3 id="原理-2"><a class="markdownIt-Anchor" href="#原理-2"></a> 原理</h3><p>假设从链表头节点到入环的距离时D，从入环点到首次相遇点的距离时S1，从首次相遇点回到入环点的距离时S2</p><ol><li>两次指针首次相遇时，各自所走的距离：</li></ol><ul><li>p1：D + S1</li><li>p2：D + S1 + S2 + S1 = D + 2S1 + S2</li></ul><ol start="2"><li>由于p2的速度是p1的两倍，因此：2(D + S1) = D + 2S1 + S2</li><li>得到 <strong>D = S2</strong>，即：从头节点到入环点的距离 = 从首次相遇点回到入环点的距离</li><li>这样一来，只要把其中一个指针放回头节点，另一个指针保持在远处，然后两个指针的 <strong>速度都是一个节点</strong>，那么：它们 <strong>相遇节点就是入环节点</strong></li></ol><h3 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">getRingStart</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="comment">//ringMeetNode可以在isCycle()中获得</span></span><br><span class="line">    Node p1 = head, p2 = ringMeetNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快乐数</title>
      <link href="/2019/10/27/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
      <url>/2019/10/27/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>编写一个算法来判断一个数是不是“快乐数”。</p><a id="more"></a><p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p><ul><li>例如:19</li></ul><blockquote><p>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 0^2 = 1</p></blockquote><h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1><p>使用“快慢指针”思想找出循环：“快指针”每次走两步，“慢指针”每次走一步，当二者相等时，即为一个循环周期。此时，判断是不是因为1引起的循环，是的话就是快乐数，否则不是快乐数。</p><ul><li>注意：此题不建议用集合记录每次的计算结果来判断是否进入循环，因为这个集合可能大到无法存储；另外，也不建议使用递归，同理，如果递归层次较深，会直接导致调用栈崩溃。不要因为这个题目给出的整数是int型而投机取巧。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = n, p2 = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        p1 = bitSquareSum(p1);</span><br><span class="line">        p2 = bitSquareSum(bitSquareSum(p2));</span><br><span class="line">    &#125;<span class="keyword">while</span>(p1 != p2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果循环点是1，则它是快乐数</span></span><br><span class="line">    <span class="comment">//也有可能循环点不是1</span></span><br><span class="line">    <span class="keyword">return</span> p1 == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bitSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span> ,bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">        bit = n%<span class="number">10</span>;</span><br><span class="line">        sum += bit*bit;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除指定元素</title>
      <link href="/2019/10/26/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E7%A7%BB%E9%99%A4%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0/"/>
      <url>/2019/10/26/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E7%A7%BB%E9%99%A4%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><a id="more"></a><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br>这个采用 <strong>双指针</strong> ，与之前的 <strong>删除排序数组中的重复项</strong> 极为相似</p><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != val) &#123;</span><br><span class="line">            nums[ans] = nums[i];</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针优化版"><a class="markdownIt-Anchor" href="#双指针优化版"></a> 双指针优化版</h1><p>现在考虑数组包含很少的要删除的元素的情况。例如，num=[1，2，3，5，4]，Val=4num=[1，2，3，5，4]，Val=4。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 num=[4，1，2，3，5]，Val=4，似乎没有必要将 [1，2，3，5] 这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。<br>所以当我们遇到 <strong>nums[ans] == val</strong> 的时候，我们可以将 <strong>当前元素与最后一个元素进行交换，并释放最后一个元素</strong>（ans–）。这实际上使数组的大小减少了 1。</p><ul><li>请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素，因为并没有i++。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">            nums[i] = nums[ans-<span class="number">1</span>];</span><br><span class="line">            ans--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并有序链表</title>
      <link href="/2019/10/25/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/10/25/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><a id="more"></a><p>题设类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="迭代法"><a class="markdownIt-Anchor" href="#迭代法"></a> 迭代法</h1><p>这个在数据结构中学过，虽然那时候学的是 <strong>C语言</strong>，但是思想相同。<br>由于没有头节点，我们可以假设个头节点，更容易的返回合并后的链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置头节点</span></span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode p = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            p.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将两个链表中剩下的一个链表直接接在末尾</span></span><br><span class="line">    p.next = (l1 == <span class="keyword">null</span>)?l2:l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O(n+m)</li><li>空间复杂度 O(1)</li></ul><h1 id="递归法"><a class="markdownIt-Anchor" href="#递归法"></a> 递归法</h1><p>我们可以递归的定义在两个链表的 merge 操作：<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191025171030.png" class="lazyload"><br>也就是说，头部比较小的一个与剩下元素的 merge 操作结果连接起来，就可以得到最终的链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归先考虑边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)  <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O(n+m)</li><li>空间复杂度 O(n+m)，由于需要n+m个栈帧</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习之旅————多线程</title>
      <link href="/2019/10/23/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/10/23/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>多线程（Thread）是软件开发中的重要内容，实际上，多线程最直观的说法是让应用程序看起来好像同时能做好几件事情</p><a id="more"></a><p>线程是独立的线程。它代表独立的执行空间。在Java中，要建立新的线程就得创建 <strong>Thread</strong>，CPU会在执行空间非常快速地来回切换。因为CPU速度很快，所以你会感觉CPU同时在做好几件事</p><ul><li>要记得，Java也只是个在底层操作系统上执行的进程。一旦轮到Java执行的时候，JVM实际执行的是执行空间最上面的字节码！在某个时间片内，目前执行程序代码会被切换到不同空间上的不同方法。</li><li>线程要记录的一项事情是目前线程执行空间做到哪里：保护现场</li></ul><h1 id="实现多线程的两种方法"><a class="markdownIt-Anchor" href="#实现多线程的两种方法"></a> 实现多线程的两种方法</h1><h2 id="继承-thread-类开发多线程"><a class="markdownIt-Anchor" href="#继承-thread-类开发多线程"></a> 继承 <strong>Thread</strong> 类开发多线程</h2><ol><li><p>编写一个类，继承 <strong>java.lang.Thread</strong> 类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure></li><li><p>在这个类重写 <strong>java.lang.Thread</strong> 类中的函数：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>实例化线程对象，调用其 <strong>start()</strong> 函数启动该线程</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li></ol><h2 id="实现-runnable-接口开发多线程"><a class="markdownIt-Anchor" href="#实现-runnable-接口开发多线程"></a> 实现 <strong>Runnable</strong> 接口开发多线程</h2><ol><li><p>编写一个类，实现 <strong>java.lang.Runnable</strong> 接口</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure></li><li><p>在这个类中重写 <strong>java.lang.Runnable</strong> 接口中的函数：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>实例化 <strong>java.lang.Thread</strong> 对象，实例化上面编写的 <strong>Runnable</strong> 实现类，将后者传入 <strong>Thread</strong> 对象的构造函数，调用 <strong>Thread</strong> 对象的 <strong>start()</strong> 函数来启动线程</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Runnable threadJob = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(threadJob);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li></ol><h1 id="两种方法比较"><a class="markdownIt-Anchor" href="#两种方法比较"></a> 两种方法比较</h1><ol><li>第一种每个对象都是一个线程，而第二种每个对象不是一个线程，必须将其传入Thread对象才能运行</li><li>第一种每个线程都有自己的成员变量，而第二种共享成员变量</li><li>Java不支持多重继承，只能继承一个类，但是可以实现多个接口，第一种方法虽然较简单，但是扩展性没有第二种强</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除排序数组中的重复项</title>
      <link href="/2019/10/22/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2019/10/22/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度，不需要考虑超出新长度后面的元素。</p><a id="more"></a><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><ul><li>如果题目没要求O(1)，可以直接用LinkedHashSet解决。</li><li>即使不能有空间要求，这道题也比较简单。这是我第一次速度超过100%，哈哈哈哈哈<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191022112916.png" class="lazyload"></li></ul><h1 id="双指针法"><a class="markdownIt-Anchor" href="#双指针法"></a> 双指针法</h1><p>由于我的答案和LeetCode思路一样，所以我叫他双指针法。</p><ul><li>首先判断数组是不是空或者是不是长度为1，是的话直接返回数组长度</li><li>声明两个变量即 <strong>双指针</strong> ，一个快指针i，一个慢指针ans</li><li>快指针声明在for循环里，每次循环都 i++</li><li>慢指针声明在循环外，当 nums[i] != nums[i+1]时(即不重复时)，令nums[ans] = nums[i]，ans++</li><li>最后返回ans<br></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == nums.length-<span class="number">1</span> || nums[i] != nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            nums[ans] = nums[i];</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后贴上leetcode解法"><a class="markdownIt-Anchor" href="#最后贴上leetcode解法"></a> 最后贴上LeetCode解法</h1><p>思路基本一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>罗马数转整数</title>
      <link href="/2019/10/21/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E7%BD%97%E9%A9%AC%E6%95%B0%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
      <url>/2019/10/21/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E7%BD%97%E9%A9%AC%E6%95%B0%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>罗马数字包含以下七种字符: I(1), V(5), X(10), L(50), C(100), D(500), M(1000)，将一串罗马数转成整数。</p><a id="more"></a><p>通常情况下，罗马数字中小的数字在大的数字的右边。<br>但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。<br>一共有六个特例：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。</li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br></li></ul><h1 id="穷举法"><a class="markdownIt-Anchor" href="#穷举法"></a> 穷举法</h1><ul><li>首先将所有的组合添加到哈希表中，一共有13种</li><li>然后遍历字符串，由于组合只有两类，一类是1个字符，另一类是2个字符，其中，2个字符优先级较高</li><li>返回ans</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">"I"</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">"IV"</span>, <span class="number">4</span>);</span><br><span class="line">    map.put(<span class="string">"V"</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">"IX"</span>, <span class="number">9</span>);</span><br><span class="line">    map.put(<span class="string">"X"</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="string">"XL"</span>, <span class="number">40</span>);</span><br><span class="line">    map.put(<span class="string">"L"</span>, <span class="number">50</span>);</span><br><span class="line">    map.put(<span class="string">"XC"</span>, <span class="number">90</span>);</span><br><span class="line">    map.put(<span class="string">"C"</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">"CD"</span>, <span class="number">400</span>);</span><br><span class="line">    map.put(<span class="string">"D"</span>, <span class="number">500</span>);</span><br><span class="line">    map.put(<span class="string">"CM"</span>, <span class="number">900</span>);</span><br><span class="line">    map.put(<span class="string">"M"</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length();)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &lt; s.length() &amp;&amp; map.containsKey(s.substring(i, i+<span class="number">2</span>)))&#123;</span><br><span class="line">            ans += map.get(s.substring(i,i+<span class="number">2</span>));</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans += map.get(s.substring(i,i+<span class="number">1</span>));</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="更优解法"><a class="markdownIt-Anchor" href="#更优解法"></a> 更优解法</h1><p>因为通常情况下，罗马数字中小的数字在大的数字的右边，所以我们可以和下一个字符比大小，如果比它小，那么就是六种特例中的一种</p><ul><li>定义一个获取罗马字符对应数字的静态方法，使用switch来获取字符对应数字</li><li>遍历字符串，比较当前字符和下一字符的数字大小，大于则加，小于则减</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态方法获得罗马数对应的数字大小</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal character"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = getValue(s.charAt(i));</span><br><span class="line">        <span class="comment">//i为最后一个时，直接加</span></span><br><span class="line">        <span class="keyword">if</span>(i == n-<span class="number">1</span> || t &gt;= getValue(s.charAt(i+<span class="number">1</span>)))&#123;</span><br><span class="line">            ans += t;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans -= t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂等法</title>
      <link href="/2019/10/20/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AD%89%E6%B3%95/"/>
      <url>/2019/10/20/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AD%89%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>实现 <strong>pow(x,n)</strong> ，即求x的n次幂。使用暴力法超时，因而使用快速幂等法。</p><a id="more"></a><h1 id="快速幂等法"><a class="markdownIt-Anchor" href="#快速幂等法"></a> 快速幂等法</h1><p>要求一个数的n次幂，可以先求他的n/2次幂，一直分下去，简化问题，减少运算次数。<br>假设 A = x^(n/2)<br>如果 n%2 == 0，则 x^n = A * A;<br>如果 n%2 != 0，则 x^n = A * A * x;</p><ul><li>可以采用循环法或者是递归法解决问题，时间复杂度均为 <strong>O(logN)</strong></li></ul><h1 id="循环法"><a class="markdownIt-Anchor" href="#循环法"></a> 循环法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//n是32位有符号整数，其数值范围是[−2^31, 2^31 − 1]。</span></span><br><span class="line">        <span class="comment">//如果直接将其 -n 转化为正数，有可能导致溢出</span></span><br><span class="line">        <span class="comment">//所以采用long类型储存n</span></span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            N = -N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> current_product = x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = N; i &gt; <span class="number">0</span>; i /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = ans * current_product;</span><br><span class="line">            &#125;</span><br><span class="line">            current_product = current_product * current_product;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="递归法"><a class="markdownIt-Anchor" href="#递归法"></a> 递归法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> N = n;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        N = -N;</span><br><span class="line">        x = <span class="number">1</span>/x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> myFastPow(x, N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myFastPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">double</span> half = myFastPow(x, n/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> ==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> half*half;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> half*half*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="位运算法"><a class="markdownIt-Anchor" href="#位运算法"></a> 位运算法</h1><p>此外还有一种位运算的方法，只说思路：把指数部分转换成2进制，然后展开成2的幂次的和。借用网上的图展示关系<br>以 x 的 10 次方举例。10 的 2 进制是 1010，然后用 2 进制转 10 进制的方法把它展成 2 的幂次的和。<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191020143802.png" class="lazyload"><br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20191020143835.png" class="lazyload"></p><ul><li>时间复杂度为 <strong>O(N)</strong></li><li>以上算法空间复杂度均是 <strong>O(1)</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="/2019/10/19/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2019/10/19/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/LeetCode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>滑动窗口是数组/字符串问题中常用的抽象概念。</p><a id="more"></a><h1 id="无重复字符的最长子串-给定一个字符串请你找出其中-不含有重复字符-的-最长子串-的长度"><a class="markdownIt-Anchor" href="#无重复字符的最长子串-给定一个字符串请你找出其中-不含有重复字符-的-最长子串-的长度"></a> <strong>无重复字符的最长子串</strong> :给定一个字符串，请你找出其中 <strong>不含有重复字符</strong> 的 <strong>最长子串</strong> 的长度</h1><h2 id="暴力法"><a class="markdownIt-Anchor" href="#暴力法"></a> 暴力法</h2><p>如果使用暴力法，检查所有的子字符串，则时间复杂度为O(n^3)，耗费时间过多。暴力法会反复检查一个字符串是否含有重复的字符，浪费时间。</p><h2 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h2><p>窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j）（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。<br>-例:[i, j）向右滑动1个元素，则它将变为[i+1, j+1)<br>回到我们的问题，我们使用 HashSet 将字符存储在当前窗口 [i, j)（最初 j = i）中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。</p><h2 id="优化版的滑动窗口"><a class="markdownIt-Anchor" href="#优化版的滑动窗口"></a> 优化版的滑动窗口</h2><p>上述的方法最多需要执行 2n 个步骤。事实上，它可以被进一步优化为仅需要 n 个步骤。我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。</p><ul><li>也就是说，如果 j 对应的字符与[i, j-1]重复，则不再让 i++，而是直接跳过[i, j],令 i=j+1;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, n = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符对应的索引为下一次不重复的位置，即下一位置</span></span><br><span class="line">        <span class="comment">//例：j这个地方与前面重复了，则下一次不重复的位置为j+1</span></span><br><span class="line">        <span class="comment">//声明HashMap，形成字符到索引的映射</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="comment">//如果map中有s[j],则更新i</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(j)))&#123;</span><br><span class="line">                i = Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新ans</span></span><br><span class="line">            ans = Math.max(ans, j-i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将s[j]和它到索引的映射(下一个不重复的位置）加入map</span></span><br><span class="line">            <span class="comment">//若是已经重复，则是更新索引，更新为下一次不重复的位置</span></span><br><span class="line">            map.put(s.charAt(j), j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo + Github 图床</title>
      <link href="/2019/10/12/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/PicGo+Github%E5%AE%9E%E7%8E%B0%E5%BA%8A%E5%9B%BE/"/>
      <url>/2019/10/12/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/PicGo+Github%E5%AE%9E%E7%8E%B0%E5%BA%8A%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>昨天用了七牛云实现了床图，但是突然发现免费的只有30天的时间，到了时间就会换域名。之前的图床就失效了，于是转而薅Github的羊毛。</p><a id="more"></a><h1 id="picgo"><a class="markdownIt-Anchor" href="#picgo"></a> PicGo</h1><p>这是一款图片上传的工具，支持众多图床<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190909113126.png" class="lazyload"></p><h1 id="创建github图床"><a class="markdownIt-Anchor" href="#创建github图床"></a> 创建Github图床</h1><p>Github国内访问较慢，但是免费的，真香</p><h2 id="1注册github"><a class="markdownIt-Anchor" href="#1注册github"></a> 1.注册Github</h2><p>这个就不说呢</p><h2 id="2创建一个新公共仓库"><a class="markdownIt-Anchor" href="#2创建一个新公共仓库"></a> 2.创建一个新公共仓库</h2><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190909113644.png" class="lazyload"></p><h2 id="3生成一个token用于操作github仓库"><a class="markdownIt-Anchor" href="#3生成一个token用于操作github仓库"></a> 3.生成一个token用于操作Github仓库</h2><p>在个人 <strong>Settings</strong> / <strong>Developer settings</strong> / <strong>Personal access tokens</strong> 内 <strong>Generate new token</strong><br>只需勾选 <strong>repo</strong><br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190909114127.png" class="lazyload"></p><ul><li>创建成功后，会生成一串token，这串token只显示一次！<br></li></ul><h1 id="配置picgo"><a class="markdownIt-Anchor" href="#配置picgo"></a> 配置PicGo</h1><h2 id="1下载运行picgo"><a class="markdownIt-Anchor" href="#1下载运行picgo"></a> 1.下载运行PicGo</h2><p>在这个链接下下载<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">PicGo</a><br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190909114643.png" class="lazyload"></p><ul><li>mac 系统选择 .dmg 下载，windwos 选择 .exe系统</li></ul><h2 id="2配置图床"><a class="markdownIt-Anchor" href="#2配置图床"></a> 2.配置图床</h2><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190909114721.png" class="lazyload"></p><ul><li>设定仓库名的时候，是按照“账户名/仓库名的格式填写”</li><li>分支名统一填写“master”</li><li>存储的路径可以按照我这样子写，就会在仓库下创建一个“img”文件夹，当然也可以不填</li></ul><h2 id="3快捷键修改"><a class="markdownIt-Anchor" href="#3快捷键修改"></a> 3.快捷键修改</h2><p>根据个人习惯，我这里是这样配置的<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190909115028.png" class="lazyload"></p><h1 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h1><p>将上面的步骤都设置好之后，就可以让自己的Markdown文档更生动形象呢，每次截图之后，都可以按一下 <strong>ctrl+shift+c</strong>，这样就会将剪切板上面的截图转化为在线网络图片链接，十分快捷。<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/biubiubiu.gif" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+gayhub搭建个人博客</title>
      <link href="/2019/10/12/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/hexo+gayhub/"/>
      <url>/2019/10/12/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/hexo+gayhub/</url>
      
        <content type="html"><![CDATA[<p>经过<strong>学姐</strong>的安利，我用<strong>hexo+gayhub</strong>搭建起了第一个个人博客</p><a id="more"></a><h1 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h1><hr><ol><li>你要有个gayhub账号，虽然在国内访问较慢，但是免费，真香</li><li>安装node.js，npm(也可以装cnpm，为npm的淘宝镜像，国内访问速度快）</li><li>安装git</li><li>有台Windows电脑，还有个女朋友</li></ol><hr><h1 id="创建github博客"><a class="markdownIt-Anchor" href="#创建github博客"></a> 创建github博客</h1><h2 id="1-新建仓库"><a class="markdownIt-Anchor" href="#1-新建仓库"></a> 1. 新建仓库</h2><p>在github上新建个仓库，命名规则必须为：<strong><a href="http://xn--6qqv7i14ofosyrb.github.io" target="_blank" rel="noopener">你的用户名.github.io</a></strong>(我也不知道为什么要这样子哈)，如果没钱的话这个就是你以后的博客地址了。</p><h2 id="2绑定域名"><a class="markdownIt-Anchor" href="#2绑定域名"></a> 2.绑定域名</h2><p>由于我没有钱，所以绑定域名就不说了，你可以买个域名，然后把域名的地址跳转到<strong><a href="http://xn--6qqv7i14ofosyrb.github.io" target="_blank" rel="noopener">你的用户名.github.io</a></strong>就行了。</p><h2 id="3配置ssh"><a class="markdownIt-Anchor" href="#3配置ssh"></a> 3.配置SSH</h2><p>这个有什么用呢？给你的博客加个密，防止其他人提交代码。<br>打开cmd输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/. ssh #检查本机已存在的ssh密钥</span><br></pre></td></tr></table></figure><p>如果提示：No such file or directory 说明你是第一次使用git。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><p>连续三次回车就行了<br>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到 <strong>.ssh\id_rsa.pub</strong> 文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：<br>将刚复制的内容粘贴到key那里，title随便填，保存.</p><h3 id="测试是否成功"><a class="markdownIt-Anchor" href="#测试是否成功"></a> 测试是否成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com # 注意邮箱地址不用改</span><br></pre></td></tr></table></figure><p>然后yes就行了。<br>此外你还配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;****&quot;// 你的github用户名，非昵称</span><br><span class="line">$ git config --global user.email  &quot;xxx@qq.com&quot;// 填写你的github注册邮箱</span><br></pre></td></tr></table></figure><p>这个具体是什么呢？我也不知道呀</p><h1 id="安装hexo"><a class="markdownIt-Anchor" href="#安装hexo"></a> 安装hexo</h1><h2 id="首先我们安装个cnpm"><a class="markdownIt-Anchor" href="#首先我们安装个cnpm"></a> 首先我们安装个cnpm</h2><p>前面也说过了，加快下载速度。<br>我们要用npm下载cnpm，然后以后都用cnpm代替npm (npm:???!!!)<br>在你的blog文件夹，在空白处点击鼠标右键，选择 <strong>Git Bash Here</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install cnpm -g --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><ul><li>开始安装hexo</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm intall -g hexo-cli </span><br><span class="line">#这里原本是 npm intall -g hexo-cli ，但是下载速度较慢所以切换成cnpm，以后都如此</span><br></pre></td></tr></table></figure><p>验证是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>如果你看不到error，那应该就是成功了，哈</p><ul><li>重要的一步来了，初始化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>如果最后一行出现 <strong>Start blogging with Hexo!</strong><br>恭喜你，可以开始编写博客了</p><h2 id="先测试一下"><a class="markdownIt-Anchor" href="#先测试一下"></a> 先测试一下</h2><p>我们经常用的指令是以下几个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean #用来清理缓存文件</span><br><span class="line">hexo g     #hexo generate的缩写，生成文件</span><br><span class="line">hexo s     #hexo serve的缩写，生成本地预览</span><br><span class="line">hexo d     #hexo deploy的缩写，部署到服务器</span><br></pre></td></tr></table></figure><p>还有一个组合指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并部署</span><br></pre></td></tr></table></figure><ul><li>测试本地运行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>打开浏览器，进入 <strong>localhost:4000</strong>，你会看到hexo自带的一个主题还有 <strong>Hello World</strong></p><h1 id="更换主题"><a class="markdownIt-Anchor" href="#更换主题"></a> 更换主题</h1><p>我最喜欢的就是美化了</p><ul><li>由于网上比较推荐的是 <strong>yilia</strong>，所以我下载了它。<br>首先下载这个主题，在你的文件夹你 <strong>Git Bash Here</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><p>下载的主题都在 <strong>themes</strong> 文件夹<br>修改源文件夹下的 <strong>_config.yml</strong> 中的 <strong>theme: landscape</strong> 改为<strong>theme: yilia</strong> ，然后重新执行 <strong>hexo g</strong> 来重新生成。<br><strong>hexo s</strong> 后进入 <strong>localhost:4000</strong> 就能预览你的主题了。<br>如果出现一些莫名其妙的问题，可以先执行 <strong>hexo clean</strong> 来清理一下内容，然后再来重新生成和发布。</p><ul><li>你可以在 <strong>themes</strong>文件夹下的 <strong>_config.yml</strong> 修改有关主题的内容，这里不多加详述了。</li></ul><h1 id="部署到github"><a class="markdownIt-Anchor" href="#部署到github"></a> 部署到Github</h1><p>如果你一切都配置好了，发布上传很容易，一句 <strong>hexo d</strong> 就搞定，当然关键还是你要把所有东西配置好。</p><ul><li>首先，<strong>ssh key</strong>肯定要配置好。</li><li>其次，配置 <strong>_config.yml</strong> 中有关 <strong>deploy</strong>的部分：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: github</span><br><span class="line">  repository: https://github.com/******.github.io.git #你的仓库地址</span><br><span class="line">  branch: master</span><br><span class="line">#注意空格</span><br></pre></td></tr></table></figure><ul><li>此外还装一个插件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ul><li>最后的最后<br><strong>hexo d</strong>就能把你的博客部署到GitHub上了。<br>以后你可以打开 <strong><a href="http://xn--6qqv7i14ofosyrb.github.io" target="_blank" rel="noopener">你的用户名.github.io</a></strong>，进入你的博客。<br>#可以写博客了</li><li>由于我基本不会命令行，所以我没用命令行。<br>你可以直接新建一个 <strong>.md</strong>的文件，然后用 <strong>Markdown</strong>的编辑器打开就可以开始写你的博客了（我用的编辑器是 <strong>VSCode</strong> + <strong>Markdown Preview Enhanced插件</strong>），这里的 <strong>.md</strong>的文件使用 <strong>Markdown</strong>语法写的，十分简单 ，几分钟速成。<br>写好后，把文件放在你的文件夹下的 <strong>source/_posts</strong>就行了。<br>然后用组合命令行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>就能直接生成本地文件并且部署到服务器上。</p><h1 id="最终效果"><a class="markdownIt-Anchor" href="#最终效果"></a> 最终效果</h1><p>也就是本博客 <strong><a href="http://EasonZzZz.github.io" target="_blank" rel="noopener">EasonZzZz.github.io</a></strong><br><img alt data-src="http://pxij6pdrn.bkt.clouddn.com/static/images/biubiubiu.gif" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm(cnpm)安装/卸载模块</title>
      <link href="/2019/10/12/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/cnpm%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/10/12/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/cnpm%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>因为发现七牛云不行，所以卸载了有关的插件。</p><a id="more"></a><h1 id="安装模块"><a class="markdownIt-Anchor" href="#安装模块"></a> 安装模块</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install xxx      #利用 npm 安装xxx模块到当前命令行所在目录</span><br><span class="line">npm install -g xxx   #利用npm安装全局模块xxx</span><br></pre></td></tr></table></figure><h1 id="本地安装时将模块写入-packagejson"><a class="markdownIt-Anchor" href="#本地安装时将模块写入-packagejson"></a> 本地安装时将模块写入 <strong>package.json</strong></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install xxx             #安装但不写入package.json</span><br><span class="line">npm install xxx –save       #安装并写入package.json的”dependencies”中</span><br><span class="line">npm install xxx –save -dev  #安装并写入package.json的”devDependencies”中</span><br></pre></td></tr></table></figure><h1 id="删除模块"><a class="markdownIt-Anchor" href="#删除模块"></a> 删除模块</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall xxx      #删除xxx模块</span><br><span class="line">npm uninstall -g xxx   #删除全局模块xxx</span><br></pre></td></tr></table></figure><p><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/biubiubiu.gif" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK-13配置环境</title>
      <link href="/2019/10/12/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/JDK-13%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/10/12/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/JDK-13%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>目前最新JDK-13的配置环境方法，虽然我也不懂为什么这样弄，但是能用就行。</p><a id="more"></a><h1 id="下载并安装jdk-13"><a class="markdownIt-Anchor" href="#下载并安装jdk-13"></a> 下载并安装JDK-13</h1><p>当然实在 <a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">官网</a> 下载了</p><h1 id="生成jre文件夹"><a class="markdownIt-Anchor" href="#生成jre文件夹"></a> 生成jre文件夹</h1><p>打开cmd，cd到D:\Java\jdk-13(你的安装文件夹) 然后输入并运行命令：bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre</p><h1 id="配置jdk-13环境"><a class="markdownIt-Anchor" href="#配置jdk-13环境"></a> 配置JDK-13环境</h1><h2 id="系统变量添加"><a class="markdownIt-Anchor" href="#系统变量添加"></a> 系统变量添加</h2><ul><li>Java_Home  D:\Java\jdk-13</li><li>ClassPath  .;%Java_Home%\bin;%Java_Home%\lib\dt.jar;%Java_Home%\lib\tools.jar(注意.号)</li></ul><h2 id="系统变量path里追加"><a class="markdownIt-Anchor" href="#系统变量path里追加"></a> 系统变量Path里追加</h2><ul><li>;%Java_Home%\bin;%Java_Home%\jre\bin</li></ul><h1 id="最后检查是否成功"><a class="markdownIt-Anchor" href="#最后检查是否成功"></a> 最后检查是否成功</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">javac</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><p>能看到很多东西应该就是成功了，哈哈哈哈哈</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习之旅————单例模式</title>
      <link href="/2019/10/12/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/10/12/%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>郭克华老师在上课讲到的一种设计模式—单例模式。<br>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建 <strong>单一对象</strong> 的最佳方式。</p><a id="more"></a><h1 id="那么问题来了为什么创建单一对象呢"><a class="markdownIt-Anchor" href="#那么问题来了为什么创建单一对象呢"></a> 那么问题来了，为什么创建单一对象呢?</h1><p>有一些实例只需要创建一次就够了，例如：一个班级只有一个班主任，Windows系统只有一个Task Manager(任务管理器)</p><h1 id="单例模式有什么优缺点呢"><a class="markdownIt-Anchor" href="#单例模式有什么优缺点呢"></a> 单例模式有什么优缺点呢？</h1><h2 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h2><ul><li>1.在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。<br></li><li>2.避免对资源的多重占用（比如写文件操作）。</li><li></li></ul><h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2><ul><li>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。<br></li></ul><hr><h1 id="如何实现单例模式"><a class="markdownIt-Anchor" href="#如何实现单例模式"></a> 如何实现单例模式</h1><p>我们将创建一个 SingleObject 类。SingleObject 类有它的 <strong>私有构造函数</strong> 和本身的一个 <strong>静态实例</strong>。<br>SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。<br><img alt data-src="https://raw.githubusercontent.com/EasonZzZz/BlogPic/master/img/20190925152915.png" class="lazyload"></p><h2 id="step-1"><a class="markdownIt-Anchor" href="#step-1"></a> Step 1</h2><p>创建一个SingleObject类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建SingleObject的一个私有静态对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance = <span class="keyword">new</span> SingObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给外面一个接口，返回唯一可用对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="step-2"><a class="markdownIt-Anchor" href="#step-2"></a> Step 2</h2><p>在外界声明个SingleObject的引用，获取该唯一对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SingleObject instance = SingleObject.getInstance();</span><br></pre></td></tr></table></figure><hr><h1 id="这里的实现方式只是一个大致的抽象方法更详细的如下"><a class="markdownIt-Anchor" href="#这里的实现方式只是一个大致的抽象方法更详细的如下"></a> 这里的实现方式只是一个大致的抽象方法，更详细的如下</h1><ul><li>懒汉式—线程不安全：最基础的实现方式，线程上下文单例，不需要共享给所有线程，也不需要加synchronize之类的锁，以提高性能</li><li>懒汉式—线程安全：加上synchronize之类保证线程安全的基础上的懒汉模式，相对性能很低，大部分时间并不需要同步</li><li>饿汉方式。指全局的单例实例在类装载时构建。</li><li>双检锁式。在懒汉式基础上利用synchronize关键字和volatile关键字确保第一次创建时没有线程间竞争而产生多个实例，仅第一次创建时同步，性能相对较高</li><li>登记式。作为创建类的全局属性存在，创建类被装载时创建</li><li>枚举。java中枚举类本身也是一种单例模式</li></ul><hr><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>单例模式是设计模式中最简单的形式之一。这一模式的目的是使得类的一个对象成为系统中的唯一实例。它有很多种实现方式，但是文中只给出了大致的思路，以后再学习更进一步的实现方式。</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
